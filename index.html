<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>CONTRA FORCE ‚Äî HTML5</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: #000;
    min-height: 100vh;
    overflow: hidden;
    font-family: 'Press Start 2P', monospace;
  }

  #gameWrapper {
    position: absolute;
    image-rendering: pixelated;
    transform-origin: top left;
  }

  canvas {
    display: block;
    image-rendering: pixelated;
    border: 2px solid #333;
  }

  #overlay {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    display: flex;
    flex-direction: column;
    justify-content: flex-start;
    align-items: center;
    background: rgba(0,0,0,0.85);
    z-index: 10;
    color: #fff;
    text-align: center;
    gap: 14px;
    overflow-y: auto;
    padding: 18px 10px;
    box-sizing: border-box;
  }

  #overlay.hidden { display: none; }

  #overlay h1 {
    font-size: 28px;
    color: #ff4444;
    text-shadow: 0 0 20px #ff0000, 0 0 40px #ff0000;
    letter-spacing: 4px;
  }

  #overlay h2 {
    font-size: 14px;
    color: #ffcc00;
    text-shadow: 0 0 10px #ffaa00;
  }

  #overlay .subtitle {
    font-size: 9px;
    color: #aaa;
    margin-top: 10px;
  }

  #overlay .blink {
    font-size: 11px;
    color: #fff;
    animation: blink 1s infinite;
    margin-top: 30px;
  }

  @keyframes blink {
    0%, 100% { opacity: 1; }
    50% { opacity: 0; }
  }

  #overlay .controls-info {
    font-size: 8px;
    color: #888;
    line-height: 2;
    margin-top: 10px;
  }

  #startBtn {
    margin-top: 20px;
    padding: 12px 32px;
    font-family: 'Press Start 2P', monospace;
    font-size: 12px;
    background: linear-gradient(135deg, #ff4444, #ff2222);
    color: #fff;
    border: 2px solid #ff8888;
    border-radius: 4px;
    cursor: pointer;
    text-shadow: 1px 1px 2px #000;
    box-shadow: 0 4px 15px rgba(255, 0, 0, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.2);
    transition: all 0.2s;
    touch-action: manipulation;
    -webkit-user-select: none;
    user-select: none;
  }

  #startBtn:hover {
    background: linear-gradient(135deg, #ff6666, #ff4444);
    box-shadow: 0 6px 20px rgba(255, 0, 0, 0.6), inset 0 1px 0 rgba(255, 255, 255, 0.3);
    transform: translateY(-2px);
  }

  #startBtn:active {
    transform: translateY(0);
    box-shadow: 0 2px 8px rgba(255, 0, 0, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.2);
  }

  #startBtn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  #hud {
    position: absolute;
    top: 8px;
    left: 8px;
    right: 8px;
    display: flex;
    justify-content: space-between;
    font-size: 10px;
    color: #fff;
    text-shadow: 1px 1px 0 #000, -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000;
    z-index: 5;
    pointer-events: none;
  }

  #hud.hidden { display: none; }

  .hud-left, .hud-right { display: flex; gap: 20px; }

  .lives-display { color: #ff4444; }
  .score-display { color: #ffcc00; }
  .weapon-display { color: #44ff44; }
  .stage-display { color: #44aaff; }
  .zoom-display { color: #aaaaaa; font-size: 10px; }

  #adminToggleBtn {
    position: fixed;
    bottom: 10px; right: 10px;
    width: 36px; height: 36px;
    background: rgba(20,20,40,0.85);
    border: 1px solid #555;
    border-radius: 6px;
    color: #ccc;
    font-size: 18px;
    cursor: pointer;
    z-index: 99;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.15s;
  }
  #adminToggleBtn:hover { background: rgba(50,40,80,0.95); border-color: #aa88ff; color: #fff; }

  /* --- GAME MODE SELECTOR --- */
  .mode-selector { display:flex; flex-wrap:wrap; gap:6px; justify-content:center; margin:8px 0; }
  .mode-btn {
    padding:6px 10px; font-family:'Press Start 2P',monospace; font-size:6px;
    background:rgba(20,20,40,0.8); color:#888; border:1px solid #444;
    border-radius:4px; cursor:pointer; transition:all 0.2s; text-align:center; min-width:80px;
  }
  .mode-btn:hover { border-color:#aaa; color:#ccc; background:rgba(40,40,60,0.9); }
  .mode-btn.active { color:#fff; border-color:#ff4444; background:rgba(80,20,20,0.8); text-shadow:0 0 6px #ff0000; }
  .mode-btn .mode-icon { font-size:14px; display:block; margin-bottom:3px; }
  .mode-btn .mode-label { display:block; }

  /* --- CHALLENGE MODAL --- */
  .challenge-modal {
    position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
    background:rgba(10,10,20,0.97); border:2px solid #ff8800; border-radius:8px;
    padding:16px; z-index:20; color:#fff; font-family:'Press Start 2P',monospace;
    width:420px; max-height:320px; overflow-y:auto; display:none;
  }
  .challenge-modal.open { display:block; }
  .challenge-item {
    display:flex; align-items:center; gap:8px; padding:6px 8px; margin:4px 0;
    background:rgba(30,30,50,0.8); border:1px solid #333; border-radius:4px; cursor:pointer;
    transition:all 0.15s;
  }
  .challenge-item:hover { border-color:#ff8800; background:rgba(50,40,20,0.8); }
  .challenge-item.completed { border-color:#44ff44; }
  .challenge-item .ch-icon { font-size:16px; }
  .challenge-item .ch-info { flex:1; }
  .challenge-item .ch-name { font-size:7px; color:#ffcc44; display:block; }
  .challenge-item .ch-desc { font-size:5px; color:#888; display:block; margin-top:2px; }
  .challenge-item .ch-status { font-size:8px; }

  /* --- ADMIN PANEL --- */
  #adminPanel {
    position: fixed;
    top: 0; right: 0;
    width: 320px;
    height: 100vh;
    background: rgba(10, 10, 20, 0.95);
    border-left: 2px solid #444;
    color: #ccc;
    font-family: 'Segoe UI', Arial, sans-serif;
    font-size: 12px;
    overflow-y: auto;
    z-index: 100;
    display: none;
    padding: 0;
    scrollbar-width: thin;
    scrollbar-color: #555 #1a1a2e;
  }
  #adminPanel.open { display: block; }
  #adminPanel::-webkit-scrollbar { width: 6px; }
  #adminPanel::-webkit-scrollbar-track { background: #1a1a2e; }
  #adminPanel::-webkit-scrollbar-thumb { background: #555; border-radius: 3px; }

  .admin-header {
    background: linear-gradient(135deg, #2a1a3e, #1a2a4e);
    padding: 12px 14px;
    font-family: 'Press Start 2P', monospace;
    font-size: 11px;
    color: #ff4444;
    text-shadow: 0 0 8px #ff0000;
    border-bottom: 1px solid #444;
    display: flex;
    justify-content: space-between;
    align-items: center;
    position: sticky; top: 0; z-index: 1;
  }
  .admin-header span { color: #888; font-size: 8px; font-family: 'Segoe UI', sans-serif; cursor: pointer; }

  .admin-section {
    border-bottom: 1px solid #333;
    padding: 0;
  }
  .admin-section-title {
    padding: 8px 14px;
    background: rgba(255,255,255,0.04);
    color: #88aaff;
    font-weight: bold;
    font-size: 10px;
    text-transform: uppercase;
    letter-spacing: 1px;
    cursor: pointer;
    user-select: none;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  .admin-section-title:hover { background: rgba(255,255,255,0.08); }
  .admin-section-title::after { content: '‚ñº'; font-size: 8px; color: #666; transition: transform 0.2s; }
  .admin-section.collapsed .admin-section-title::after { content: '‚ñ∂'; }
  .admin-section.collapsed .admin-section-body { display: none; }
  .admin-section-body { padding: 8px 14px 12px; }

  .admin-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 6px;
  }
  .admin-row label {
    flex: 1;
    font-size: 11px;
    color: #aaa;
  }
  .admin-row input[type="range"] {
    width: 100px;
    accent-color: #ff4444;
    cursor: pointer;
  }
  .admin-row .val {
    width: 40px;
    text-align: right;
    font-size: 10px;
    color: #ffcc00;
    font-family: monospace;
  }
  .admin-row input[type="checkbox"] {
    accent-color: #44ff44;
    width: 16px; height: 16px;
    cursor: pointer;
  }

  .admin-btn {
    display: inline-block;
    padding: 5px 10px;
    margin: 2px;
    background: #2a2a4e;
    border: 1px solid #555;
    color: #ccc;
    font-size: 10px;
    cursor: pointer;
    border-radius: 3px;
    font-family: inherit;
  }
  .admin-btn:hover { background: #3a3a6e; border-color: #888; color: #fff; }
  .admin-btn.active { background: #443366; border-color: #aa88ff; color: #fff; }
  .admin-btn.danger { border-color: #aa3333; }
  .admin-btn.danger:hover { background: #4e2a2a; border-color: #ff4444; }

  .editor-bar {
    display: flex; gap: 4px; flex-wrap: wrap; margin-bottom: 6px;
  }
  .editor-bar .admin-btn.selected { background: #446644; border-color: #88ff88; color: #88ff88; }

  .admin-grid-info {
    font-size: 9px;
    color: #666;
    margin-top: 4px;
    font-style: italic;
  }

  .keybind-row {
    display: flex;
    align-items: center;
    margin-bottom: 5px;
  }
  .keybind-row .kb-label {
    width: 60px;
    font-size: 11px;
    color: #aaa;
    text-transform: capitalize;
  }
  .keybind-row .kb-keys {
    display: flex;
    gap: 4px;
    flex: 1;
  }
  .kb-btn {
    display: inline-block;
    padding: 3px 8px;
    background: #1a1a3e;
    border: 1px solid #555;
    border-radius: 3px;
    color: #ddd;
    font-size: 10px;
    font-family: 'Segoe UI', monospace;
    cursor: pointer;
    min-width: 40px;
    text-align: center;
    transition: all 0.15s;
  }
  .kb-btn:hover { border-color: #88aaff; color: #fff; background: #2a2a5e; }
  .kb-btn.listening {
    border-color: #ffcc00;
    color: #ffcc00;
    background: #2a2a1e;
    animation: blink 0.6s infinite;
  }
  .kb-btn.kb-add {
    color: #666;
    border-style: dashed;
    min-width: 26px;
    padding: 3px 5px;
    font-size: 12px;
  }
  .kb-btn.kb-add:hover { color: #aaa; border-color: #888; }
  .kb-btn .kb-remove {
    margin-left: 4px;
    color: #884444;
    cursor: pointer;
    font-size: 9px;
  }

  /* --- MOBILE TOUCH CONTROLS --- */
  #touchControls {
    display: none;
    position: fixed;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 140px;
    background: linear-gradient(180deg, rgba(0,0,0,0), rgba(0,0,0,0.7));
    z-index: 50;
    pointer-events: none;
  }

  #touchControls.visible { display: flex; pointer-events: auto; }

  /* D-Pad (left side) */
  .touch-dpad {
    position: absolute;
    bottom: 10px;
    left: 10px;
    width: 100px;
    height: 100px;
    display: grid;
    grid-template-columns: 1fr 1fr 1fr;
    grid-template-rows: 1fr 1fr 1fr;
    gap: 2px;
    pointer-events: auto;
  }

  .dpad-btn {
    background: rgba(100,100,150,0.6);
    border: 2px solid #666;
    border-radius: 4px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 20px;
    color: #aaa;
    user-select: none;
    -webkit-user-select: none;
    -webkit-touch-callout: none;
    cursor: pointer;
    transition: all 0.1s;
    touch-action: none;
  }

  .dpad-btn:active,
  .dpad-btn.active {
    background: rgba(150,150,200,0.9);
    border-color: #aaa;
    color: #fff;
    transform: scale(0.95);
  }

  /* D-Pad center (empty) */
  .dpad-center { grid-area: 2 / 2; pointer-events: none; background: none; border: none; }

  /* Action buttons (right side) */
  .touch-actions {
    position: absolute;
    bottom: 10px;
    right: 10px;
    display: flex;
    gap: 8px;
    flex-direction: column;
    pointer-events: auto;
  }

  .action-row {
    display: flex;
    gap: 8px;
  }

  .touch-btn {
    width: 50px;
    height: 50px;
    border-radius: 50%;
    background: rgba(150,80,80,0.7);
    border: 2px solid #666;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 18px;
    color: #aaa;
    user-select: none;
    -webkit-user-select: none;
    -webkit-touch-callout: none;
    cursor: pointer;
    transition: all 0.1s;
    touch-action: none;
  }

  .touch-btn:active,
  .touch-btn.active {
    background: rgba(200,100,100,0.95);
    border-color: #ff6666;
    color: #fff;
    transform: scale(0.9);
  }

  .touch-btn.jump { background: rgba(100,150,100,0.7); }
  .touch-btn.jump:active,
  .touch-btn.jump.active { background: rgba(150,200,150,0.95); border-color: #66ff66; color: #fff; }

  .touch-btn.grapple { background: rgba(80,120,180,0.7); }
  .touch-btn.grapple:active,
  .touch-btn.grapple.active { background: rgba(100,150,220,0.95); border-color: #6699ff; color: #fff; }

  /* Touch Control Size Variants */
  #touchControls.size-small .touch-dpad { width: 70px; height: 70px; }
  #touchControls.size-small .dpad-btn { font-size: 14px; }
  #touchControls.size-small .touch-btn { width: 40px; height: 40px; font-size: 10px; }
  #touchControls.size-small .touch-actions { gap: 6px; }
  #touchControls.size-small .action-row { gap: 6px; }

  /* Default is medium (100px dpad, 50px buttons) */
  #touchControls.size-medium .touch-dpad { width: 100px; height: 100px; }
  #touchControls.size-medium .dpad-btn { font-size: 20px; }
  #touchControls.size-medium .touch-btn { width: 50px; height: 50px; font-size: 11px; }
  #touchControls.size-medium .touch-actions { gap: 8px; }
  #touchControls.size-medium .action-row { gap: 8px; }

  #touchControls.size-large .touch-dpad { width: 130px; height: 130px; }
  #touchControls.size-large .dpad-btn { font-size: 28px; }
  #touchControls.size-large .touch-btn { width: 65px; height: 65px; font-size: 13px; }
  #touchControls.size-large .touch-actions { gap: 10px; }
  #touchControls.size-large .action-row { gap: 10px; }

  /* Size selector */
  #touchSizeSelector {
    position: absolute;
    bottom: 150px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 4px;
    z-index: 100;
    pointer-events: auto;
  }

  .size-btn {
    width: 28px;
    height: 28px;
    padding: 0;
    font-size: 10px;
    background: rgba(100,100,120,0.7);
    border: 1px solid #666;
    border-radius: 3px;
    color: #aaa;
    cursor: pointer;
    transition: all 0.15s;
    font-family: 'Press Start 2P', monospace;
    display: flex;
    align-items: center;
    justify-content: center;
    touch-action: none;
    -webkit-user-select: none;
    user-select: none;
  }

  .size-btn:hover,
  .size-btn.active {
    background: rgba(150,150,180,0.9);
    border-color: #aaa;
    color: #fff;
  }

  .size-btn.active {
    background: rgba(100,150,100,0.9);
    border-color: #66ff66;
    color: #66ff66;
  }

  /* Show controls on mobile/touch devices */
  @media (max-width: 768px) {
    #touchControls { display: flex; }
    #adminToggleBtn { bottom: 160px; }
  }

  /* Landscape mode adjustments */
  @media (max-height: 500px) {
    #touchControls { height: auto; padding-bottom: 10px; }
    #touchControls.size-small { height: auto; }
    #touchControls.size-medium { height: auto; }
    #touchControls.size-large { height: auto; }
    #adminToggleBtn { bottom: auto; bottom: 140px; }
  }
  .kb-btn .kb-remove:hover { color: #ff4444; }

  /* --- ACHIEVEMENT TOAST --- */
  #achievementToast {
    position: fixed;
    top: -80px;
    left: 50%;
    transform: translateX(-50%);
    background: linear-gradient(135deg, rgba(20,10,40,0.97), rgba(40,20,60,0.97));
    border: 2px solid #ffaa00;
    border-radius: 8px;
    padding: 10px 20px;
    display: flex;
    align-items: center;
    gap: 12px;
    z-index: 200;
    transition: top 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
    box-shadow: 0 4px 25px rgba(255, 170, 0, 0.4), inset 0 1px 0 rgba(255,255,255,0.1);
    min-width: 280px;
    max-width: 420px;
  }
  #achievementToast.show { top: 16px; }
  #achievementToast .toast-icon {
    font-size: 28px;
    filter: drop-shadow(0 0 6px rgba(255,200,0,0.6));
    flex-shrink: 0;
  }
  #achievementToast .toast-body { display: flex; flex-direction: column; gap: 3px; }
  #achievementToast .toast-label {
    font-family: 'Press Start 2P', monospace;
    font-size: 7px;
    color: #ffaa00;
    text-transform: uppercase;
    letter-spacing: 2px;
  }
  #achievementToast .toast-name {
    font-family: 'Press Start 2P', monospace;
    font-size: 10px;
    color: #fff;
    text-shadow: 0 0 8px rgba(255,255,255,0.4);
  }
  #achievementToast .toast-desc {
    font-size: 9px;
    color: #aaa;
    font-family: 'Segoe UI', sans-serif;
  }

  /* --- ACHIEVEMENTS & LEADERBOARD PANELS --- */
  #achievementsPanel, #leaderboardPanel {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background: rgba(0,0,0,0.92);
    z-index: 150;
    display: none;
    flex-direction: column;
    align-items: center;
    padding: 30px 20px;
    overflow-y: auto;
    color: #fff;
  }
  #achievementsPanel.open, #leaderboardPanel.open { display: flex; }

  .panel-title {
    font-family: 'Press Start 2P', monospace;
    font-size: 16px;
    color: #ffaa00;
    text-shadow: 0 0 15px rgba(255,170,0,0.5);
    margin-bottom: 6px;
  }
  .panel-subtitle {
    font-size: 10px;
    color: #888;
    margin-bottom: 20px;
    font-family: 'Segoe UI', sans-serif;
  }
  .panel-close {
    position: absolute;
    top: 12px; right: 16px;
    font-family: 'Press Start 2P', monospace;
    font-size: 10px;
    color: #888;
    cursor: pointer;
    transition: color 0.15s;
    z-index: 2;
  }
  .panel-close:hover { color: #ff4444; }

  .achievement-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(260px, 1fr));
    gap: 10px;
    width: 100%;
    max-width: 600px;
  }
  .ach-card {
    background: rgba(30,20,50,0.8);
    border: 1px solid #333;
    border-radius: 6px;
    padding: 10px 12px;
    display: flex;
    align-items: center;
    gap: 10px;
    transition: border-color 0.2s, background 0.2s;
  }
  .ach-card.unlocked {
    border-color: #ffaa00;
    background: rgba(60,40,10,0.5);
  }
  .ach-card.locked { opacity: 0.5; }
  .ach-card .ach-icon { font-size: 24px; flex-shrink: 0; }
  .ach-card.locked .ach-icon { filter: grayscale(1) brightness(0.5); }
  .ach-card .ach-info { display: flex; flex-direction: column; gap: 3px; }
  .ach-card .ach-name {
    font-family: 'Press Start 2P', monospace;
    font-size: 8px;
    color: #fff;
  }
  .ach-card.locked .ach-name { color: #666; }
  .ach-card .ach-desc {
    font-size: 9px;
    color: #999;
    font-family: 'Segoe UI', sans-serif;
  }
  .ach-card .ach-time {
    font-size: 8px;
    color: #666;
    font-family: 'Segoe UI', sans-serif;
    margin-top: 2px;
  }
  .ach-progress-bar {
    width: 100%;
    height: 4px;
    background: #222;
    border-radius: 2px;
    margin-top: 4px;
    overflow: hidden;
  }
  .ach-progress-fill {
    height: 100%;
    background: linear-gradient(90deg, #ffaa00, #ffcc44);
    border-radius: 2px;
    transition: width 0.3s;
  }

  /* Leaderboard table */
  .lb-table {
    width: 100%;
    max-width: 500px;
    border-collapse: collapse;
    margin-top: 10px;
  }
  .lb-table th {
    font-family: 'Press Start 2P', monospace;
    font-size: 8px;
    color: #ffaa00;
    padding: 8px 6px;
    border-bottom: 2px solid #ffaa00;
    text-align: left;
  }
  .lb-table td {
    font-family: 'Segoe UI', sans-serif;
    font-size: 11px;
    padding: 7px 6px;
    border-bottom: 1px solid #222;
    color: #ccc;
  }
  .lb-table tr.highlight td {
    color: #ffcc00;
    font-weight: bold;
    background: rgba(255,170,0,0.08);
  }
  .lb-table .lb-rank { width: 40px; text-align: center; }
  .lb-table .lb-rank-gold { color: #ffd700; }
  .lb-table .lb-rank-silver { color: #c0c0c0; }
  .lb-table .lb-rank-bronze { color: #cd7f32; }
  .lb-empty {
    text-align: center;
    color: #555;
    font-size: 10px;
    padding: 30px;
    font-family: 'Segoe UI', sans-serif;
  }
  .lb-clear-btn {
    margin-top: 16px;
    padding: 6px 16px;
    font-family: 'Press Start 2P', monospace;
    font-size: 7px;
    background: rgba(80,20,20,0.6);
    color: #ff6666;
    border: 1px solid #ff4444;
    border-radius: 4px;
    cursor: pointer;
    transition: background 0.15s;
  }
  .lb-clear-btn:hover { background: rgba(120,30,30,0.8); }

  /* HUD achievement counter */
  .ach-hud-btn {
    cursor: pointer;
    pointer-events: auto;
    color: #ffaa00;
    transition: color 0.15s;
  }
  .ach-hud-btn:hover { color: #ffdd44; }

  /* --- DIFFICULTY SELECTOR --- */
  .diff-selector {
    display: flex;
    gap: 6px;
    margin: 6px 0;
    flex-wrap: wrap;
    justify-content: center;
  }
  .diff-btn {
    padding: 6px 14px;
    font-family: 'Press Start 2P', monospace;
    font-size: 8px;
    background: rgba(30,30,50,0.8);
    border: 2px solid #555;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.15s;
    color: #888;
    text-shadow: none;
  }
  .diff-btn:hover { border-color: #aaa; color: #fff; }
  .diff-btn.active { transform: scale(1.05); }
  .diff-btn[data-diff="easy"] { border-color: #44cc44; color: #44cc44; }
  .diff-btn[data-diff="easy"].active { background: rgba(40,100,40,0.4); box-shadow: 0 0 12px rgba(68,204,68,0.3); }
  .diff-btn[data-diff="normal"] { border-color: #ffcc00; color: #ffcc00; }
  .diff-btn[data-diff="normal"].active { background: rgba(100,80,0,0.4); box-shadow: 0 0 12px rgba(255,204,0,0.3); }
  .diff-btn[data-diff="hard"] { border-color: #ff6644; color: #ff6644; }
  .diff-btn[data-diff="hard"].active { background: rgba(100,30,20,0.4); box-shadow: 0 0 12px rgba(255,102,68,0.3); }
  .diff-btn[data-diff="nightmare"] { border-color: #cc44ff; color: #cc44ff; }
  .diff-btn[data-diff="nightmare"].active { background: rgba(80,20,100,0.4); box-shadow: 0 0 12px rgba(204,68,255,0.3); }
  .diff-btn[data-diff="custom"] { border-color: #44ddff; color: #44ddff; }
  .diff-btn[data-diff="custom"].active { background: rgba(20,60,80,0.4); box-shadow: 0 0 12px rgba(68,221,255,0.3); }
  .diff-label {
    font-family: 'Segoe UI', sans-serif;
    font-size: 10px;
    color: #888;
    margin-bottom: 2px;
  }
  .diff-desc {
    font-family: 'Segoe UI', sans-serif;
    font-size: 9px;
    color: #666;
    min-height: 14px;
    margin-top: 2px;
  }

  /* --- SAVE/LOAD TOAST --- */
  .save-toast {
    position: fixed;
    top: 20px;
    left: 50%;
    transform: translateX(-50%) translateY(-80px);
    background: rgba(0,0,0,0.9);
    border: 2px solid #44ff44;
    color: #44ff44;
    padding: 8px 20px;
    font-family: 'Press Start 2P', monospace;
    font-size: 10px;
    z-index: 9999;
    border-radius: 6px;
    pointer-events: none;
    transition: transform 0.3s ease;
  }
  .save-toast.show { transform: translateX(-50%) translateY(0); }
  .save-toast.error { border-color: #ff4444; color: #ff4444; }

  /* --- SHARE MODAL --- */
  .share-modal-bg {
    position: fixed; inset: 0;
    background: rgba(0,0,0,0.85);
    display: flex; align-items: center; justify-content: center;
    z-index: 9000;
  }
  .share-modal {
    background: #111;
    border: 2px solid #44ddff;
    border-radius: 10px;
    padding: 20px 28px;
    max-width: 420px;
    width: 90%;
    text-align: center;
    font-family: 'Press Start 2P', monospace;
  }
  .share-modal h3 { color: #44ddff; font-size: 12px; margin: 0 0 12px; }
  .share-modal textarea {
    width: 100%;
    height: 60px;
    background: #1a1a2e;
    color: #eee;
    border: 1px solid #444;
    border-radius: 4px;
    font-family: monospace;
    font-size: 10px;
    resize: none;
    padding: 6px;
  }
  .share-modal .share-btns {
    display: flex; gap: 8px; justify-content: center; margin-top: 10px;
  }
  .share-modal .share-btns button {
    padding: 6px 14px;
    font-family: 'Press Start 2P', monospace;
    font-size: 8px;
    border-radius: 4px;
    cursor: pointer;
    border: 1px solid;
  }

  /* --- TOUCH LAYOUT EDITOR --- */
  .touch-layout-overlay {
    position: fixed; inset: 0;
    background: rgba(0,0,0,0.7);
    z-index: 7000;
    display: flex; align-items: center; justify-content: center;
    font-family: 'Press Start 2P', monospace;
  }
  .touch-layout-panel {
    background: #111;
    border: 2px solid #ffaa00;
    border-radius: 10px;
    padding: 16px 20px;
    max-width: 360px;
    width: 90%;
    text-align: center;
    color: #eee;
  }
  .touch-layout-panel h3 { color: #ffaa00; font-size: 11px; margin: 0 0 10px; }
  .touch-layout-row { display: flex; justify-content: space-between; align-items: center; margin: 8px 0; font-size: 8px; }
  .touch-layout-row label { color: #aaa; }
  .touch-layout-row input[type="range"] { width: 120px; }
  .touch-layout-row .val { color: #ffaa00; min-width: 30px; text-align: right; }

  /* --- MUSIC CONTROLS --- */
  .music-controls {
    position: absolute;
    top: 4px;
    right: 4px;
    display: flex;
    gap: 4px;
    z-index: 15;
  }
  .music-btn {
    background: rgba(0,0,0,0.4);
    border: 1px solid #555;
    color: #ccc;
    padding: 2px 6px;
    font-size: 12px;
    cursor: pointer;
    border-radius: 3px;
    font-family: sans-serif;
  }
  .music-btn:hover { background: rgba(50,50,50,0.6); color: #fff; }
  .music-btn.muted { color: #ff4444; }

  /* --- ONLINE MULTIPLAYER (WebRTC) --- */
  .mp-modal-bg {
    position: fixed; inset: 0; background: rgba(0,0,0,0.85);
    display: flex; align-items: center; justify-content: center;
    z-index: 9100; font-family: 'Press Start 2P', monospace;
  }
  .mp-modal {
    background: #0a0a1a; border: 2px solid #44ddff; border-radius: 10px;
    padding: 20px 28px; max-width: 520px; width: 90%; color: #ddd;
    box-shadow: 0 0 40px rgba(68,221,255,0.3);
  }
  .mp-modal h2 { color: #44ddff; font-size: 14px; margin: 0 0 14px; text-align: center; }
  .mp-modal h3 { color: #ffaa00; font-size: 10px; margin: 12px 0 6px; }
  .mp-modal p { font-size: 8px; color: #999; line-height: 1.6; margin: 4px 0 10px; }
  .mp-modal textarea {
    width: 100%; height: 70px; background: #111; color: #44ff88; border: 1px solid #336;
    border-radius: 4px; font-family: monospace; font-size: 9px; padding: 6px; resize: none;
    box-sizing: border-box;
  }
  .mp-modal textarea:focus { border-color: #44ddff; outline: none; }
  .mp-btn {
    display: inline-block; padding: 7px 16px; font-family: 'Press Start 2P', monospace;
    font-size: 8px; border: 1px solid; border-radius: 4px; cursor: pointer;
    margin: 4px 4px 4px 0; transition: background 0.15s;
  }
  .mp-btn-host { background: rgba(0,60,30,0.8); color: #44ff88; border-color: #44ff88; }
  .mp-btn-host:hover { background: rgba(0,100,50,0.8); }
  .mp-btn-join { background: rgba(0,30,60,0.8); color: #44ddff; border-color: #44ddff; }
  .mp-btn-join:hover { background: rgba(0,50,100,0.8); }
  .mp-btn-danger { background: rgba(60,0,0,0.8); color: #ff4444; border-color: #ff4444; }
  .mp-btn-danger:hover { background: rgba(100,0,0,0.8); }
  .mp-btn-copy { background: rgba(40,40,10,0.8); color: #ffaa00; border-color: #ffaa00; }
  .mp-btn-copy:hover { background: rgba(80,60,10,0.8); }
  .mp-btn-close { background: rgba(30,30,30,0.8); color: #aaa; border-color: #666; }
  .mp-btn-close:hover { background: rgba(60,60,60,0.8); }
  .mp-status {
    font-size: 8px; padding: 6px 10px; border-radius: 4px; margin: 8px 0;
    text-align: center;
  }
  .mp-status-waiting { background: rgba(60,60,0,0.4); color: #ffaa00; border: 1px solid #665500; }
  .mp-status-connected { background: rgba(0,60,0,0.4); color: #44ff88; border: 1px solid #006600; }
  .mp-status-error { background: rgba(60,0,0,0.4); color: #ff4444; border: 1px solid #660000; }
  .mp-step { margin: 10px 0; padding: 8px; background: rgba(20,20,40,0.6); border-radius: 6px; border: 1px solid #223; }
  .mp-step-num {
    display: inline-block; width: 18px; height: 18px; line-height: 18px;
    text-align: center; background: #44ddff; color: #000; border-radius: 50%;
    font-size: 8px; font-weight: bold; margin-right: 6px;
  }
  .mp-step-label { font-size: 9px; color: #ccc; }
  .mp-hud {
    position: absolute; top: 4px; left: 50%; transform: translateX(-50%);
    font-family: 'Press Start 2P', monospace; font-size: 7px;
    padding: 2px 10px; border-radius: 10px; z-index: 90; pointer-events: none;
  }
  .mp-hud-host { background: rgba(0,60,0,0.6); color: #44ff88; border: 1px solid #44ff88; }
  .mp-hud-guest { background: rgba(0,30,60,0.6); color: #44ddff; border: 1px solid #44ddff; }
  .mp-hud-ping { font-size: 6px; color: #999; margin-left: 8px; }

  /* --- CUTSCENE / STORY MODE --- */
  #cutsceneOverlay {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    z-index: 9050; display: none; cursor: pointer;
  }
  #cutsceneOverlay.active { display: block; }
  .cs-skip-hint {
    position: absolute; bottom: 8px; right: 12px;
    font-family: 'Press Start 2P', monospace; font-size: 7px;
    color: rgba(255,255,255,0.4); pointer-events: none;
    animation: csBlink 2s infinite;
  }
  @keyframes csBlink { 0%,100%{opacity:0.4} 50%{opacity:0.15} }

  /* --- GAMEPAD INDICATOR --- */
  .gp-hud {
    position: absolute; top: 4px; right: 8px;
    font-family: 'Press Start 2P', monospace; font-size: 6px;
    color: #888; z-index: 15; pointer-events: none;
  }
  .gp-hud-icon { margin-right: 4px; }
  .gp-hud-connected { color: #44ff88; }
  .gp-hud-p1 { color: #ff6666; }
  .gp-hud-p2 { color: #6688ff; }
</style>
</head>
<body>

<div id="gameWrapper">
  <canvas id="game"></canvas>
  <!-- CUTSCENE OVERLAY (canvas-based) -->
  <div id="cutsceneOverlay"><span class="cs-skip-hint">CLICK / ENTER to advance &bull; ESC to skip</span></div>
  <!-- MUSIC/SFX CONTROLS -->
  <div class="music-controls">
    <button class="music-btn" id="musicToggle" onclick="toggleMusic()" title="Toggle Music">üéµ</button>
    <button class="music-btn" id="sfxToggle" onclick="toggleSFX()" title="Toggle SFX">üîä</button>
  </div>

  <div id="hud" class="hidden">
    <div class="hud-left">
      <span class="lives-display" id="livesDisplay">‚ô•‚ô•‚ô•</span>
      <span class="score-display" id="scoreDisplay">SCORE: 0</span>
    </div>
    <div id="coopDisplay" style="display:none; position:absolute; left:10px; top:40px; color:#ffcccc; font-size:12px;">
      P2: <span id="player2LivesDisplay">‚ô•‚ô•‚ô•</span>
    </div>
    <div class="hud-right">
      <span class="weapon-display" id="weaponDisplay">RIFLE</span>
      <span class="stage-display" id="stageDisplay">STAGE 1</span>
      <span class="zoom-display" id="diffDisplay" style="font-size:8px;">NORMAL</span>
      <span class="zoom-display" id="zoomDisplay">üîç100%</span>
      <span class="zoom-display" id="depthDisplay" style="color:#ccaa44"></span>
      <span class="zoom-display" id="grappleDisplay" style="color:#88ccff"></span>
      <span class="zoom-display ach-hud-btn" id="achHudBtn" title="Achievements (Tab)">üèÜ 0/0</span>
      <span class="zoom-display ach-hud-btn" id="lbHudBtn" title="Leaderboard (L)" style="color:#44ddff;">üìä</span>
    </div>
  </div>

  <!-- MOBILE TOUCH CONTROLS -->
  <div id="touchControls" class="size-medium">
    <!-- Size selector -->
    <div id="touchSizeSelector">
      <button class="size-btn" id="sizeSmall" title="Small buttons">S</button>
      <button class="size-btn active" id="sizeMedium" title="Medium buttons">M</button>
      <button class="size-btn" id="sizeLarge" title="Large buttons">L</button>
    </div>
    <!-- D-Pad (movement) -->
    <div class="touch-dpad">
      <div></div>
      <button class="dpad-btn" id="touchUp" data-action="up">‚ñ≤</button>
      <div></div>
      <button class="dpad-btn" id="touchLeft" data-action="left">‚óÑ</button>
      <div class="dpad-center"></div>
      <button class="dpad-btn" id="touchRight" data-action="right">‚ñ∫</button>
      <div></div>
      <button class="dpad-btn" id="touchDown" data-action="down">‚ñº</button>
      <div></div>
    </div>
    <!-- Action buttons -->
    <div class="touch-actions">
      <div class="action-row">
        <button class="touch-btn jump" id="touchJump" data-action="jump">JUMP</button>
        <button class="touch-btn" id="touchShoot" data-action="shoot">FIRE</button>
      </div>
      <div class="action-row">
        <button class="touch-btn grapple" id="touchGrapple" data-action="grapple">HOOK</button>
      </div>
    </div>
  </div>

  <div id="overlay">
    <h1>CONTRA FORCE</h1>
    <h2>‚ö° RUN & GUN ‚ö°</h2>
    <div class="subtitle">A CLASSIC SIDE-SCROLLING SHOOTER</div>
    <div class="blink">‚Äî PRESS ENTER TO START ‚Äî</div>
    <div class="diff-label">DIFFICULTY</div>
    <div class="diff-selector" id="diffSelector">
      <button class="diff-btn" data-diff="easy" onclick="setDifficulty('easy')">EASY</button>
      <button class="diff-btn active" data-diff="normal" onclick="setDifficulty('normal')">NORMAL</button>
      <button class="diff-btn" data-diff="hard" onclick="setDifficulty('hard')">HARD</button>
      <button class="diff-btn" data-diff="nightmare" onclick="setDifficulty('nightmare')">NIGHTMARE</button>
      <button class="diff-btn" data-diff="custom" onclick="setDifficulty('custom')">CUSTOM</button>
    </div>
    <div class="diff-desc" id="diffDesc">Standard arcade experience</div>
    <div class="diff-label" style="margin-top:8px;">GAME MODE</div>
    <div class="mode-selector" id="modeSelector">
      <button class="mode-btn active" data-mode="campaign" onclick="selectGameMode('campaign')"><span class="mode-icon">üéÆ</span><span class="mode-label">CAMPAIGN</span></button>
      <button class="mode-btn" data-mode="endless" onclick="selectGameMode('endless')"><span class="mode-icon">‚ôæÔ∏è</span><span class="mode-label">ENDLESS</span></button>
      <button class="mode-btn" data-mode="bossrush" onclick="selectGameMode('bossrush')"><span class="mode-icon">üëπ</span><span class="mode-label">BOSS RUSH</span></button>
      <button class="mode-btn" data-mode="timeattack" onclick="selectGameMode('timeattack')"><span class="mode-icon">‚è±Ô∏è</span><span class="mode-label">TIME ATTACK</span></button>
      <button class="mode-btn" data-mode="newgameplus" onclick="selectGameMode('newgameplus')"><span class="mode-icon">‚ûï</span><span class="mode-label">NEW GAME+</span></button>
      <button class="mode-btn" data-mode="challenge" onclick="selectGameMode('challenge')"><span class="mode-icon">üèÖ</span><span class="mode-label">CHALLENGES</span></button>
    </div>
    <div class="mode-desc" id="modeDesc" style="font-size:6px;color:#aaa;margin:4px 0;font-family:'Press Start 2P',monospace;">Classic 10-stage campaign</div>
    <button id="startBtn">START GAME</button>
    <div style="display:flex; gap:12px; margin-top:8px;">
      <button onclick="toggleAchievementsPanel()" style="padding:6px 14px; font-family:'Press Start 2P',monospace; font-size:8px; background:rgba(60,40,10,0.7); color:#ffaa00; border:1px solid #ffaa00; border-radius:4px; cursor:pointer;">üèÜ ACHIEVEMENTS</button>
      <button onclick="toggleLeaderboardPanel()" style="padding:5px 12px; font-family:'Press Start 2P',monospace; font-size:8px; background:rgba(10,40,60,0.7); color:#44ddff; border:1px solid #44ddff; border-radius:4px; cursor:pointer;">üìä LEADERBOARD</button>
      <button onclick="startTutorial()" id="tutorialBtn" style="padding:6px 14px; font-family:'Press Start 2P',monospace; font-size:8px; background:rgba(10,60,30,0.7); color:#44ff88; border:1px solid #44ff88; border-radius:4px; cursor:pointer;">üìñ TUTORIAL</button>
    </div>
    <div style="margin-top:6px; display:flex; align-items:center; gap:8px; justify-content:center;">
      <label style="font-family:'Press Start 2P',monospace; font-size:7px; color:#cc88ff; cursor:pointer; display:flex; align-items:center; gap:6px;">
        <input type="checkbox" id="storyModeInit" checked onchange="storyMode=this.checked;localStorage.setItem('contraForce_storyMode',storyMode?'1':'0');" style="cursor:pointer;">
        üìñ STORY MODE
      </label>
    </div>
    <div class="controls-info">
      ARROWS / WASD ‚Äî MOVE &amp; AIM<br>
      SPACE / Z ‚Äî SHOOT<br>
      X ‚Äî JUMP<br>
      UP/DOWN ON LADDER ‚Äî CLIMB<br>
      UP AGAINST WALL ‚Äî WALL CRAWL<br>
      C ‚Äî FIRE GRAPPLE HOOK<br>
      +/- ‚Äî ZOOM<br>
    </div>
  </div>
</div>

<!-- ACHIEVEMENT TOAST -->
<div id="achievementToast">
  <span class="toast-icon" id="toastIcon">üèÜ</span>
  <div class="toast-body">
    <span class="toast-label">ACHIEVEMENT UNLOCKED</span>
    <span class="toast-name" id="toastName"></span>
    <span class="toast-desc" id="toastDesc"></span>
  </div>
</div>

<!-- ACHIEVEMENTS PANEL -->
<div id="achievementsPanel">
  <span class="panel-close" onclick="toggleAchievementsPanel()">‚úï ESC</span>
  <div class="panel-title">üèÜ ACHIEVEMENTS</div>
  <div class="panel-subtitle" id="achCount">0 / 0 unlocked</div>
  <div class="achievement-grid" id="achGrid"></div>
</div>

<!-- LEADERBOARD PANEL -->
<div id="leaderboardPanel">
  <span class="panel-close" onclick="toggleLeaderboardPanel()">‚úï ESC</span>
  <div class="panel-title">üìä LEADERBOARD</div>
  <div class="panel-subtitle">Top scores on this device</div>
  <div id="lbContent"></div>
  <div style="display:flex; gap:8px; margin:10px 0; justify-content:center;">
    <button onclick="showShareModal()" style="padding:5px 12px; font-family:'Press Start 2P',monospace; font-size:7px; background:rgba(0,50,80,0.7); color:#44ddff; border:1px solid #44ddff; border-radius:4px; cursor:pointer;">üì§ SHARE SCORE</button>
    <button onclick="showImportScoreModal()" style="padding:5px 12px; font-family:'Press Start 2P',monospace; font-size:7px; background:rgba(0,50,30,0.7); color:#44ff88; border:1px solid #44ff88; border-radius:4px; cursor:pointer;">üì• IMPORT SCORE</button>
  </div>
  <button class="lb-clear-btn" onclick="clearLeaderboard()">CLEAR ALL SCORES</button>
</div>

<!-- ADMIN TOGGLE BUTTON -->
<div id="adminToggleBtn" onclick="toggleAdmin()" title="Admin Panel (`)">‚öô</div>

<!-- ADMIN PANEL -->
<div id="adminPanel">
  <div class="admin-header">
    ‚öô ADMIN PANEL
    <span onclick="toggleAdmin()">‚úï CLOSE (`)</span>
  </div>

  <!-- PHYSICS -->
  <div class="admin-section">
    <div class="admin-section-title" onclick="this.parentElement.classList.toggle('collapsed')">Physics</div>
    <div class="admin-section-body">
      <div class="admin-row"><label>Gravity</label><input type="range" min="0" max="2" step="0.05" id="s_gravity"><span class="val" id="v_gravity"></span></div>
      <div class="admin-row"><label>Jump Force</label><input type="range" min="-20" max="-3" step="0.5" id="s_jumpForce"><span class="val" id="v_jumpForce"></span></div>
      <div class="admin-row"><label>Player Speed</label><input type="range" min="1" max="10" step="0.5" id="s_playerSpeed"><span class="val" id="v_playerSpeed"></span></div>
      <div class="admin-row"><label>Max Fall Speed</label><input type="range" min="3" max="20" step="0.5" id="s_maxFall"><span class="val" id="v_maxFall"></span></div>
      <div class="admin-row"><label>Climb Speed</label><input type="range" min="1" max="8" step="0.5" id="s_climbSpeed"><span class="val" id="v_climbSpeed"></span></div>
    </div>
  </div>

  <!-- COMBAT -->
  <div class="admin-section">
    <div class="admin-section-title" onclick="this.parentElement.classList.toggle('collapsed')">Combat</div>
    <div class="admin-section-body">
      <div class="admin-row"><label>Bullet Speed</label><input type="range" min="3" max="20" step="0.5" id="s_bulletSpeed"><span class="val" id="v_bulletSpeed"></span></div>
      <div class="admin-row"><label>Enemy Bullet Speed</label><input type="range" min="1" max="12" step="0.5" id="s_enemyBulletSpeed"><span class="val" id="v_enemyBulletSpeed"></span></div>
      <div class="admin-row"><label>Lives</label><input type="range" min="1" max="99" step="1" id="s_lives"><span class="val" id="v_lives"></span></div>
      <div class="admin-row"><label>God Mode</label><input type="checkbox" id="s_godMode"></div>
      <div class="admin-row"><label>Show Hitboxes</label><input type="checkbox" id="s_showHitboxes"></div>
      <div class="admin-row"><label>Pause Game</label><input type="checkbox" id="s_paused"></div>
      <div class="admin-row"><label>Two-Player Co-op</label><input type="checkbox" id="s_coopMode"></div>
    </div>
  </div>

  <!-- ACHIEVEMENTS/LEADERBOARD -->
  <div class="admin-section collapsed">
    <div class="admin-section-title" onclick="this.parentElement.classList.toggle('collapsed')">Achievements & Leaderboard</div>
    <div class="admin-section-body">
      <div class="admin-row"><label>Achievements</label><button onclick="toggleAchievementsPanel()" style="padding:3px 8px; font-size:10px; cursor:pointer; background:#332200; color:#ffaa00; border:1px solid #ffaa00; border-radius:3px;">üèÜ VIEW</button></div>
      <div class="admin-row"><label>Leaderboard</label><button onclick="toggleLeaderboardPanel()" style="padding:3px 8px; font-size:10px; cursor:pointer; background:#002233; color:#44ddff; border:1px solid #44ddff; border-radius:3px;">üìä VIEW</button></div>
      <div class="admin-row"><label>Reset Achievements</label><button onclick="if(confirm('Reset all achievements?')){achievements={};saveAchievements();updateAchHud();}" style="padding:3px 8px; font-size:10px; cursor:pointer; background:#330000; color:#ff6666; border:1px solid #ff4444; border-radius:3px;">üóëÔ∏è RESET</button></div>
      <div class="admin-row"><label>Clear Leaderboard</label><button onclick="clearLeaderboard()" style="padding:3px 8px; font-size:10px; cursor:pointer; background:#330000; color:#ff6666; border:1px solid #ff4444; border-radius:3px;">üóëÔ∏è CLEAR</button></div>
    </div>
  </div>

  <!-- KEYBINDS -->
  <div class="admin-section collapsed">
    <div class="admin-section-title" onclick="this.parentElement.classList.toggle('collapsed')">Keybinds</div>
    <div class="admin-section-body">
      <div id="keybindsList"></div>
      <div class="admin-grid-info" style="margin-top:6px">Click a key to rebind it. Press any key to assign. ESC to cancel.</div>
      <div style="margin-top:6px">
        <button class="admin-btn" onclick="resetKeybinds()">Reset to Defaults</button>
      </div>
    </div>
  </div>

  <!-- WEAPONS -->
  <div class="admin-section">
    <div class="admin-section-title" onclick="this.parentElement.classList.toggle('collapsed')">Weapons</div>
    <div class="admin-section-body">
      <div class="editor-bar" id="weaponBar"></div>
    </div>
  </div>

  <!-- GAME -->
  <div class="admin-section">
    <div class="admin-section-title" onclick="this.parentElement.classList.toggle('collapsed')">Game</div>
    <div class="admin-section-body">
      <div class="admin-row"><label>Stage</label>
        <div class="editor-bar" id="stageBar"></div>
      </div>
      <div class="admin-row"><label>Score</label><input type="range" min="0" max="100000" step="1000" id="s_score"><span class="val" id="v_score"></span></div>
      <div style="display:flex;gap:4px;flex-wrap:wrap;margin-top:4px">
        <button class="admin-btn" onclick="adminKillAllEnemies()">Kill All Enemies</button>
        <button class="admin-btn" onclick="adminRespawnEnemies()">Respawn Enemies</button>
        <button class="admin-btn" onclick="adminClearBullets()">Clear Bullets</button>
        <button class="admin-btn danger" onclick="adminRegenLevel()">Regenerate Level</button>
      </div>
    </div>
  </div>

  <!-- SPAWN -->
  <div class="admin-section">
    <div class="admin-section-title" onclick="this.parentElement.classList.toggle('collapsed')">Spawn</div>
    <div class="admin-section-body">
      <div class="editor-bar" id="spawnBar"></div>
      <div class="admin-grid-info">Click a button then click on the game to spawn</div>
    </div>
  </div>

  <!-- LEVEL EDITOR -->
  <div class="admin-section">
    <div class="admin-section-title" onclick="this.parentElement.classList.toggle('collapsed')">Level Editor</div>
    <div class="admin-section-body">
      <div class="admin-row"><label>Editor Mode</label><input type="checkbox" id="s_editorMode"></div>
      <div class="editor-bar" id="brushBar">
        <button class="admin-btn selected" onclick="setBrush(0,this)">üî≤ Erase</button>
        <button class="admin-btn" onclick="setBrush(1,this)">üü´ Solid</button>
        <button class="admin-btn" onclick="setBrush(2,this)">ü™ú Ladder</button>
        <button class="admin-btn" onclick="setBrush(3,this)">üåä Water</button>
        <button class="admin-btn" onclick="setBrush(4,this)">üíé Treasure</button>
      </div>
      <div class="admin-row"><label>Brush Size</label><input type="range" min="1" max="5" step="1" id="s_brushSize"><span class="val" id="v_brushSize">1</span></div>
      <div style="display:flex;gap:4px;flex-wrap:wrap;margin-top:6px">
        <button class="admin-btn" onclick="adminFlattenGround()">Flatten Ground</button>
        <button class="admin-btn" onclick="adminClearMap()">Clear All Tiles</button>
        <button class="admin-btn" onclick="adminExportLevel()">Export JSON</button>
        <button class="admin-btn" onclick="adminImportLevel()">Import JSON</button>
      </div>
      <div class="admin-grid-info">
        Editor mode: click & drag on game canvas to paint tiles.<br>
        Right-click to erase. Shift+click to teleport player.
      </div>
      <canvas id="minimapCanvas" width="280" height="60" style="width:100%;margin-top:8px;border:1px solid #444;background:#111;image-rendering:pixelated;cursor:pointer"></canvas>
      <div class="admin-grid-info" style="margin-top:2px">Click minimap to jump camera there</div>
    </div>
  </div>

  <!-- SAVE / LOAD -->
  <div class="admin-section collapsed">
    <div class="admin-section-title" onclick="this.parentElement.classList.toggle('collapsed')">Save / Load</div>
    <div class="admin-section-body">
      <div style="display:flex;gap:4px;flex-wrap:wrap">
        <button class="admin-btn" onclick="saveGameState()">üíæ Save Game</button>
        <button class="admin-btn" onclick="loadGameState()">üìÇ Load Game</button>
        <button class="admin-btn danger" onclick="if(confirm('Delete saved game?')){localStorage.removeItem('contraForce_saveState');showSaveToast('Save deleted','error')}">üóëÔ∏è Delete Save</button>
      </div>
      <div style="display:flex;gap:4px;flex-wrap:wrap;margin-top:6px">
        <button class="admin-btn" onclick="exportSaveFile()">‚¨áÔ∏è Export to File</button>
        <button class="admin-btn" onclick="importSaveFile()">‚¨ÜÔ∏è Import from File</button>
      </div>
      <div class="admin-grid-info" style="margin-top:4px">Save your current game progress. Export/Import for backup.</div>
    </div>
  </div>

  <!-- LEVEL FILE -->
  <div class="admin-section collapsed">
    <div class="admin-section-title" onclick="this.parentElement.classList.toggle('collapsed')">Level File I/O</div>
    <div class="admin-section-body">
      <div style="display:flex;gap:4px;flex-wrap:wrap">
        <button class="admin-btn" onclick="downloadLevelFile()">‚¨áÔ∏è Download Level</button>
        <button class="admin-btn" onclick="uploadLevelFile()">‚¨ÜÔ∏è Upload Level</button>
      </div>
      <div style="display:flex;gap:4px;flex-wrap:wrap;margin-top:6px">
        <button class="admin-btn" onclick="adminExportLevel()">üìã Copy JSON</button>
        <button class="admin-btn" onclick="adminImportLevel()">üìã Paste JSON</button>
      </div>
      <div class="admin-grid-info" style="margin-top:4px">Download/upload level files. Includes terrain, enemies, powerups, treasures.</div>
    </div>
  </div>

  <!-- AUDIO -->
  <div class="admin-section collapsed">
    <div class="admin-section-title" onclick="this.parentElement.classList.toggle('collapsed')">Audio</div>
    <div class="admin-section-body">
      <div class="admin-row"><label>Music Volume</label><input type="range" min="0" max="100" step="5" id="s_musicVol" oninput="setMusicVolume(this.value/100)"><span class="val" id="v_musicVol">60</span></div>
      <div class="admin-row"><label>SFX Volume</label><input type="range" min="0" max="100" step="5" id="s_sfxVol" oninput="setSfxVolume(this.value/100)"><span class="val" id="v_sfxVol">80</span></div>
      <div class="admin-row"><label>Music Enabled</label><input type="checkbox" id="s_musicEnabled" checked onchange="toggleMusic()"></div>
      <div class="admin-row"><label>SFX Enabled</label><input type="checkbox" id="s_sfxEnabled" checked onchange="toggleSFX()"></div>
    </div>
  </div>

  <!-- TOUCH LAYOUT -->
  <div class="admin-section collapsed">
    <div class="admin-section-title" onclick="this.parentElement.classList.toggle('collapsed')">Touch Controls</div>
    <div class="admin-section-body">
      <div class="admin-row"><label>Opacity</label><input type="range" min="20" max="100" step="5" id="s_touchOpacity" oninput="setTouchOpacity(this.value/100)"><span class="val" id="v_touchOpacity">70</span></div>
      <div class="admin-row"><label>Button Size</label>
        <div style="display:flex;gap:4px">
          <button class="admin-btn" onclick="setTouchButtonSize('small')">S</button>
          <button class="admin-btn" onclick="setTouchButtonSize('medium')">M</button>
          <button class="admin-btn" onclick="setTouchButtonSize('large')">L</button>
        </div>
      </div>
      <div class="admin-row"><label>Vibration</label><input type="checkbox" id="s_touchVibrate" checked onchange="touchVibrate=this.checked"></div>
      <div class="admin-row"><label>Swap Sides</label><input type="checkbox" id="s_touchSwap" onchange="swapTouchSides(this.checked)"></div>
      <div class="admin-grid-info" style="margin-top:4px">Customise touch control layout, opacity and feedback.</div>
    </div>
  </div>

  <!-- ONLINE MULTIPLAYER -->
  <div class="admin-section collapsed">
    <div class="admin-section-title" onclick="this.parentElement.classList.toggle('collapsed')">Online Multiplayer</div>
    <div class="admin-section-body">
      <div style="display:flex;gap:4px;flex-wrap:wrap">
        <button class="admin-btn" onclick="showMpModal()" style="background:#001133;color:#88aaff;border:1px solid #88aaff;">üåê Open Multiplayer</button>
      </div>
      <div id="mpAdminStatus" style="font-size:9px;color:#888;margin-top:6px;">Status: Not connected</div>
      <div class="admin-grid-info" style="margin-top:4px">Host or join an online co-op game via WebRTC. No server required ‚Äî peer-to-peer with copy/paste codes.</div>
    </div>
  </div>

  <!-- GAMEPAD / CONTROLLER -->
  <div class="admin-section collapsed">
    <div class="admin-section-title" onclick="this.parentElement.classList.toggle('collapsed')">Gamepad / Controller</div>
    <div class="admin-section-body">
      <div id="gpAdminStatus" style="font-size:9px;color:#888;margin-bottom:6px;">No gamepads detected</div>
      <div class="admin-row"><label>Dead Zone</label><input type="range" min="5" max="50" step="5" id="s_gpDeadzone" value="20" oninput="gpDeadzone=this.value/100;document.getElementById('v_gpDeadzone').textContent=this.value+'%'"><span class="val" id="v_gpDeadzone">20%</span></div>
      <div class="admin-row"><label>Vibration</label><input type="checkbox" id="s_gpVibration" checked onchange="gpVibration=this.checked"></div>
      <div class="admin-grid-info" style="margin-top:4px">Connect a gamepad and press any button. Pad 1 = Player 1, Pad 2 = Player 2 (co-op). Standard mapping: D-pad/Stick=Move, A=Jump, X/B=Shoot, Y/RB=Grapple, Start=Start Game.</div>
    </div>
  </div>

  <!-- ANIMATED SPRITES -->
  <div class="admin-section collapsed">
    <div class="admin-section-title" onclick="this.parentElement.classList.toggle('collapsed')">Animated Sprites</div>
    <div class="admin-section-body">
      <div class="admin-row"><label>Use Sprites</label><input type="checkbox" id="s_useSprites" checked onchange="useSprites=this.checked"></div>
      <div class="admin-grid-info" style="margin-top:4px">Toggle between sprite-sheet rendering (animated multi-frame sprites) and legacy procedural drawing. Sprite sheets are generated at startup from offscreen canvases.</div>
      <div id="spriteSheetPreview" style="margin-top:6px"></div>
      <button class="admin-btn" onclick="showSpriteSheetPreview()" style="margin-top:4px;background:#1a1a00;color:#aaff44;border:1px solid #aaff44;">Show Sprite Sheets</button>
    </div>
  </div>

  <!-- STORY MODE -->
  <div class="admin-section collapsed">
    <div class="admin-section-title" onclick="this.parentElement.classList.toggle('collapsed')">Story Mode</div>
    <div class="admin-section-body">
      <div class="admin-row"><label>Story Mode</label><input type="checkbox" id="s_storyMode" checked onchange="storyMode=this.checked;localStorage.setItem('contraForce_storyMode',storyMode?'1':'0')"></div>
      <div class="admin-grid-info" style="margin-top:4px">When enabled, narrative cutscenes play between stages. Disable for pure arcade action.</div>
      <div style="display:flex;gap:4px;flex-wrap:wrap;margin-top:6px">
        <button class="admin-btn" onclick="playCutscene('prologue',()=>{})" style="background:#1a0033;color:#cc88ff;border:1px solid #cc88ff;">‚ñ∂ Preview Prologue</button>
        <button class="admin-btn" onclick="playCutscene('epilogue',()=>{})" style="background:#1a0033;color:#cc88ff;border:1px solid #cc88ff;">‚ñ∂ Preview Epilogue</button>
      </div>
    </div>
  </div>

  <!-- CHARACTERS -->
  <div class="admin-section collapsed">
    <div class="admin-section-title" onclick="this.parentElement.classList.toggle('collapsed')">Characters</div>
    <div class="admin-section-body">
      <div id="charAdminList" style="font-size:9px;color:#ccc;"></div>
      <div style="display:flex;gap:4px;flex-wrap:wrap;margin-top:6px">
        <button class="admin-btn" onclick="unlockAllCharacters()" style="background:#1a001a;color:#ff88ff;border:1px solid #ff88ff;">üîì Unlock All</button>
        <button class="admin-btn" onclick="resetCharacterUnlocks()" style="background:#330000;color:#ff4444;border:1px solid #ff4444;">üîí Reset Unlocks</button>
      </div>
      <div class="admin-grid-info" style="margin-top:4px">6 playable characters with unique stats, abilities, and starting weapons. Select before each game.</div>
    </div>
  </div>

  <!-- VEHICLES & SECRETS -->
  <div class="admin-section collapsed">
    <div class="admin-section-title" onclick="this.parentElement.classList.toggle('collapsed')">Vehicles & Secrets</div>
    <div class="admin-section-body">
      <div class="admin-grid-info">Vehicles spawn on stages 3, 5, 7, 9. Secret exits on stages 3 ‚Üí 11, 7 ‚Üí 12.</div>
      <div style="display:flex;gap:4px;flex-wrap:wrap;margin-top:6px">
        <button class="admin-btn" onclick="adminSpawnVehicle('HOVERBIKE')" style="background:#001a22;color:#44ccff;border:1px solid #44ccff;">üèç Spawn Hoverbike</button>
        <button class="admin-btn" onclick="adminSpawnVehicle('TANK')" style="background:#1a1a00;color:#88aa55;border:1px solid #88aa55;">üõ° Spawn Tank</button>
      </div>
      <div id="secretsAdminInfo" style="font-size:9px;color:#aaa;margin-top:6px"></div>
    </div>
  </div>

  <!-- VISUAL EFFECTS -->
  <div class="admin-section collapsed">
    <div class="admin-section-title" onclick="this.parentElement.classList.toggle('collapsed')">Visual Effects</div>
    <div class="admin-section-body">
      <div class="admin-row"><label>CRT Shader</label><input type="checkbox" id="s_crtEnabled" onchange="crtEnabled=this.checked"></div>
      <div class="admin-row"><label>Scanlines</label><input type="checkbox" id="s_crtScanlines" checked onchange="crtScanlines=this.checked"></div>
      <div class="admin-row"><label>Chromatic Aberration</label><input type="checkbox" id="s_crtAberration" checked onchange="crtChromaticAberration=this.checked"></div>
      <div class="admin-row"><label>Screen Curvature</label><input type="checkbox" id="s_crtCurvature" checked onchange="crtCurvature=this.checked"></div>
      <div class="admin-row"><label>Scanline Intensity</label><input type="range" min="0" max="40" step="2" value="12" id="s_crtScanAlpha" oninput="crtScanlineAlpha=this.value/100;document.getElementById('v_crtScanAlpha').textContent=this.value+'%'"><span class="val" id="v_crtScanAlpha">12%</span></div>
      <div class="admin-row"><label>Aberration Px</label><input type="range" min="0" max="5" step="0.5" value="1.5" id="s_crtAberAmt" oninput="crtAberrationAmount=parseFloat(this.value);document.getElementById('v_crtAberAmt').textContent=this.value"><span class="val" id="v_crtAberAmt">1.5</span></div>
      <hr style="border-color:#333;margin:8px 0">
      <div class="admin-row"><label>Weather Effects</label><input type="checkbox" id="s_weatherEnabled" checked onchange="weatherEnabled=this.checked"></div>
      <div class="admin-row"><label>Dynamic Lighting</label><input type="checkbox" id="s_lightingEnabled" checked onchange="dynamicLightingEnabled=this.checked"></div>
      <div class="admin-row"><label>Animated Water/Lava</label><input type="checkbox" id="s_animTiles" checked onchange="animatedTilesEnabled=this.checked"></div>
      <div class="admin-grid-info" style="margin-top:4px">CRT shader adds retro scanlines, chromatic aberration and screen curvature. Weather varies per stage theme. Dynamic lighting adds muzzle flash and explosion glow.</div>
    </div>
  </div>

  <!-- PARTICLE EDITOR -->
  <div class="admin-section">
    <div class="admin-section-title" onclick="this.parentElement.classList.toggle('collapsed')">Particle Editor üí•</div>
    <div class="admin-body">
      <div class="admin-grid-info" style="margin-bottom:6px">Tweak explosion, death, glow, ring, and debris particle effects in real time. Click ‚ñ∂ TEST to preview each effect at the player's position.</div>
      <div id="particleEditorPresets"></div>
      <hr style="border-color:#333;margin:8px 0">
      <div style="display:flex;gap:8px;justify-content:center;">
        <button class="admin-btn" onclick="particlePresets={explosion:{count:30,speed:6,life:35,color:'#ff4400',size:3,gravity:0.2},death:{count:40,speed:7,life:40,color:'#ff4400',sizeMin:1,sizeMax:3,gravity:0},glow:{count:10,speed:4,life:40,color:'#ff8800',sizeMin:2,sizeMax:4},ring:{count:12,speed:0.15,life:20,color:'#ff6600',size:3},debris:{count:6,speed:5,life:60,color:'#666666',sizeMin:3,sizeMax:5,gravity:0.2}};updateParticleEditorUI();" style="font-size:8px;padding:4px 10px;background:#330000;color:#ff6666;border:1px solid #ff4444;border-radius:4px;cursor:pointer;">üîÑ RESET ALL</button>
        <button class="admin-btn" onclick="for(const n of Object.keys(particlePresets)){particleEditorTestEffect(n);}" style="font-size:8px;padding:4px 10px;background:#002200;color:#66ff66;border:1px solid #44ff44;border-radius:4px;cursor:pointer;">üí• TEST ALL</button>
      </div>
    </div>
  </div>

  <!-- ACCESSIBILITY -->
  <div class="admin-section collapsed">
    <div class="admin-section-title" onclick="this.parentElement.classList.toggle('collapsed')">Accessibility ‚ôø</div>
    <div class="admin-section-body">
      <div class="admin-row"><label>Color Blind Mode</label>
        <select id="s_colorBlind" onchange="accessColorBlindMode=this.value" style="background:#1a1a2e;color:#ccc;border:1px solid #555;padding:2px 4px;font-size:9px;">
          <option value="none">None</option>
          <option value="protanopia">Protanopia (Red)</option>
          <option value="deuteranopia">Deuteranopia (Green)</option>
          <option value="tritanopia">Tritanopia (Blue)</option>
        </select>
      </div>
      <div class="admin-row"><label>Aim Assist</label><input type="checkbox" id="s_aimAssist" onchange="accessAimAssist=this.checked"></div>
      <div class="admin-row"><label>Aim Strength</label><input type="range" min="10" max="80" step="5" value="30" id="s_aimStr" oninput="accessAimAssistStrength=this.value/100;document.getElementById('v_aimStr').textContent=this.value+'%'"><span class="val" id="v_aimStr">30%</span></div>
      <div class="admin-row"><label>Infinite Lives</label><input type="checkbox" id="s_infLives" onchange="accessInfiniteLives=this.checked"></div>
      <div class="admin-row"><label>Enemy Speed</label><input type="range" min="20" max="150" step="10" value="100" id="s_enemySpd" oninput="accessEnemySpeedMult=this.value/100;document.getElementById('v_enemySpd').textContent=this.value+'%'"><span class="val" id="v_enemySpd">100%</span></div>
      <div class="admin-row"><label>Enemy Bullet Speed</label><input type="range" min="20" max="150" step="10" value="100" id="s_bulletTime" oninput="accessBulletTimeMult=this.value/100;document.getElementById('v_bulletTime').textContent=this.value+'%'"><span class="val" id="v_bulletTime">100%</span></div>
      <div class="admin-row"><label>High Contrast HUD</label><input type="checkbox" id="s_highContrast" onchange="accessHighContrastHUD=this.checked"></div>
      <div class="admin-row"><label>Large HUD Text</label><input type="checkbox" id="s_largeHUD" onchange="accessLargeHUD=this.checked"></div>
      <div class="admin-row"><label>Reduce Screen Shake</label><input type="checkbox" id="s_reduceShake" onchange="accessScreenShakeReduced=this.checked"></div>
      <div class="admin-grid-info" style="margin-top:4px">Color-blind filters, aim assist, difficulty modifiers, and HUD customization for improved accessibility.</div>
    </div>
  </div>

  <!-- SPEEDRUN -->
  <div class="admin-section collapsed">
    <div class="admin-section-title" onclick="this.parentElement.classList.toggle('collapsed')">Speedrun Timer ‚è±</div>
    <div class="admin-section-body">
      <div class="admin-row"><label>Enable Timer</label><input type="checkbox" id="s_speedrun" onchange="speedrunEnabled=this.checked;if(this.checked)initSpeedrun()"></div>
      <div class="admin-row"><label>Clear PB Splits</label><button onclick="if(confirm('Clear all PB splits?')){speedrunPB=[];saveSpeedrunPB();}" style="padding:3px 8px;font-size:10px;cursor:pointer;background:#330000;color:#ff6666;border:1px solid #ff4444;border-radius:3px;">üóëÔ∏è CLEAR</button></div>
      <div id="speedrunPBList" style="font-size:8px;color:#88aa88;margin-top:6px;max-height:80px;overflow-y:auto;"></div>
      <div class="admin-grid-info" style="margin-top:4px">Shows live timer with per-stage splits. Compares against your Personal Best. Great for Time Attack mode!</div>
    </div>
  </div>

  <!-- WEAPON FUSION -->
  <div class="admin-section collapsed">
    <div class="admin-section-title" onclick="this.parentElement.classList.toggle('collapsed')">Weapon Fusion ‚öî</div>
    <div class="admin-section-body">
      <div class="admin-grid-info">Pick up two different weapons within 5 seconds to fuse them into a powerful combo weapon!</div>
      <div id="fusionListAdmin" style="font-size:7px;color:#aaa;margin-top:6px;max-height:120px;overflow-y:auto;"></div>
      <button class="admin-btn" onclick="showFusionList()" style="margin-top:4px;background:#1a1a00;color:#ffaa44;border:1px solid #ffaa44;">üìã Show Fusion Recipes</button>
    </div>
  </div>

</div>

<!-- SAVE TOAST -->
<div class="save-toast" id="saveToast"></div>

<!-- MULTIPLAYER HUD BADGE -->
<div id="mpHud" class="mp-hud" style="display:none;"></div>

<!-- GAMEPAD HUD -->
<div id="gpHud" class="gp-hud" style="display:none;"></div>

<!-- MULTIPLAYER MODAL (injected dynamically) -->
<div id="mpModalContainer"></div>

<script>
// ============================================================
//  CONTRA FORCE ‚Äî HTML5 GAME
// ============================================================

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const overlay = document.getElementById('overlay');
const hud = document.getElementById('hud');

// --- SETTINGS (adjustable via admin panel) ---
const GAME_W = 800;
const GAME_H = 450;
const TILE = 32;
let gravity = 0.55;
let maxFall = 10;
let playerSpeed = 3;
let jumpForce = -11;
let bulletSpeed = 8;
let enemyBulletSpeed = 4;
const SCROLL_THRESHOLD = 300;
let climbSpeed = 2.5;
let godMode = false;
let showHitboxes = false;

// ============================================================
//  DIFFICULTY SYSTEM
// ============================================================
const DIFFICULTY_PRESETS = {
  easy: {
    label: 'EASY', color: '#44cc44',
    desc: 'Relaxed ‚Äî more lives, fewer enemies, slower bullets',
    lives: 5,
    enemySpawnMult: 0.6,
    enemyHpMult: 0.75,
    enemyBulletSpeedMult: 0.7,
    enemyFireRateMult: 1.4,   // higher = slower fire (longer cooldown)
    bossHpMult: 0.6,
    powerupSpawnMult: 1.5,
    playerSpeed: 3.2,
    scoreMult: 0.5,
    respawnInvincibility: 180,
  },
  normal: {
    label: 'NORMAL', color: '#ffcc00',
    desc: 'Standard arcade experience',
    lives: 3,
    enemySpawnMult: 1.0,
    enemyHpMult: 1.0,
    enemyBulletSpeedMult: 1.0,
    enemyFireRateMult: 1.0,
    bossHpMult: 1.0,
    powerupSpawnMult: 1.0,
    playerSpeed: 3,
    scoreMult: 1.0,
    respawnInvincibility: 120,
  },
  hard: {
    label: 'HARD', color: '#ff6644',
    desc: 'Punishing ‚Äî tougher enemies, faster bullets, fewer power-ups',
    lives: 2,
    enemySpawnMult: 1.3,
    enemyHpMult: 1.5,
    enemyBulletSpeedMult: 1.3,
    enemyFireRateMult: 0.75,
    bossHpMult: 1.5,
    powerupSpawnMult: 0.6,
    playerSpeed: 3,
    scoreMult: 1.5,
    respawnInvincibility: 90,
  },
  nightmare: {
    label: 'NIGHTMARE', color: '#cc44ff',
    desc: 'One life. Relentless enemies. No mercy.',
    lives: 1,
    enemySpawnMult: 1.6,
    enemyHpMult: 2.0,
    enemyBulletSpeedMult: 1.5,
    enemyFireRateMult: 0.6,
    bossHpMult: 2.0,
    powerupSpawnMult: 0.4,
    playerSpeed: 3,
    scoreMult: 2.5,
    respawnInvincibility: 60,
  },
  custom: {
    label: 'CUSTOM', color: '#44ddff',
    desc: 'Use Admin Panel settings',
    lives: 3,
    enemySpawnMult: 1.0,
    enemyHpMult: 1.0,
    enemyBulletSpeedMult: 1.0,
    enemyFireRateMult: 1.0,
    bossHpMult: 1.0,
    powerupSpawnMult: 1.0,
    playerSpeed: 3,
    scoreMult: 1.0,
    respawnInvincibility: 120,
  },
};

let currentDifficulty = 'normal';
let diffSettings = { ...DIFFICULTY_PRESETS.normal };

function setDifficulty(diff) {
  currentDifficulty = diff;
  diffSettings = { ...DIFFICULTY_PRESETS[diff] };
  // Update selector UI
  document.querySelectorAll('.diff-btn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.diff === diff);
  });
  const descEl = document.getElementById('diffDesc');
  if (descEl) descEl.textContent = diffSettings.desc;
  const descEl2 = document.getElementById('diffDescOverlay');
  if (descEl2) descEl2.textContent = diffSettings.desc;
  // Save preference
  try { localStorage.setItem('contraForce_difficulty', diff); } catch(e) {}
}

function loadDifficulty() {
  try {
    const saved = localStorage.getItem('contraForce_difficulty');
    if (saved && DIFFICULTY_PRESETS[saved]) {
      setDifficulty(saved);
    }
  } catch(e) {}
}

function applyDifficulty() {
  if (currentDifficulty === 'custom') return; // custom uses admin panel values
  playerSpeed = diffSettings.playerSpeed;
  enemyBulletSpeed = 4 * diffSettings.enemyBulletSpeedMult;
}

// Score helper ‚Äî applies difficulty multiplier
function addScore(pts) {
  score += Math.round(pts * diffSettings.scoreMult);
}

function getDifficultyLabel() {
  const p = DIFFICULTY_PRESETS[currentDifficulty];
  return p ? p.label : 'NORMAL';
}

function getDifficultyColor() {
  const p = DIFFICULTY_PRESETS[currentDifficulty];
  return p ? p.color : '#ffcc00';
}

loadDifficulty();
let paused = false;
let editorMode = false;
let editorBrush = 1; // 0=erase, 1=solid, 2=ladder
let coopMode = false; // Two-player co-op
let twoPlayerReady = false; // Toggle for admin panel

// Zoom
let zoom = 1.0;
const ZOOM_MIN = 0.4;
const ZOOM_MAX = 2.5;
const ZOOM_STEP = 0.1;
function viewW() { return GAME_W / zoom; }
function viewH() { return GAME_H / zoom; }

canvas.width = GAME_W;
canvas.height = GAME_H;

// --- AUDIO ENGINE (Web Audio API) ---
const AudioCtx = window.AudioContext || window.webkitAudioContext;
let audioCtx;

function initAudio() {
  if (!audioCtx) audioCtx = new AudioCtx();
}

function playSound(type) {
  if (!audioCtx || !sfxEnabled) return;
  const osc = audioCtx.createOscillator();
  const sfxGain = audioCtx.createGain();
  const masterGain = audioCtx.createGain();
  masterGain.gain.setValueAtTime(sfxVolume, audioCtx.currentTime);
  osc.connect(sfxGain);
  sfxGain.connect(masterGain);
  masterGain.connect(audioCtx.destination);
  // Alias for all existing case statements
  const gain = sfxGain;
  const t = audioCtx.currentTime;

  switch(type) {
    case 'shoot':
      osc.type = 'square';
      osc.frequency.setValueAtTime(600, t);
      osc.frequency.exponentialRampToValueAtTime(100, t + 0.08);
      gain.gain.setValueAtTime(0.15, t);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.08);
      osc.start(t); osc.stop(t + 0.08);
      break;
    case 'spread':
      osc.type = 'sawtooth';
      osc.frequency.setValueAtTime(800, t);
      osc.frequency.exponentialRampToValueAtTime(200, t + 0.1);
      gain.gain.setValueAtTime(0.12, t);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
      osc.start(t); osc.stop(t + 0.1);
      break;
    case 'laser':
      osc.type = 'sine';
      osc.frequency.setValueAtTime(1200, t);
      osc.frequency.exponentialRampToValueAtTime(300, t + 0.15);
      gain.gain.setValueAtTime(0.15, t);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
      osc.start(t); osc.stop(t + 0.15);
      break;
    case 'explosion':
      osc.type = 'sawtooth';
      osc.frequency.setValueAtTime(100, t);
      osc.frequency.exponentialRampToValueAtTime(20, t + 0.3);
      gain.gain.setValueAtTime(0.25, t);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
      osc.start(t); osc.stop(t + 0.3);
      break;
    case 'powerup':
      osc.type = 'sine';
      osc.frequency.setValueAtTime(400, t);
      osc.frequency.exponentialRampToValueAtTime(1200, t + 0.2);
      gain.gain.setValueAtTime(0.15, t);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.25);
      osc.start(t); osc.stop(t + 0.25);
      break;
    case 'hit':
      osc.type = 'square';
      osc.frequency.setValueAtTime(200, t);
      osc.frequency.exponentialRampToValueAtTime(50, t + 0.1);
      gain.gain.setValueAtTime(0.2, t);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
      osc.start(t); osc.stop(t + 0.1);
      break;
    case 'dig':
      osc.type = 'triangle';
      osc.frequency.setValueAtTime(80, t);
      osc.frequency.exponentialRampToValueAtTime(40, t + 0.08);
      gain.gain.setValueAtTime(0.12, t);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.08);
      osc.start(t); osc.stop(t + 0.08);
      break;
    case 'wall_climb':
      osc.type = 'triangle';
      osc.frequency.setValueAtTime(120, t);
      osc.frequency.exponentialRampToValueAtTime(90, t + 0.06);
      gain.gain.setValueAtTime(0.06, t);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.06);
      osc.start(t); osc.stop(t + 0.06);
      break;
    case 'treasure':
      osc.type = 'sine';
      osc.frequency.setValueAtTime(600, t);
      osc.frequency.exponentialRampToValueAtTime(1400, t + 0.15);
      gain.gain.setValueAtTime(0.12, t);
      gain.gain.exponentialRampToValueAtTime(0.05, t + 0.15);
      osc.frequency.exponentialRampToValueAtTime(1800, t + 0.3);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.35);
      osc.start(t); osc.stop(t + 0.35);
      break;
    case 'grapple_fire':
      osc.type = 'sawtooth';
      osc.frequency.setValueAtTime(300, t);
      osc.frequency.exponentialRampToValueAtTime(800, t + 0.08);
      gain.gain.setValueAtTime(0.1, t);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
      osc.start(t); osc.stop(t + 0.1);
      break;
    case 'grapple_latch':
      osc.type = 'square';
      osc.frequency.setValueAtTime(500, t);
      osc.frequency.exponentialRampToValueAtTime(300, t + 0.05);
      gain.gain.setValueAtTime(0.15, t);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.08);
      osc.start(t); osc.stop(t + 0.08);
      break;
    case 'grapple_pull':
      osc.type = 'triangle';
      osc.frequency.setValueAtTime(150, t);
      osc.frequency.exponentialRampToValueAtTime(400, t + 0.15);
      gain.gain.setValueAtTime(0.06, t);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.2);
      osc.start(t); osc.stop(t + 0.2);
      break;
    case 'die':
      osc.type = 'sawtooth';
      osc.frequency.setValueAtTime(400, t);
      osc.frequency.exponentialRampToValueAtTime(30, t + 0.5);
      gain.gain.setValueAtTime(0.2, t);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.5);
      osc.start(t); osc.stop(t + 0.5);
      break;
    case 'jump':
      osc.type = 'sine';
      osc.frequency.setValueAtTime(250, t);
      osc.frequency.exponentialRampToValueAtTime(600, t + 0.12);
      gain.gain.setValueAtTime(0.1, t);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.12);
      osc.start(t); osc.stop(t + 0.12);
      break;
    case 'boss':
      osc.type = 'square';
      osc.frequency.setValueAtTime(80, t);
      osc.frequency.exponentialRampToValueAtTime(40, t + 0.6);
      gain.gain.setValueAtTime(0.3, t);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.6);
      osc.start(t); osc.stop(t + 0.6);
      break;
    case 'stage_clear':
      osc.type = 'sine';
      // ascending victory jingle
      osc.frequency.setValueAtTime(523, t);
      osc.frequency.setValueAtTime(659, t + 0.12);
      osc.frequency.setValueAtTime(784, t + 0.24);
      osc.frequency.setValueAtTime(1047, t + 0.36);
      gain.gain.setValueAtTime(0.18, t);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.5);
      osc.start(t); osc.stop(t + 0.5);
      break;
    case 'menu_select':
      osc.type = 'square';
      osc.frequency.setValueAtTime(800, t);
      osc.frequency.setValueAtTime(1000, t + 0.04);
      gain.gain.setValueAtTime(0.08, t);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.08);
      osc.start(t); osc.stop(t + 0.08);
      break;
    case 'enemy_shoot':
      osc.type = 'sawtooth';
      osc.frequency.setValueAtTime(250, t);
      osc.frequency.exponentialRampToValueAtTime(80, t + 0.06);
      gain.gain.setValueAtTime(0.06, t);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.06);
      osc.start(t); osc.stop(t + 0.06);
      break;
    case 'coin':
      osc.type = 'sine';
      osc.frequency.setValueAtTime(1200, t);
      osc.frequency.setValueAtTime(1600, t + 0.06);
      gain.gain.setValueAtTime(0.1, t);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.12);
      osc.start(t); osc.stop(t + 0.12);
      break;
    case 'game_over':
      osc.type = 'sawtooth';
      osc.frequency.setValueAtTime(300, t);
      osc.frequency.exponentialRampToValueAtTime(60, t + 0.8);
      gain.gain.setValueAtTime(0.2, t);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.8);
      osc.start(t); osc.stop(t + 0.8);
      break;
    case 'victory':
      osc.type = 'sine';
      osc.frequency.setValueAtTime(523, t);
      osc.frequency.setValueAtTime(659, t + 0.15);
      osc.frequency.setValueAtTime(784, t + 0.3);
      osc.frequency.setValueAtTime(1047, t + 0.45);
      gain.gain.setValueAtTime(0.18, t);
      gain.gain.setValueAtTime(0.2, t + 0.45);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.8);
      osc.start(t); osc.stop(t + 0.8);
      break;
    case 'rocket':
      osc.type = 'sawtooth';
      osc.frequency.setValueAtTime(150, t);
      osc.frequency.exponentialRampToValueAtTime(50, t + 0.2);
      gain.gain.setValueAtTime(0.15, t);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.2);
      osc.start(t); osc.stop(t + 0.2);
      break;
    case 'flame':
      osc.type = 'sawtooth';
      osc.frequency.setValueAtTime(60, t);
      osc.frequency.linearRampToValueAtTime(120, t + 0.05);
      osc.frequency.linearRampToValueAtTime(40, t + 0.1);
      gain.gain.setValueAtTime(0.08, t);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
      osc.start(t); osc.stop(t + 0.1);
      break;
    case 'homing':
      osc.type = 'sine';
      osc.frequency.setValueAtTime(900, t);
      osc.frequency.exponentialRampToValueAtTime(600, t + 0.1);
      gain.gain.setValueAtTime(0.1, t);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
      osc.start(t); osc.stop(t + 0.1);
      break;
    case 'machine':
      osc.type = 'square';
      osc.frequency.setValueAtTime(500, t);
      osc.frequency.exponentialRampToValueAtTime(200, t + 0.04);
      gain.gain.setValueAtTime(0.08, t);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.04);
      osc.start(t); osc.stop(t + 0.04);
      break;
    case 'wave':
      osc.type = 'triangle';
      osc.frequency.setValueAtTime(300, t);
      osc.frequency.linearRampToValueAtTime(600, t + 0.05);
      osc.frequency.linearRampToValueAtTime(300, t + 0.1);
      gain.gain.setValueAtTime(0.1, t);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.12);
      osc.start(t); osc.stop(t + 0.12);
      break;
  }
}

// ============================================================
//  MUSIC ENGINE ‚Äî Procedural Chip-tune via Web Audio
// ============================================================
let musicEnabled = true;
let sfxEnabled = true;
let musicVolume = 0.6;
let sfxVolume = 0.8;
let musicGainNode = null;
let musicPlaying = false;
let musicIntervalId = null;
let currentMusicTrack = null;

// Music note helpers
const NOTE_FREQ = {
  C3:131, D3:147, E3:165, F3:175, G3:196, A3:220, B3:247,
  C4:262, D4:294, E4:330, F4:349, G4:392, A4:440, B4:494,
  C5:523, D5:587, E5:659, F5:698, G5:784, A5:880, B5:988,
  C6:1047, R:0 // R = rest
};

// Melody tracks per music state
const MUSIC_TRACKS = {
  title: {
    tempo: 140,
    melody: ['E4','E4','R','E4','R','C4','E4','R','G4','R','R','R','G3','R','R','R',
             'C4','R','R','G3','R','R','E3','R','R','A3','R','B3','R','A3','R','R'],
    bass:   ['C3','R','R','G3','R','R','C3','R','E3','R','R','R','G3','R','R','R',
             'C3','R','R','G3','R','R','C3','R','R','F3','R','G3','R','F3','R','R'],
  },
  action: {
    tempo: 160,
    melody: ['E4','E4','E5','R','E4','D4','E4','R','G4','R','A4','R','G4','E4','R','R',
             'A4','A4','A4','R','G4','A4','R','R','E4','R','C4','R','D4','E4','R','R'],
    bass:   ['A3','R','A3','R','A3','R','A3','R','C3','R','C3','R','C3','R','C3','R',
             'F3','R','F3','R','E3','R','E3','R','A3','R','A3','R','A3','R','A3','R'],
  },
  boss: {
    tempo: 180,
    melody: ['C4','C4','C4','R','C4','D4','E4','R','E4','D4','C4','R','G3','R','R','R',
             'C4','C4','B3','R','A3','B3','C4','R','G3','A3','G3','R','R','R','R','R'],
    bass:   ['C3','R','C3','R','C3','R','C3','R','E3','R','E3','R','G3','R','G3','R',
             'F3','R','F3','R','F3','R','F3','R','G3','R','G3','R','G3','R','G3','R'],
  },
  gameover: {
    tempo: 90,
    melody: ['E4','D4','C4','R','B3','A3','R','R'],
    bass:   ['A3','R','F3','R','E3','A3','R','R'],
  },
  victory: {
    tempo: 140,
    melody: ['C4','E4','G4','C5','R','G4','C5','E5','R','R','C5','E5','G5','R','R','R'],
    bass:   ['C3','R','E3','R','G3','R','C3','R','E3','R','G3','R','C3','R','R','R'],
  },
};

function startMusic(trackName) {
  if (!audioCtx || !musicEnabled) return;
  stopMusic();
  const track = MUSIC_TRACKS[trackName];
  if (!track) return;
  currentMusicTrack = trackName;
  musicPlaying = true;

  if (!musicGainNode) {
    musicGainNode = audioCtx.createGain();
    musicGainNode.connect(audioCtx.destination);
  }
  musicGainNode.gain.setValueAtTime(musicVolume * 0.25, audioCtx.currentTime);

  let step = 0;
  const secPerBeat = 60 / track.tempo;

  musicIntervalId = setInterval(() => {
    if (!audioCtx || !musicEnabled || !musicPlaying) { stopMusic(); return; }
    const t = audioCtx.currentTime;

    // Melody
    const noteKey = track.melody[step % track.melody.length];
    const freq = NOTE_FREQ[noteKey];
    if (freq > 0) {
      const osc = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      osc.type = 'square';
      osc.frequency.setValueAtTime(freq, t);
      g.gain.setValueAtTime(musicVolume * 0.15, t);
      g.gain.exponentialRampToValueAtTime(0.001, t + secPerBeat * 0.9);
      osc.connect(g); g.connect(musicGainNode);
      osc.start(t); osc.stop(t + secPerBeat);
    }

    // Bass
    const bassKey = track.bass[step % track.bass.length];
    const bassFreq = NOTE_FREQ[bassKey];
    if (bassFreq > 0) {
      const osc2 = audioCtx.createOscillator();
      const g2 = audioCtx.createGain();
      osc2.type = 'triangle';
      osc2.frequency.setValueAtTime(bassFreq, t);
      g2.gain.setValueAtTime(musicVolume * 0.12, t);
      g2.gain.exponentialRampToValueAtTime(0.001, t + secPerBeat * 0.9);
      osc2.connect(g2); g2.connect(musicGainNode);
      osc2.start(t); osc2.stop(t + secPerBeat);
    }

    step++;
    // Loop
    if (step >= Math.max(track.melody.length, track.bass.length)) step = 0;
  }, secPerBeat * 1000);
}

function stopMusic() {
  musicPlaying = false;
  if (musicIntervalId) { clearInterval(musicIntervalId); musicIntervalId = null; }
  currentMusicTrack = null;
}

function toggleMusic() {
  musicEnabled = !musicEnabled;
  const btn = document.getElementById('musicToggle');
  if (btn) { btn.textContent = musicEnabled ? 'üéµ' : 'üéµ'; btn.classList.toggle('muted', !musicEnabled); }
  const cb = document.getElementById('s_musicEnabled');
  if (cb) cb.checked = musicEnabled;
  if (!musicEnabled) stopMusic();
  try { localStorage.setItem('contraForce_musicEnabled', musicEnabled ? '1' : '0'); } catch(e) {}
}

function toggleSFX() {
  sfxEnabled = !sfxEnabled;
  const btn = document.getElementById('sfxToggle');
  if (btn) { btn.textContent = sfxEnabled ? 'üîä' : 'üîá'; btn.classList.toggle('muted', !sfxEnabled); }
  const cb = document.getElementById('s_sfxEnabled');
  if (cb) cb.checked = sfxEnabled;
  try { localStorage.setItem('contraForce_sfxEnabled', sfxEnabled ? '1' : '0'); } catch(e) {}
}

function setMusicVolume(v) {
  musicVolume = Math.max(0, Math.min(1, v));
  if (musicGainNode) musicGainNode.gain.setValueAtTime(musicVolume * 0.25, audioCtx.currentTime);
  const el = document.getElementById('v_musicVol');
  if (el) el.textContent = Math.round(musicVolume * 100);
  try { localStorage.setItem('contraForce_musicVol', String(musicVolume)); } catch(e) {}
}

function setSfxVolume(v) {
  sfxVolume = Math.max(0, Math.min(1, v));
  const el = document.getElementById('v_sfxVol');
  if (el) el.textContent = Math.round(sfxVolume * 100);
  try { localStorage.setItem('contraForce_sfxVol', String(sfxVolume)); } catch(e) {}
}

// Load audio prefs
(function loadAudioPrefs(){
  try {
    const me = localStorage.getItem('contraForce_musicEnabled');
    if (me === '0') { musicEnabled = false; }
    const se = localStorage.getItem('contraForce_sfxEnabled');
    if (se === '0') { sfxEnabled = false; }
    const mv = localStorage.getItem('contraForce_musicVol');
    if (mv) musicVolume = parseFloat(mv);
    const sv = localStorage.getItem('contraForce_sfxVol');
    if (sv) sfxVolume = parseFloat(sv);
  } catch(e) {}
})();

// Update music based on game state (called from game loop)
function updateMusic() {
  if (!musicEnabled || !audioCtx) return;
  let desired = null;
  if (gameState === 'title') desired = 'title';
  else if (gameState === 'playing') {
    // Check if boss is active and on screen
    const bossActive = enemies.some(e => e.isBoss && e.active);
    desired = bossActive ? 'boss' : 'action';
  } else if (gameState === 'gameover') desired = 'gameover';
  else if (gameState === 'victory') desired = 'victory';
  if (desired && desired !== currentMusicTrack) startMusic(desired);
}

// ============================================================
//  SAVE / LOAD GAME STATE
// ============================================================
function showSaveToast(msg, type) {
  const el = document.getElementById('saveToast');
  if (!el) return;
  el.textContent = msg;
  el.className = 'save-toast show' + (type === 'error' ? ' error' : '');
  setTimeout(() => { el.className = 'save-toast'; }, 2000);
}

function getFullGameState() {
  return {
    version: 2,
    timestamp: Date.now(),
    score, stage, gameState: 'playing',
    currentDifficulty, diffSettings: { ...diffSettings },
    player: serializePlayer(player),
    player2: (coopMode && player2) ? serializePlayer(player2) : null,
    coopMode,
    level: { map: level.map, cols: level.cols, rows: level.rows, groundRow: level.groundRow, treasureMap: level.treasureMap || {} },
    enemies: enemies.map(e => ({...e})),
    powerups: powerups.map(p => ({...p})),
    objects: objects.map(o => ({...o})),
    treasureItems: treasureItems.map(t => ({...t})),
    vehiclePickups: vehiclePickups.map(v => ({...v})),
    camX, camY, zoom,
    runStats: { ...runStats, weaponsCollected: [...runStats.weaponsCollected] },
    godMode, editorMode, playerSpeedBoost,
  };
}

function serializePlayer(p) {
  if (!p) return null;
  const s = {};
  for (const k in p) {
    if (k === 'weapon') { s._weaponType = p.weapon.type || p.weapon.name; continue; }
    if (k === 'grapple') { s.grapple = p.grapple ? {...p.grapple} : null; continue; }
    s[k] = p[k];
  }
  return s;
}

function deserializePlayer(s) {
  if (!s) return null;
  const p = {...s};
  // Restore weapon
  if (s._weaponType) {
    const wName = s._weaponType.toUpperCase();
    p.weapon = WEAPONS[wName] || WEAPONS.RIFLE;
    delete p._weaponType;
  } else {
    p.weapon = WEAPONS.RIFLE;
  }
  return p;
}

function saveGameState() {
  if (gameState !== 'playing') { showSaveToast('Can only save during gameplay', 'error'); return; }
  try {
    const state = getFullGameState();
    localStorage.setItem('contraForce_saveState', JSON.stringify(state));
    showSaveToast('üíæ Game Saved!');
    playSound('powerup');
  } catch(e) { showSaveToast('Save failed: ' + e.message, 'error'); }
}

function loadGameState() {
  try {
    const raw = localStorage.getItem('contraForce_saveState');
    if (!raw) { showSaveToast('No saved game found', 'error'); return; }
    const state = JSON.parse(raw);
    restoreGameState(state);
    showSaveToast('üìÇ Game Loaded!');
    playSound('powerup');
  } catch(e) { showSaveToast('Load failed: ' + e.message, 'error'); }
}

function restoreGameState(state) {
  initAudio();
  score = state.score || 0;
  stage = state.stage || 1;
  if (state.currentDifficulty) setDifficulty(state.currentDifficulty);
  if (state.diffSettings) diffSettings = { ...diffSettings, ...state.diffSettings };

  // Restore level
  if (state.level) {
    level = { map: state.level.map, cols: state.level.cols, rows: state.level.rows, groundRow: state.level.groundRow, treasureMap: state.level.treasureMap || {} };
  } else {
    level = generateLevel(stage);
  }

  // Restore player
  player = deserializePlayer(state.player) || createPlayer(60);
  coopMode = !!state.coopMode;
  if (coopMode && state.player2) {
    player2 = deserializePlayer(state.player2);
  } else {
    player2 = coopMode ? createPlayer(100) : null;
  }

  // Restore entity arrays (safe defaults)
  enemies = state.enemies || [];
  powerups = state.powerups || [];
  objects = state.objects || [];
  treasureItems = state.treasureItems || [];
  vehiclePickups = state.vehiclePickups || [];
  bullets = [];
  enemyBullets = [];
  particles = [];
  popups = [];

  camX = state.camX || 0;
  camY = state.camY || 0;
  zoom = state.zoom || 1;
  godMode = !!state.godMode;
  editorMode = !!state.editorMode;
  playerSpeedBoost = state.playerSpeedBoost || 0;

  if (state.runStats) {
    Object.assign(runStats, state.runStats);
    runStats.weaponsCollected = new Set(state.runStats.weaponsCollected || []);
  }

  gameState = 'playing';
  overlay.classList.add('hidden');
  hud.classList.remove('hidden');
  updateAchHud();
}

function exportSaveFile() {
  if (gameState !== 'playing') { showSaveToast('Can only export during gameplay', 'error'); return; }
  const state = getFullGameState();
  const blob = new Blob([JSON.stringify(state)], { type: 'application/json' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = `contra_save_stage${stage}_${new Date().toISOString().slice(0,10)}.json`;
  a.click();
  URL.revokeObjectURL(a.href);
  showSaveToast('‚¨áÔ∏è Save exported!');
}

function importSaveFile() {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '.json';
  input.onchange = e => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = ev => {
      try {
        const state = JSON.parse(ev.target.result);
        restoreGameState(state);
        showSaveToast('üìÇ Save imported!');
      } catch(err) { showSaveToast('Invalid save file', 'error'); }
    };
    reader.readAsText(file);
  };
  input.click();
}

// Quick save/load with F5/F9
window.addEventListener('keydown', e => {
  if (e.code === 'F5' && !e.ctrlKey && !e.altKey) { e.preventDefault(); saveGameState(); }
  if (e.code === 'F9' && !e.ctrlKey && !e.altKey) { e.preventDefault(); loadGameState(); }
});

// ============================================================
//  LEVEL FILE I/O (Download / Upload)
// ============================================================
function getFullLevelData() {
  return {
    version: 1,
    stage,
    level: { map: level.map, cols: level.cols, rows: level.rows, groundRow: level.groundRow, treasureMap: level.treasureMap || {} },
    enemies: enemies.map(e => ({...e})),
    powerups: powerups.map(p => ({...p})),
    objects: objects.map(o => ({...o})),
  };
}

function downloadLevelFile() {
  if (!level) { showSaveToast('No level loaded', 'error'); return; }
  const data = getFullLevelData();
  const blob = new Blob([JSON.stringify(data)], { type: 'application/json' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = `contra_level_${stage}_${Date.now()}.json`;
  a.click();
  URL.revokeObjectURL(a.href);
  showSaveToast('‚¨áÔ∏è Level exported!');
}

function uploadLevelFile() {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '.json';
  input.onchange = e => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = ev => {
      try {
        const data = JSON.parse(ev.target.result);
        if (data.level && data.level.map) {
          level.map = data.level.map;
          level.cols = data.level.cols;
          level.rows = data.level.rows;
          level.groundRow = data.level.groundRow || level.rows - 2;
          level.treasureMap = data.level.treasureMap || {};
          if (data.enemies) enemies = data.enemies;
          if (data.powerups) powerups = data.powerups;
          if (data.objects) objects = data.objects;
          showSaveToast('‚¨ÜÔ∏è Level imported!');
        } else { showSaveToast('Invalid level file', 'error'); }
      } catch(err) { showSaveToast('Parse error: ' + err.message, 'error'); }
    };
    reader.readAsText(file);
  };
  input.click();
}

// ============================================================
//  SHAREABLE LEADERBOARD ‚Äî Encode/Decode Score Codes
// ============================================================
function encodeScoreCode(entry) {
  const data = { s: entry.score, st: entry.stage, k: entry.kills, d: Math.round(entry.duration), dt: entry.date, o: entry.outcome, df: entry.difficulty || 'normal' };
  try { return btoa(JSON.stringify(data)); } catch(e) { return ''; }
}

function decodeScoreCode(code) {
  try {
    const data = JSON.parse(atob(code.trim()));
    return { score: data.s, stage: data.st, kills: data.k, duration: data.d, date: data.dt, outcome: data.o, difficulty: data.df || 'normal', imported: true };
  } catch(e) { return null; }
}

function showShareModal() {
  // Get latest leaderboard entry
  const lb = getLeaderboard();
  const latest = lb.find(e => e.isLatest);
  if (!latest) { showSaveToast('No score to share', 'error'); return; }
  const code = encodeScoreCode(latest);
  const bg = document.createElement('div');
  bg.className = 'share-modal-bg';
  bg.innerHTML = `<div class="share-modal">
    <h3>üì§ SHARE SCORE</h3>
    <p style="font-size:8px;color:#aaa;margin:0 0 8px">Copy this code and share with friends!</p>
    <textarea id="shareCode" readonly>${code}</textarea>
    <div class="share-btns">
      <button onclick="navigator.clipboard.writeText(document.getElementById('shareCode').value);showSaveToast('üìã Copied!')" style="background:#004466;color:#44ddff;border-color:#44ddff">üìã COPY</button>
      <button onclick="this.closest('.share-modal-bg').remove()" style="background:#333;color:#aaa;border-color:#666">CLOSE</button>
    </div>
  </div>`;
  bg.addEventListener('click', e => { if (e.target === bg) bg.remove(); });
  document.body.appendChild(bg);
}

function showImportScoreModal() {
  const bg = document.createElement('div');
  bg.className = 'share-modal-bg';
  bg.innerHTML = `<div class="share-modal">
    <h3>üì• IMPORT SCORE</h3>
    <p style="font-size:8px;color:#aaa;margin:0 0 8px">Paste a shared score code below:</p>
    <textarea id="importCode" placeholder="Paste score code here..."></textarea>
    <div class="share-btns">
      <button onclick="importScoreFromModal()" style="background:#003322;color:#44ff88;border-color:#44ff88">üì• IMPORT</button>
      <button onclick="this.closest('.share-modal-bg').remove()" style="background:#333;color:#aaa;border-color:#666">CLOSE</button>
    </div>
  </div>`;
  bg.addEventListener('click', e => { if (e.target === bg) bg.remove(); });
  document.body.appendChild(bg);
}

function importScoreFromModal() {
  const ta = document.getElementById('importCode');
  if (!ta || !ta.value.trim()) { showSaveToast('No code entered', 'error'); return; }
  const entry = decodeScoreCode(ta.value);
  if (!entry) { showSaveToast('Invalid score code', 'error'); return; }
  saveLeaderboardEntry(entry);
  showSaveToast('üì• Score imported!');
  ta.closest('.share-modal-bg').remove();
  renderLeaderboard();
}

// ============================================================
//  TOUCH CONTROLS ENHANCEMENTS
// ============================================================
let touchVibrate = true;
let touchOpacity = 0.7;
let touchSwapped = false;

function setTouchOpacity(v) {
  touchOpacity = v;
  const tc = document.getElementById('touchControls');
  if (tc) tc.style.opacity = v;
  const el = document.getElementById('v_touchOpacity');
  if (el) el.textContent = Math.round(v * 100);
  try { localStorage.setItem('contraForce_touchOpacity', String(v)); } catch(e) {}
}

function swapTouchSides(swap) {
  touchSwapped = swap;
  const tc = document.getElementById('touchControls');
  if (!tc) return;
  const dpad = tc.querySelector('.touch-dpad');
  const actions = tc.querySelector('.touch-actions');
  if (dpad && actions) {
    if (swap) {
      dpad.style.order = '2';
      dpad.style.left = 'auto'; dpad.style.right = '20px';
      actions.style.order = '1';
      actions.style.right = 'auto'; actions.style.left = '20px';
    } else {
      dpad.style.order = '';
      dpad.style.left = ''; dpad.style.right = '';
      actions.style.order = '';
      actions.style.right = ''; actions.style.left = '';
    }
  }
  try { localStorage.setItem('contraForce_touchSwapped', swap ? '1' : '0'); } catch(e) {}
}

// Load touch prefs
(function loadTouchPrefs(){
  try {
    const op = localStorage.getItem('contraForce_touchOpacity');
    if (op) touchOpacity = parseFloat(op);
    const sw = localStorage.getItem('contraForce_touchSwapped');
    if (sw === '1') touchSwapped = true;
  } catch(e) {}
})();
const keys = {};

// Configurable keybinds: each action has an array of key codes
const keybinds = {
  left:  ['ArrowLeft', 'KeyA'],
  right: ['ArrowRight', 'KeyD'],
  up:    ['ArrowUp', 'KeyW'],
  down:  ['ArrowDown', 'KeyS'],
  jump:  ['KeyX'],
  shoot: ['Space', 'KeyZ'],
  grapple: ['KeyC'],
};

// Player 2 keybinds for co-op mode
const keybinds2 = {
  left:  ['KeyJ'],
  right: ['KeyL'],
  up:    ['KeyI'],
  down:  ['KeyK'],
  jump:  ['KeyU'],
  shoot: ['KeyO', 'KeyP'],
  grapple: ['KeyY'],
};

// Pretty name for display
function keyName(code) {
  const map = {
    ArrowLeft:'‚Üê', ArrowRight:'‚Üí', ArrowUp:'‚Üë', ArrowDown:'‚Üì',
    Space:'SPACE', KeyA:'A', KeyB:'B', KeyC:'C', KeyD:'D', KeyE:'E',
    KeyF:'F', KeyG:'G', KeyH:'H', KeyI:'I', KeyJ:'J', KeyK:'K',
    KeyL:'L', KeyM:'M', KeyN:'N', KeyO:'O', KeyP:'P', KeyQ:'Q',
    KeyR:'R', KeyS:'S', KeyT:'T', KeyU:'U', KeyV:'V', KeyW:'W',
    KeyX:'X', KeyY:'Y', KeyZ:'Z',
    Digit0:'0', Digit1:'1', Digit2:'2', Digit3:'3', Digit4:'4',
    Digit5:'5', Digit6:'6', Digit7:'7', Digit8:'8', Digit9:'9',
    ShiftLeft:'L-SHIFT', ShiftRight:'R-SHIFT',
    ControlLeft:'L-CTRL', ControlRight:'R-CTRL',
    AltLeft:'L-ALT', AltRight:'R-ALT',
    Tab:'TAB', Enter:'ENTER', Backspace:'BKSP', Escape:'ESC',
    Comma:',', Period:'.', Slash:'/', Semicolon:';', Quote:"'",
    BracketLeft:'[', BracketRight:']', Backslash:'\\',
    NumpadAdd:'NUM+', NumpadSubtract:'NUM-',
    Numpad0:'NUM0', Numpad1:'NUM1', Numpad2:'NUM2', Numpad3:'NUM3',
    Numpad4:'NUM4', Numpad5:'NUM5', Numpad6:'NUM6', Numpad7:'NUM7',
    Numpad8:'NUM8', Numpad9:'NUM9',
  };
  return map[code] || code;
}

window.addEventListener('keydown', e => {
  if (adminOpen && e.target.closest('#adminPanel')) return;
  // If we're rebinding a key, capture it
  if (rebindingAction) {
    e.preventDefault();
    e.stopPropagation();
    finishRebind(e.code);
    return;
  }
  keys[e.code] = true;
  if (gameState === 'playing') e.preventDefault();
});
window.addEventListener('keyup', e => {
  keys[e.code] = false;
  if (gameState === 'playing') e.preventDefault();
});

// ============================================================
//  GAMEPAD / CONTROLLER SUPPORT
// ============================================================
// Uses the Gamepad API with per-frame polling.
// Gamepad 0 ‚Üí Player 1, Gamepad 1 ‚Üí Player 2.
// Standard mapping (Xbox-style):
//   D-pad / Left stick ‚Üí Move & Aim
//   A (btn 0) ‚Üí Jump          B (btn 1) ‚Üí Shoot
//   X (btn 2) ‚Üí Shoot          Y (btn 3) ‚Üí Grapple
//   LB (btn 4) ‚Üí Grapple       RB (btn 5) ‚Üí Grapple
//   Start (btn 9) ‚Üí Start Game / Advance cutscene
//   LT (btn 6) ‚Üí Shoot         RT (btn 7) ‚Üí Shoot

let gpDeadzone = 0.20;
let gpVibration = true;
const gpState = [null, null]; // cached state per gamepad index
const gpPrev = [{}, {}];       // previous button states for edge detection

// Standard button indices
const GP_A = 0, GP_B = 1, GP_X = 2, GP_Y = 3;
const GP_LB = 4, GP_RB = 5, GP_LT = 6, GP_RT = 7;
const GP_SELECT = 8, GP_START = 9;
const GP_L3 = 10, GP_R3 = 11;
const GP_DPAD_UP = 12, GP_DPAD_DOWN = 13, GP_DPAD_LEFT = 14, GP_DPAD_RIGHT = 15;

function pollGamepads() {
  const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
  for (let i = 0; i < 2; i++) {
    const gp = gamepads[i];
    if (gp && gp.connected) {
      // Cache previous button states
      if (gpState[i]) {
        for (let b = 0; b < gpState[i].buttons.length; b++) {
          gpPrev[i][b] = gpState[i].buttons[b].pressed;
        }
      }
      gpState[i] = gp;
    } else {
      gpState[i] = null;
    }
  }
}

// Check if a button was JUST pressed this frame (edge detection for Start, etc.)
function gpJustPressed(padIdx, btnIdx) {
  const gp = gpState[padIdx];
  if (!gp || !gp.buttons[btnIdx]) return false;
  return gp.buttons[btnIdx].pressed && !gpPrev[padIdx][btnIdx];
}

function gpBtn(padIdx, btnIdx) {
  const gp = gpState[padIdx];
  if (!gp || !gp.buttons[btnIdx]) return false;
  return gp.buttons[btnIdx].pressed;
}

function gpAxis(padIdx, axisIdx) {
  const gp = gpState[padIdx];
  if (!gp || gp.axes[axisIdx] === undefined) return 0;
  const v = gp.axes[axisIdx];
  return Math.abs(v) < gpDeadzone ? 0 : v;
}

// Gamepad vibration (rumble)
function gpRumble(padIdx, duration, weakMag, strongMag) {
  if (!gpVibration) return;
  const gp = gpState[padIdx];
  if (!gp) return;
  const va = gp.vibrationActuator;
  if (va && va.playEffect) {
    va.playEffect('dual-rumble', {
      duration: duration || 100,
      weakMagnitude: weakMag || 0.3,
      strongMagnitude: strongMag || 0.5,
    }).catch(() => {});
  }
}

// Helper: gamepad input for a specific pad index
function gpLeft(i)    { return gpBtn(i, GP_DPAD_LEFT)  || gpAxis(i, 0) < -0.5; }
function gpRight(i)   { return gpBtn(i, GP_DPAD_RIGHT) || gpAxis(i, 0) > 0.5; }
function gpUp(i)      { return gpBtn(i, GP_DPAD_UP)    || gpAxis(i, 1) < -0.5; }
function gpDown(i)    { return gpBtn(i, GP_DPAD_DOWN)  || gpAxis(i, 1) > 0.5; }
function gpJump(i)    { return gpBtn(i, GP_A); }
function gpShoot(i)   { return gpBtn(i, GP_B) || gpBtn(i, GP_X) || gpBtn(i, GP_LT) || gpBtn(i, GP_RT); }
function gpGrapple(i) { return gpBtn(i, GP_Y) || gpBtn(i, GP_LB) || gpBtn(i, GP_RB); }
function gpStart(i)   { return gpJustPressed(i, GP_START); }

// Gamepad HUD update
function updateGpHud() {
  const el = document.getElementById('gpHud');
  if (!el) return;
  const gp0 = gpState[0], gp1 = gpState[1];
  if (!gp0 && !gp1) { el.style.display = 'none'; return; }
  el.style.display = '';
  let html = '<span class="gp-hud-icon">üéÆ</span>';
  if (gp0) html += '<span class="gp-hud-p1">P1</span> ';
  if (gp1) html += '<span class="gp-hud-p2">P2</span>';
  el.innerHTML = html;
}

// Admin panel gamepad status update
function updateGpAdminStatus() {
  const el = document.getElementById('gpAdminStatus');
  if (!el) return;
  const gp0 = gpState[0], gp1 = gpState[1];
  if (!gp0 && !gp1) { el.textContent = 'No gamepads detected'; el.style.color = '#888'; return; }
  let parts = [];
  if (gp0) parts.push('P1: ' + (gp0.id.length > 40 ? gp0.id.substring(0, 40) + '‚Ä¶' : gp0.id));
  if (gp1) parts.push('P2: ' + (gp1.id.length > 40 ? gp1.id.substring(0, 40) + '‚Ä¶' : gp1.id));
  el.innerHTML = parts.join('<br>');
  el.style.color = '#44ff88';
}

// Gamepad connection events
window.addEventListener('gamepadconnected', e => {
  updateGpHud();
  updateGpAdminStatus();
});
window.addEventListener('gamepaddisconnected', e => {
  const idx = e.gamepad.index;
  if (idx < 2) gpState[idx] = null;
  updateGpHud();
  updateGpAdminStatus();
});

// --- Player 1 input (keyboard + touch + gamepad 0) ---
function isLeft()  { return keybinds.left.some(k => keys[k]) || gpLeft(0); }
function isRight() { return keybinds.right.some(k => keys[k]) || gpRight(0); }
function isUp()    { return keybinds.up.some(k => keys[k]) || gpUp(0); }
function isDown()  { return keybinds.down.some(k => keys[k]) || gpDown(0); }
function isJump()  { return keybinds.jump.some(k => keys[k]) || isUp() || gpJump(0); }
function isJumpKey() { return keybinds.jump.some(k => keys[k]) || gpJump(0); }
function isShoot() { return keybinds.shoot.some(k => keys[k]) || gpShoot(0); }
function isGrapple() { return keybinds.grapple.some(k => keys[k]) || gpGrapple(0); }

// --- Player 2 input (keyboard + gamepad 1) ---
function isLeft2()    { return keybinds2.left.some(k => keys[k]) || gpLeft(1); }
function isRight2()   { return keybinds2.right.some(k => keys[k]) || gpRight(1); }
function isUp2()      { return keybinds2.up.some(k => keys[k]) || gpUp(1); }
function isDown2()    { return keybinds2.down.some(k => keys[k]) || gpDown(1); }
function isJump2()    { return keybinds2.jump.some(k => keys[k]) || isUp2() || gpJump(1); }
function isJumpKey2() { return keybinds2.jump.some(k => keys[k]) || gpJump(1); }
function isShoot2()   { return keybinds2.shoot.some(k => keys[k]) || gpShoot(1); }
function isGrapple2() { return keybinds2.grapple.some(k => keys[k]) || gpGrapple(1); }

// Rebinding state
let rebindingAction = null;  // e.g. 'left'
let rebindingSlot = 0;       // which slot (0 or 1)
let rebindingEl = null;       // the button being rebound

// Set touch button size and save preference
function setTouchButtonSize(size) {
  const validSizes = ['small', 'medium', 'large'];
  if (!validSizes.includes(size)) size = 'medium';
  
  const touchControls = document.getElementById('touchControls');
  if (!touchControls) return;
  
  // Remove all size classes and add new one
  touchControls.classList.remove('size-small', 'size-medium', 'size-large');
  touchControls.classList.add('size-' + size);
  
  // Update size button highlights
  document.getElementById('sizeSmall')?.classList.toggle('active', size === 'small');
  document.getElementById('sizeMedium')?.classList.toggle('active', size === 'medium');
  document.getElementById('sizeLarge')?.classList.toggle('active', size === 'large');
  
  // Save preference to localStorage
  localStorage.setItem('touchButtonSize', size);
}

// --- MOBILE TOUCH INPUT ---
const touchKeys = {}; // Tracks active touch inputs
const TOUCH_KEY_MAP = {
  up: 'ArrowUp',
  down: 'ArrowDown',
  left: 'ArrowLeft',
  right: 'ArrowRight',
  jump: 'KeyX',
  shoot: 'Space',
  grapple: 'KeyC',
};

function isMobileDevice() {
  return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)
    || (window.innerWidth <= 768 && window.matchMedia('(hover: none)').matches);
}

function initTouchControls() {
  const touchControls = document.getElementById('touchControls');
  if (!touchControls) return;

  // Load saved button size preference or default to medium
  let savedSize = localStorage.getItem('touchButtonSize') || 'medium';
  setTouchButtonSize(savedSize);

  // Show touch controls on mobile devices
  if (isMobileDevice()) {
    touchControls.classList.add('visible');
  }

  // Size selector buttons
  document.getElementById('sizeSmall')?.addEventListener('click', () => setTouchButtonSize('small'));
  document.getElementById('sizeMedium')?.addEventListener('click', () => setTouchButtonSize('medium'));
  document.getElementById('sizeLarge')?.addEventListener('click', () => setTouchButtonSize('large'));

  // Get all touch buttons
  const touchButtons = document.querySelectorAll('[data-action]');
  
  touchButtons.forEach(btn => {
    const action = btn.getAttribute('data-action');
    
    // Touch start (finger down)
    btn.addEventListener('touchstart', e => {
      e.preventDefault();
      e.stopPropagation();
      btn.classList.add('active');
      touchKeys[action] = true;
      // Simulate keyboard down
      const keyCode = TOUCH_KEY_MAP[action];
      if (keyCode) keys[keyCode] = true;
    }, { passive: false });
    
    // Mouse down (for desktop testing)
    btn.addEventListener('mousedown', e => {
      e.preventDefault();
      btn.classList.add('active');
      touchKeys[action] = true;
      const keyCode = TOUCH_KEY_MAP[action];
      if (keyCode) keys[keyCode] = true;
    });
    
    // Touch end (finger up)
    btn.addEventListener('touchend', e => {
      e.preventDefault();
      e.stopPropagation();
      btn.classList.remove('active');
      delete touchKeys[action];
      const keyCode = TOUCH_KEY_MAP[action];
      if (keyCode) keys[keyCode] = false;
    }, { passive: false });
    
    // Touch cancel (interrupted touch)
    btn.addEventListener('touchcancel', e => {
      btn.classList.remove('active');
      delete touchKeys[action];
      const keyCode = TOUCH_KEY_MAP[action];
      if (keyCode) keys[keyCode] = false;
    });
    
    // Mouse up/leave (for desktop testing)
    btn.addEventListener('mouseup', e => {
      btn.classList.remove('active');
      delete touchKeys[action];
      const keyCode = TOUCH_KEY_MAP[action];
      if (keyCode) keys[keyCode] = false;
    });
    
    btn.addEventListener('mouseleave', e => {
      btn.classList.remove('active');
      delete touchKeys[action];
      const keyCode = TOUCH_KEY_MAP[action];
      if (keyCode) keys[keyCode] = false;
    });
  });
  
  // Prevent default touch behaviors to avoid scrolling
  touchControls.addEventListener('touchmove', e => e.preventDefault(), { passive: false });
  touchControls.addEventListener('touchstart', e => e.stopPropagation(), { passive: false });

  // Apply saved touch preferences
  setTouchOpacity(touchOpacity);
  if (touchSwapped) swapTouchSides(true);
}

// --- GAME STATE ---
let gameState = 'title'; // title, playing, gameover, victory, cutscene
let score = 0;
let stage = 1;

// ============================================================
//  GAME MODES
// ============================================================
let gameMode = 'campaign'; // campaign, endless, bossrush, timeattack, newgameplus, challenge
let ngPlusLevel = 0; // New Game+ cycle count
let ngPlusWeapon = 'NORMAL'; // weapon carried into NG+

// --- ENDLESS / SURVIVAL MODE ---
let endlessWave = 0;
let endlessSpawnTimer = 0;
let endlessBaseInterval = 180; // frames between spawns (decreases per wave)
let endlessBossEvery = 5; // boss every N waves
let endlessKills = 0;
let endlessKillsNeeded = 0;

// --- BOSS RUSH MODE ---
let bossRushIdx = 0; // which boss (0-9)
let bossRushTimer = 0; // total elapsed frames
let bossRushBestTimes = [];
try { bossRushBestTimes = JSON.parse(localStorage.getItem('contraForce_bossRushTimes') || '[]'); } catch(e) {}

// --- TIME ATTACK MODE ---
let timeAttackStage = 1;
let timeAttackTimer = 0; // elapsed frames
let timeAttackBests = {};
try { timeAttackBests = JSON.parse(localStorage.getItem('contraForce_timeAttackBests') || '{}'); } catch(e) {}

// --- CHALLENGE MISSIONS ---
const CHALLENGES = [
  { id: 'no_hit_boss', name: 'UNTOUCHABLE BOSS', desc: 'Defeat any boss without taking damage', icon: 'üõ°Ô∏è', check: null },
  { id: 'pistol_only', name: 'PISTOL ONLY', desc: 'Clear stage 1 using only the default weapon', icon: 'üî´', check: null },
  { id: 'pacifist', name: 'PACIFIST RUN', desc: 'Reach the boss of stage 1 with 0 kills', icon: 'üïäÔ∏è', check: null },
  { id: 'speed_demon', name: 'SPEED DEMON', desc: 'Clear any stage in under 45 seconds', icon: '‚ö°', check: null },
  { id: 'combo_king', name: 'COMBO KING', desc: 'Achieve a 20x combo in a single run', icon: 'üî•', check: null },
  { id: 'no_death_3', name: 'IRON MAN', desc: 'Clear 3 consecutive stages without dying', icon: 'üí™', check: null },
  { id: 'boss_rush_5m', name: 'BOSS SPEEDSTER', desc: 'Complete Boss Rush in under 5 minutes', icon: '‚è±Ô∏è', check: null },
  { id: 'endless_w10', name: 'SURVIVOR', desc: 'Reach wave 10 in Endless mode', icon: '‚ôæÔ∏è', check: null },
  { id: 'endless_w25', name: 'ENDURANCE', desc: 'Reach wave 25 in Endless mode', icon: 'üèãÔ∏è', check: null },
  { id: 'all_weapons', name: 'ARSENAL', desc: 'Collect every weapon type in a single run', icon: 'üéØ', check: null },
];
let challengeProgress = {};
try { challengeProgress = JSON.parse(localStorage.getItem('contraForce_challenges') || '{}'); } catch(e) {}
let activeChallenge = null; // currently active challenge id
let challengeState = {}; // per-run challenge tracking

function saveChallengeProgress() {
  try { localStorage.setItem('contraForce_challenges', JSON.stringify(challengeProgress)); } catch(e) {}
}

// --- MODE GAME OVER HANDLER ---
function handleModeGameOver() {
  // Don't trigger game over during demo mode
  if (gameState === 'demo') { stopDemoMode(); return; }
  playSound('game_over');
  gameState = 'gameover';

  if (gameMode === 'endless') {
    saveModeLeaderboardEntry('endless', {
      name: selectedCharacter || 'RICO',
      wave: endlessWave,
      score: score,
      kills: runStats.kills,
      date: new Date().toISOString()
    });
    showOverlay('SURVIVAL OVER', `WAVE ${endlessWave} | SCORE: ${score}`, 'PRESS ENTER TO RETRY');
  } else if (gameMode === 'bossrush') {
    const elapsed = Math.floor(bossRushTimer / 60);
    saveModeLeaderboardEntry('bossrush', {
      name: selectedCharacter || 'RICO',
      bossesDefeated: bossRushIdx,
      time: elapsed,
      score: score,
      date: new Date().toISOString()
    });
    showOverlay('BOSS RUSH FAILED', `BOSSES: ${bossRushIdx}/10 | TIME: ${elapsed}s`, 'PRESS ENTER TO RETRY');
  } else if (gameMode === 'timeattack') {
    const taTime = (timeAttackTimer / 60).toFixed(1);
    showOverlay('TIME ATTACK OVER', `STAGE ${timeAttackStage} | TIME: ${taTime}s | SCORE: ${score}`, 'PRESS ENTER TO RETRY');
  } else if (gameMode === 'challenge') {
    showOverlay('CHALLENGE FAILED', `${activeChallenge ? CHALLENGES.find(c=>c.id===activeChallenge)?.name || activeChallenge : 'Unknown'}`, 'PRESS ENTER TO RETRY');
  } else {
    // Campaign / NG+
    submitScore('gameover');
    showOverlay('GAME OVER', `FINAL SCORE: ${score}`, 'PRESS ENTER TO RESTART');
  }
}

// --- MODE LEADERBOARDS ---
function getModeLeaderboard(mode) {
  try {
    return JSON.parse(localStorage.getItem('contraForce_lb_' + mode) || '[]');
  } catch(e) { return []; }
}

function saveModeLeaderboardEntry(mode, entry) {
  const lb = getModeLeaderboard(mode);
  lb.push(entry);
  if (mode === 'endless') lb.sort((a, b) => b.wave - a.wave || b.score - a.score);
  else if (mode === 'bossrush' || mode === 'timeattack') lb.sort((a, b) => a.time - b.time || b.score - a.score);
  else lb.sort((a, b) => b.score - a.score);
  while (lb.length > 20) lb.pop();
  try { localStorage.setItem('contraForce_lb_' + mode, JSON.stringify(lb)); } catch(e) {}
}

// --- MODE DESCRIPTIONS ---
function getModeDesc(mode) {
  switch (mode) {
    case 'campaign': return 'Classic 10-stage campaign';
    case 'endless': return 'Infinite waves, escalating difficulty ‚Äî survive!';
    case 'bossrush': return 'Fight all 10 bosses back-to-back, timed';
    case 'timeattack': return 'Speedrun stages for best times';
    case 'newgameplus': return ngPlusLevel > 0 ? 'NG+' + ngPlusLevel + ' ‚Äî harder enemies, keep weapon' : 'Beat campaign first to unlock';
    case 'challenge': return 'Complete specific mission objectives';
    default: return '';
  }
}

function selectGameMode(mode) {
  gameMode = mode;
  // Update all mode buttons
  document.querySelectorAll('.mode-btn').forEach(b => {
    b.classList.toggle('active', b.dataset.mode === mode);
  });
  // Update descriptions
  const desc = getModeDesc(mode);
  const d1 = document.getElementById('modeDesc');
  const d2 = document.getElementById('modeDescOverlay');
  if (d1) d1.textContent = desc;
  if (d2) d2.textContent = desc;
  // Show challenge modal if challenge mode selected
  if (mode === 'challenge') showChallengeSelect();
  else hideChallengeSelect();
}

// ============================================================
//  ENDLESS / SURVIVAL MODE
// ============================================================
function initEndlessMode() {
  endlessWave = 0;
  endlessKills = 0;
  endlessSpawnTimer = 0;
  score = 0;
  stage = 1;
  challengeState = {};
}

function startEndlessWave() {
  endlessWave++;
  endlessKillsNeeded = 5 + endlessWave * 2;
  endlessKills = 0;
  endlessSpawnTimer = 0;
  endlessBaseInterval = Math.max(30, 180 - endlessWave * 6);

  // Every N waves, spawn a boss
  if (endlessWave > 1 && endlessWave % endlessBossEvery === 0) {
    spawnEndlessBoss();
  }
}

function spawnEndlessEnemy() {
  if (!level || !player) return;
  const waveMult = Math.min(4.0, 1.0 + endlessWave * 0.15);
  const typeKeys = Object.keys(ENEMY_TYPES);
  const typeKey = typeKeys[Math.floor(Math.random() * typeKeys.length)];
  const type = ENEMY_TYPES[typeKey];

  // Spawn near edges of viewport
  const side = Math.random() < 0.5 ? 1 : -1;
  let ex = player.x + side * (viewW() * 0.6 + Math.random() * 100);
  ex = Math.max(TILE, Math.min(ex, (level.cols - 2) * TILE));
  const col = Math.floor(ex / TILE);

  let ey = 0;
  if (type.flying) {
    ey = (2 + Math.floor(Math.random() * 4)) * TILE;
  } else {
    for (let r = 0; r < level.rows; r++) {
      if (col >= 0 && col < level.cols && level.map[r][col] === 1) {
        ey = r * TILE - type.h;
        break;
      }
    }
  }
  if (ey <= 0 && !type.flying) return;

  const scaledHp = Math.round(type.hp * diffSettings.enemyHpMult * waveMult);
  const scaledFireRate = Math.max(8, Math.round(type.fireRate * diffSettings.enemyFireRateMult / waveMult));
  enemies.push({
    x: ex, y: ey,
    ...type,
    hp: scaledHp, maxHp: scaledHp,
    fireRate: scaledFireRate,
    fireTimer: Math.floor(Math.random() * scaledFireRate),
    active: true, facing: side > 0 ? -1 : 1,
    patrolStart: ex - 5 * TILE, patrolEnd: ex + 5 * TILE,
    dir: side > 0 ? -1 : 1,
    vy: 0, onGround: false, jumpTimer: 0,
    shieldFacing: -1, teleportTimer: 0, cloakAlpha: 1,
    pairBuddy: null, pairOffset: 0,
    flyY: ey, flyPhase: Math.random() * Math.PI * 2,
  });
}

function spawnEndlessBoss() {
  if (!level || !player) return;
  const bossLevel = Math.floor(endlessWave / endlessBossEvery);
  const bossX = player.x + (Math.random() < 0.5 ? 300 : -300);
  const col = Math.max(2, Math.min(level.cols - 3, Math.floor(bossX / TILE)));
  let bossY = 0;
  for (let r = 0; r < level.rows; r++) {
    if (level.map[r][col] === 1) { bossY = r * TILE - 64; break; }
  }
  const bossHp = Math.round((30 + bossLevel * 25) * diffSettings.bossHpMult);
  enemies.push({
    x: col * TILE, y: bossY,
    w: 48, h: 64, hp: bossHp, maxHp: bossHp,
    speed: 1 + bossLevel * 0.1, score: 3000 + bossLevel * 500,
    color: '#ff2222', fireRate: Math.max(12, 25 - bossLevel * 2),
    fireTimer: 0, shootRange: 500,
    active: true, facing: -1,
    isBoss: true, etype: 'boss',
    patrolStart: (col - 8) * TILE, patrolEnd: (col + 8) * TILE,
    dir: -1, phase: 0, phaseTimer: 0, vy: 0, onGround: false,
  });
}

function updateEndlessMode() {
  if (gameMode !== 'endless' || gameState !== 'playing') return;

  // Count active enemies (not counting dead/inactive)
  const aliveEnemies = enemies.filter(e => e.active && e.hp > 0).length;

  endlessSpawnTimer++;
  // Spawn rate increases each wave
  const spawnInterval = Math.max(20, endlessBaseInterval - aliveEnemies * 10);
  if (endlessSpawnTimer >= spawnInterval && aliveEnemies < 15 + endlessWave) {
    spawnEndlessEnemy();
    endlessSpawnTimer = 0;
  }

  // Wave clear check
  if (endlessKills >= endlessKillsNeeded) {
    startEndlessWave();
    spawnPopup(player.x + player.w/2, player.y - 30, 'WAVE ' + endlessWave + '!', '#ff44ff', 16);
    playSound('stage_clear');
    triggerFlash('#ff44ff', 0.3);
    // Check challenge
    if (endlessWave >= 10 && !challengeProgress['endless_w10']) {
      challengeProgress['endless_w10'] = true; saveChallengeProgress();
    }
    if (endlessWave >= 25 && !challengeProgress['endless_w25']) {
      challengeProgress['endless_w25'] = true; saveChallengeProgress();
    }
  }
}

function onEndlessEnemyKill() {
  if (gameMode === 'endless') endlessKills++;
}

// ============================================================
//  BOSS RUSH MODE
// ============================================================
function initBossRush() {
  bossRushIdx = 0;
  bossRushTimer = 0;
  score = 0;
  stage = 1;
}

function spawnBossRushBoss() {
  const bossNum = bossRushIdx + 1;
  const bossHp = Math.round((30 + bossNum * 15) * diffSettings.bossHpMult);
  // Use a flat arena
  enemies = [];
  const cols = level.cols;
  const bossX = (cols - 8) * TILE;
  let bossY = 0;
  for (let r = 0; r < level.rows; r++) {
    if (level.map[r][cols - 8] === 1) { bossY = r * TILE - 64; break; }
  }
  enemies.push({
    x: bossX, y: bossY,
    w: 48, h: 64, hp: bossHp, maxHp: bossHp,
    speed: 1 + bossNum * 0.1, score: 2000 + bossNum * 500,
    color: ['#ff2222','#ff8800','#ffff00','#44ff44','#44ffff','#4488ff','#8844ff','#ff44ff','#ff4488','#ffffff'][bossRushIdx % 10],
    fireRate: Math.max(10, 25 - bossNum), fireTimer: 0, shootRange: 500,
    active: true, facing: -1,
    isBoss: true, etype: 'boss',
    patrolStart: (cols - 14) * TILE, patrolEnd: (cols - 3) * TILE,
    dir: -1, phase: 0, phaseTimer: 0, vy: 0, onGround: false,
  });
}

function onBossRushBossKill() {
  if (gameMode !== 'bossrush') return;
  bossRushIdx++;
  if (bossRushIdx >= 10) {
    // All 10 bosses defeated!
    const timeS = bossRushTimer / 60;
    saveModeLeaderboardEntry('bossrush', {
      time: timeS, score, kills: runStats.kills,
      date: Date.now(), difficulty: currentDifficulty, isLatest: true
    });
    if (timeS < 300 && !challengeProgress['boss_rush_5m']) {
      challengeProgress['boss_rush_5m'] = true; saveChallengeProgress();
    }
    try {
      const best = bossRushBestTimes;
      best.push(timeS);
      best.sort((a,b) => a - b);
      while (best.length > 10) best.pop();
      localStorage.setItem('contraForce_bossRushTimes', JSON.stringify(best));
    } catch(e) {}
    gameState = 'victory';
    const mins = Math.floor(timeS / 60);
    const secs = Math.floor(timeS % 60);
    showOverlay('BOSS RUSH COMPLETE!', `TIME: ${mins}:${String(secs).padStart(2,'0')}  |  SCORE: ${score}`, 'PRESS ENTER TO PLAY AGAIN');
  } else {
    // Next boss
    spawnPopup(player.x + player.w/2, player.y - 30, 'BOSS ' + (bossRushIdx + 1) + '/10', '#ff8844', 14);
    playSound('stage_clear');
    triggerFlash('#ff8844', 0.3);
    player.invincible = 90;
    setTimeout(() => { if (gameMode === 'bossrush' && gameState === 'playing') spawnBossRushBoss(); }, 1500);
  }
}

// ============================================================
//  TIME ATTACK MODE
// ============================================================
function initTimeAttack() {
  timeAttackTimer = 0;
}

function updateTimeAttack() {
  if (gameMode === 'timeattack' && gameState === 'playing') {
    timeAttackTimer++;
  }
}

function onTimeAttackStageClear(stageNum) {
  if (gameMode !== 'timeattack') return;
  const timeS = timeAttackTimer / 60;
  const key = 'stage_' + stageNum;
  if (!timeAttackBests[key] || timeS < timeAttackBests[key]) {
    timeAttackBests[key] = timeS;
    try { localStorage.setItem('contraForce_timeAttackBests', JSON.stringify(timeAttackBests)); } catch(e) {}
  }
  saveModeLeaderboardEntry('timeattack', {
    stage: stageNum, time: timeS, score, kills: runStats.kills,
    date: Date.now(), difficulty: currentDifficulty, isLatest: true
  });
  // Check speed demon challenge
  if (timeS < 45 && !challengeProgress['speed_demon']) {
    challengeProgress['speed_demon'] = true; saveChallengeProgress();
  }
}

// ============================================================
//  NEW GAME+ MODE
// ============================================================
function canStartNGPlus() {
  // Must have beaten the campaign at least once
  const lb = getLeaderboard();
  return lb.some(e => e.outcome === 'victory') || ngPlusLevel > 0;
}

function initNGPlus() {
  ngPlusLevel++;
  stage = 1;
  score = 0;
  // Difficulty multipliers scale with NG+ level
  const mult = 1 + ngPlusLevel * 0.3;
  diffSettings.enemyHpMult *= mult;
  diffSettings.enemySpawnMult = Math.min(3, diffSettings.enemySpawnMult * (1 + ngPlusLevel * 0.15));
  diffSettings.bossHpMult *= mult;
  diffSettings.enemyFireRateMult = Math.max(0.3, diffSettings.enemyFireRateMult * (1 - ngPlusLevel * 0.05));
  diffSettings.scoreMult *= (1 + ngPlusLevel * 0.2);
}

// ============================================================
//  CHALLENGE MISSIONS
// ============================================================
function showChallengeSelect() {
  let modal = document.getElementById('challengeModal');
  if (!modal) {
    modal = document.createElement('div');
    modal.id = 'challengeModal';
    modal.className = 'challenge-modal';
    document.getElementById('overlay').appendChild(modal);
  }
  const items = CHALLENGES.map(ch => {
    const done = challengeProgress[ch.id];
    return `<div class="challenge-item${done ? ' completed' : ''}" onclick="pickChallenge('${ch.id}')">
      <span class="ch-icon">${ch.icon}</span>
      <span class="ch-info">
        <span class="ch-name">${ch.name}</span>
        <span class="ch-desc">${ch.desc}</span>
      </span>
      <span class="ch-status">${done ? '‚úÖ' : activeChallenge === ch.id ? '‚ñ∂Ô∏è' : ''}</span>
    </div>`;
  }).join('');
  modal.innerHTML = `<div style="font-size:10px;color:#ff8800;margin-bottom:8px;text-align:center;">SELECT CHALLENGE</div>${items}
    <div style="text-align:center;margin-top:8px;">
      <button onclick="hideChallengeSelect()" style="padding:4px 12px;font-family:'Press Start 2P',monospace;font-size:6px;background:#333;color:#aaa;border:1px solid #666;border-radius:3px;cursor:pointer;">CLOSE</button>
    </div>`;
  modal.classList.add('open');
}

function hideChallengeSelect() {
  const modal = document.getElementById('challengeModal');
  if (modal) modal.classList.remove('open');
}

function pickChallenge(id) {
  activeChallenge = id;
  hideChallengeSelect();
  const ch = CHALLENGES.find(c => c.id === id);
  const d1 = document.getElementById('modeDesc');
  const d2 = document.getElementById('modeDescOverlay');
  const txt = ch ? 'Challenge: ' + ch.name : '';
  if (d1) d1.textContent = txt;
  if (d2) d2.textContent = txt;
}

function initChallengeRun() {
  challengeState = {
    damageTaken: 0,
    kills: 0,
    weaponsUsed: new Set(['NORMAL']),
    bossHitsTaken: 0,
    stagesNoDeath: 0,
    currentStageDeaths: 0,
    consecutiveNoDeath: 0,
  };
}

function checkChallengeCompletion() {
  if (gameMode !== 'challenge' || !activeChallenge) return;
  const ch = activeChallenge;
  let completed = false;

  switch (ch) {
    case 'no_hit_boss':
      // Checked when boss dies ‚Äî see boss kill handler
      break;
    case 'pistol_only':
      if (stage >= 2 && challengeState.weaponsUsed.size === 1 && challengeState.weaponsUsed.has('NORMAL')) {
        completed = true;
      }
      break;
    case 'pacifist':
      // Checked when reaching boss area
      break;
    case 'speed_demon':
      // Checked in onTimeAttackStageClear equivalent
      break;
    case 'combo_king':
      if (runStats.maxCombo >= 20) completed = true;
      break;
    case 'no_death_3':
      if (challengeState.consecutiveNoDeath >= 3) completed = true;
      break;
    case 'all_weapons':
      if (runStats.weaponsCollected.size >= 10) completed = true;
      break;
    default: break;
  }

  if (completed && !challengeProgress[ch]) {
    challengeProgress[ch] = true;
    saveChallengeProgress();
    spawnPopup(player.x + player.w/2, player.y - 40, 'CHALLENGE COMPLETE!', '#ff8800', 16);
    playSound('powerup');
    triggerFlash('#ff8800', 0.4);
  }
}

// ============================================================
//  STORY MODE & CUTSCENE ENGINE
// ============================================================

let storyMode = localStorage.getItem('contraForce_storyMode') !== '0'; // on by default
let csActive = false;
let csCallback = null;

// --- STORY DATA ---
// Each entry: array of scenes. Each scene: { speaker, portrait, text, bg, shake?, flash? }
// portrait: emoji-style char code drawn procedurally  bg: gradient stops or color
const STORY = {
  prologue: [
    { speaker: 'COMMAND', portrait: 'üì°', bg: '#0a0a1e',
      text: 'YEAR 2637. An alien signal has been detected from deep space. Hostile forces have invaded Earth, establishing forward bases across the globe.' },
    { speaker: 'COMMAND', portrait: 'üì°', bg: '#0a0a1e',
      text: 'All conventional military forces have been overwhelmed. Our last hope rests with two elite commandos from the Special Forces unit CONTRA.' },
    { speaker: 'LANCE', portrait: 'üî¥', bg: '#1a0a0a',
      text: 'Lance here. Armed and ready. Whatever those alien scum throw at us, we\'ll throw it right back.' },
    { speaker: 'BILL', portrait: 'üîµ', bg: '#0a0a1a',
      text: 'Bill reporting in. Intel says the first base is hidden deep in the jungle. Let\'s move out and take them down.' },
    { speaker: 'COMMAND', portrait: 'üì°', bg: '#0a0a1e',
      text: 'Godspeed, soldiers. The fate of humanity rests in your hands. Engage!' },
  ],

  stage1: [
    { speaker: 'BILL', portrait: 'üîµ', bg: '#0a1a0a',
      text: 'This jungle is crawling with enemy patrols. Stay sharp ‚Äî the outer defense perimeter should be just ahead.' },
    { speaker: 'LANCE', portrait: 'üî¥', bg: '#1a1a0a',
      text: 'I see gun turrets in the canopy. They\'ve fortified this whole region. Let\'s clear a path.' },
  ],
  stage2: [
    { speaker: 'COMMAND', portrait: 'üì°', bg: '#1a0a0a',
      text: 'Good work in the jungle. Satellite imagery shows ancient ruins ahead ‚Äî the enemy has converted them into a forward base.' },
    { speaker: 'LANCE', portrait: 'üî¥', bg: '#2e1a0a',
      text: 'Ruins? Perfect cover for an ambush. I\'ll keep my spread gun ready.' },
  ],
  stage3: [
    { speaker: 'BILL', portrait: 'üîµ', bg: '#041428',
      text: 'The next target is an underwater base. They\'re manufacturing weapons deep beneath the surface.' },
    { speaker: 'LANCE', portrait: 'üî¥', bg: '#0a2040',
      text: 'Underwater combat... great. At least we\'ve got waterproof ammo. Let\'s flood their plans.' },
  ],
  stage4: [
    { speaker: 'COMMAND', portrait: 'üì°', bg: '#02020a',
      text: 'We\'ve traced their communications to an orbital space station. A shuttle is standing by for launch.' },
    { speaker: 'BILL', portrait: 'üîµ', bg: '#06061a',
      text: 'Zero gravity, zero mercy. Those aliens picked the wrong planet to invade.' },
  ],
  stage5: [
    { speaker: 'COMMAND', portrait: 'üì°', bg: '#cc8844',
      text: 'The space station\'s data cores reveal a desert supply depot ‚Äî their main weapons cache on Earth.' },
    { speaker: 'LANCE', portrait: 'üî¥', bg: '#aa5522',
      text: 'A desert fortress? The heat\'ll be brutal, but we\'ve survived worse. Moving out.' },
  ],
  stage6: [
    { speaker: 'BILL', portrait: 'üîµ', bg: '#667799',
      text: 'Intel suggests a research facility hidden in the arctic mountains. They\'re developing a superweapon.' },
    { speaker: 'LANCE', portrait: 'üî¥', bg: '#445566',
      text: 'Snow fortress... frostbite and bullets. My favorite combination. Let\'s shut it down.' },
  ],
  stage7: [
    { speaker: 'COMMAND', portrait: 'üì°', bg: '#1a0a2e',
      text: 'This is it ‚Äî the enemy\'s main stronghold on Earth. All remaining forces are dug in here.' },
    { speaker: 'BILL', portrait: 'üîµ', bg: '#2e1a4e',
      text: 'The final assault. Everything we\'ve fought for leads to this moment. No retreat.' },
    { speaker: 'LANCE', portrait: 'üî¥', bg: '#4a1a2e',
      text: 'Let\'s finish this. For Earth. For everyone who\'s counting on us!' },
  ],
  stage8: [
    { speaker: 'COMMAND', portrait: 'üì°', bg: '#2e0a00',
      text: 'Incredible ‚Äî sensors detect a hidden passage beneath the fortress, leading to a volcanic cavern. The aliens have a base underground!' },
    { speaker: 'LANCE', portrait: 'üî¥', bg: '#5e1a00',
      text: 'A volcano? They really don\'t want us finding this place. That means we\'re on the right track.' },
  ],
  stage9: [
    { speaker: 'BILL', portrait: 'üîµ', bg: '#001a3e',
      text: 'We\'ve broken into their cybernetic core. This is their command and control center ‚Äî pure alien technology.' },
    { speaker: 'COMMAND', portrait: 'üì°', bg: '#000a1e',
      text: 'Be careful! The defenses here are fully automated. Their AI controls everything.' },
  ],
  stage10: [
    { speaker: 'COMMAND', portrait: 'üì°', bg: '#1a0040',
      text: 'You\'ve reached the heart of the invasion ‚Äî the Alien Hive. Their queen controls the entire army from here.' },
    { speaker: 'BILL', portrait: 'üîµ', bg: '#0a001e',
      text: 'I can feel the walls... pulsing. This whole place is alive.' },
    { speaker: 'LANCE', portrait: 'üî¥', bg: '#2a0060',
      text: 'One last fight. We take down the queen, and this war is over. Let\'s make it count!' },
  ],

  epilogue: [
    { speaker: '', portrait: '', bg: '#000000',
      text: 'The Alien Queen falls. The hive shudders and begins to collapse around them.' },
    { speaker: 'LANCE', portrait: 'üî¥', bg: '#1a0a0a', shake: true,
      text: 'The whole place is coming down! We need to get out ‚Äî NOW!' },
    { speaker: 'BILL', portrait: 'üîµ', bg: '#0a0a1a',
      text: 'I see daylight ahead! GO GO GO!' },
    { speaker: '', portrait: '', bg: '#ffffff', flash: true,
      text: 'A blinding flash erupts as the alien hive implodes. Silence follows.' },
    { speaker: 'COMMAND', portrait: 'üì°', bg: '#0a0a1e',
      text: 'We\'re reading your transponders... You made it! Both of you! The alien signatures are gone ‚Äî it\'s over!' },
    { speaker: 'BILL', portrait: 'üîµ', bg: '#0a1a0a',
      text: 'We did it, Lance. Earth is safe.' },
    { speaker: 'LANCE', portrait: 'üî¥', bg: '#1a0a0a',
      text: 'Until the next invasion. But for now... let\'s enjoy the sunrise.' },
    { speaker: '', portrait: '', bg: '#1a1a3e',
      text: 'THE END. Thank you for playing CONTRA FORCE. The world is safe ‚Äî because of you.' },
  ],
};

// --- CUTSCENE RENDERER ---
// Draws directly on the game canvas ‚Äî no extra canvas needed
function playCutscene(key, callback) {
  const scenes = STORY[key];
  if (!scenes || scenes.length === 0) { if (callback) callback(); return; }

  csActive = true;
  csCallback = callback;
  let sceneIdx = 0;
  let charIdx = 0;
  let typeTimer = 0;
  const TYPE_SPEED = 2; // frames per character
  let waitingForInput = false;
  let skipAll = false;

  const csOverlay = document.getElementById('cutsceneOverlay');
  csOverlay.classList.add('active');

  // Advance to next scene or finish
  function advance() {
    if (skipAll) { finish(); return; }
    if (!waitingForInput) {
      // Show all text immediately
      charIdx = scenes[sceneIdx].text.length;
      waitingForInput = true;
      return;
    }
    sceneIdx++;
    if (sceneIdx >= scenes.length) { finish(); return; }
    charIdx = 0;
    typeTimer = 0;
    waitingForInput = false;
  }

  function skip() {
    skipAll = true;
    finish();
  }

  function finish() {
    csActive = false;
    csOverlay.classList.remove('active');
    // Remove listeners
    csOverlay.removeEventListener('click', onCsClick);
    document.removeEventListener('keydown', onCsKey);
    if (csCallback) { const cb = csCallback; csCallback = null; cb(); }
  }

  function onCsClick(e) { e.stopPropagation(); advance(); }
  function onCsKey(e) {
    if (e.code === 'Escape') { e.preventDefault(); skip(); return; }
    if (e.code === 'Enter' || e.code === 'Space') { e.preventDefault(); advance(); }
  }

  csOverlay.addEventListener('click', onCsClick);
  document.addEventListener('keydown', onCsKey);

  // Render loop
  function renderCutscene() {
    if (!csActive) return;

    const scene = scenes[sceneIdx];
    const W = canvas.width, H = canvas.height;

    // Background
    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0);

    // Gradient or solid bg
    if (scene.bg) {
      const grad = ctx.createLinearGradient(0, 0, 0, H);
      grad.addColorStop(0, scene.bg);
      grad.addColorStop(1, '#000000');
      ctx.fillStyle = grad;
    } else {
      ctx.fillStyle = '#000';
    }
    ctx.fillRect(0, 0, W, H);

    // Optional flash
    if (scene.flash && charIdx > 10) {
      ctx.fillStyle = `rgba(255,255,255,${Math.max(0, 0.3 - charIdx * 0.005)})`;
      ctx.fillRect(0, 0, W, H);
    }

    // Subtle particle/star field
    const time = Date.now() * 0.001;
    ctx.fillStyle = 'rgba(255,255,255,0.15)';
    for (let i = 0; i < 40; i++) {
      const sx = ((Math.sin(i * 127.1 + time * 0.3) + 1) * 0.5) * W;
      const sy = ((Math.cos(i * 311.7 + time * 0.2) + 1) * 0.5) * H * 0.55;
      const sr = 0.5 + Math.sin(i * 73.3 + time) * 0.3;
      ctx.fillRect(sx, sy, sr, sr);
    }

    // Portrait (large emoji area left side)
    if (scene.portrait) {
      // Portrait background circle
      const px = 100, py = H * 0.38;
      ctx.beginPath();
      ctx.arc(px, py, 44, 0, Math.PI * 2);
      const pColor = scene.portrait === 'üî¥' ? '#ff4444' : scene.portrait === 'üîµ' ? '#4488ff' : '#44ddff';
      ctx.fillStyle = pColor + '22';
      ctx.fill();
      ctx.strokeStyle = pColor + '88';
      ctx.lineWidth = 2;
      ctx.stroke();

      // Draw a simple character icon
      ctx.font = '36px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = '#fff';
      ctx.fillText(scene.portrait, px, py);

      // Speaker name label
      if (scene.speaker) {
        ctx.font = "bold 11px 'Press Start 2P', monospace";
        ctx.fillStyle = pColor;
        ctx.textAlign = 'center';
        ctx.fillText(scene.speaker, px, py + 56);
      }
    }

    // Text box area (bottom portion)
    const boxY = H * 0.62;
    const boxH = H * 0.34;
    const boxX = 30;
    const boxW = W - 60;

    // Text box background
    ctx.fillStyle = 'rgba(0,0,0,0.75)';
    ctx.strokeStyle = 'rgba(68,221,255,0.4)';
    ctx.lineWidth = 1;
    const r = 8;
    ctx.beginPath();
    ctx.moveTo(boxX + r, boxY);
    ctx.lineTo(boxX + boxW - r, boxY);
    ctx.arcTo(boxX + boxW, boxY, boxX + boxW, boxY + r, r);
    ctx.lineTo(boxX + boxW, boxY + boxH - r);
    ctx.arcTo(boxX + boxW, boxY + boxH, boxX + boxW - r, boxY + boxH, r);
    ctx.lineTo(boxX + r, boxY + boxH);
    ctx.arcTo(boxX, boxY + boxH, boxX, boxY + boxH - r, r);
    ctx.lineTo(boxX, boxY + r);
    ctx.arcTo(boxX, boxY, boxX + r, boxY, r);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    // Speaker name in box
    if (scene.speaker) {
      ctx.font = "9px 'Press Start 2P', monospace";
      const nameColor = scene.portrait === 'üî¥' ? '#ff6666' : scene.portrait === 'üîµ' ? '#6688ff' : '#44ddff';
      ctx.fillStyle = nameColor;
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';
      ctx.fillText(scene.speaker, boxX + 14, boxY + 10);
    }

    // Typewriter text
    if (!waitingForInput) {
      typeTimer++;
      if (typeTimer >= TYPE_SPEED) {
        typeTimer = 0;
        if (charIdx < scene.text.length) charIdx++;
        else waitingForInput = true;
      }
    }

    const displayText = scene.text.substring(0, charIdx);
    ctx.font = "9px 'Press Start 2P', monospace";
    ctx.fillStyle = '#ddd';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'top';

    // Word-wrap text
    const maxLineW = boxW - 28;
    const lineH = 16;
    const words = displayText.split(' ');
    let line = '';
    let ly = boxY + (scene.speaker ? 28 : 14);
    for (let w = 0; w < words.length; w++) {
      const test = line + (line ? ' ' : '') + words[w];
      if (ctx.measureText(test).width > maxLineW && line) {
        ctx.fillText(line, boxX + 14, ly);
        ly += lineH;
        line = words[w];
      } else {
        line = test;
      }
    }
    if (line) ctx.fillText(line, boxX + 14, ly);

    // Blinking advance indicator
    if (waitingForInput) {
      const blink = Math.sin(Date.now() * 0.005) > 0;
      if (blink) {
        ctx.fillStyle = '#44ddff';
        ctx.font = "8px 'Press Start 2P', monospace";
        ctx.textAlign = 'right';
        ctx.fillText('‚ñº', boxX + boxW - 12, boxY + boxH - 12);
      }
    }

    // Scene counter
    ctx.font = "7px 'Press Start 2P', monospace";
    ctx.fillStyle = 'rgba(255,255,255,0.2)';
    ctx.textAlign = 'left';
    ctx.fillText(`${sceneIdx + 1}/${scenes.length}`, 10, H - 10);

    // Optional screen shake
    if (scene.shake && charIdx > 0 && charIdx < scene.text.length) {
      // Already rendered, just a visual note ‚Äî actual shake by offset would require more complex transforms
    }

    ctx.restore();
    requestAnimationFrame(renderCutscene);
  }

  renderCutscene();
}

// Get the cutscene key for a stage intro
function getCutsceneKey(stageNum) {
  return 'stage' + stageNum;
}

// ============================================================
//  ACHIEVEMENT & LEADERBOARD SYSTEM
// ============================================================

// --- Run Stats (reset each game session) ---
let runStats = {
  kills: 0,
  bossKills: 0,
  deaths: 0,
  weaponsCollected: new Set(),
  treasuresFound: 0,
  maxCombo: 0,
  combo: 0,
  comboTimer: 0,
  shotsFired: 0,
  grappleUses: 0,
  noDeathRun: true,
  stagesCleared: 0,
  startTime: Date.now(),
  damageDealt: 0,
  stageDeaths: 0,
};

function resetRunStats() {
  runStats = {
    kills: 0,
    bossKills: 0,
    deaths: 0,
    weaponsCollected: new Set(),
    treasuresFound: 0,
    maxCombo: 0,
    combo: 0,
    comboTimer: 0,
    shotsFired: 0,
    grappleUses: 0,
    noDeathRun: true,
    stagesCleared: 0,
    startTime: Date.now(),
    damageDealt: 0,
    stageDeaths: 0,
  };
}

// --- Achievement Definitions ---
const ACHIEVEMENTS = [
  // Combat
  { id: 'first_blood',     name: 'First Blood',        icon: 'üî´', desc: 'Kill your first enemy',                   check: () => runStats.kills >= 1 },
  { id: 'killing_spree',   name: 'Killing Spree',      icon: 'üíÄ', desc: 'Kill 25 enemies in one run',              check: () => runStats.kills >= 25 },
  { id: 'massacre',         name: 'Massacre',            icon: '‚ò†Ô∏è', desc: 'Kill 100 enemies in one run',             check: () => runStats.kills >= 100 },
  { id: 'genocide',         name: 'One-Man Army',        icon: 'ü™ñ', desc: 'Kill 250 enemies in one run',             check: () => runStats.kills >= 250 },
  { id: 'combo5',           name: 'Combo Starter',       icon: 'üî•', desc: 'Get a 5-kill combo',                      check: () => runStats.maxCombo >= 5 },
  { id: 'combo15',          name: 'Combo King',          icon: 'üëë', desc: 'Get a 15-kill combo',                     check: () => runStats.maxCombo >= 15 },

  // Boss
  { id: 'boss_slayer',      name: 'Boss Slayer',         icon: 'üêâ', desc: 'Defeat a boss',                           check: () => runStats.bossKills >= 1 },
  { id: 'boss_master',      name: 'Boss Master',         icon: '‚öîÔ∏è', desc: 'Defeat 3 bosses in one run',             check: () => runStats.bossKills >= 3 },

  // Progression
  { id: 'stage2',           name: 'Moving On',           icon: 'üöÄ', desc: 'Reach Stage 2',                           check: () => runStats.stagesCleared >= 1 },
  { id: 'stage4',           name: 'Halfway There',       icon: 'üèîÔ∏è', desc: 'Reach Stage 4',                           check: () => runStats.stagesCleared >= 3 },
  { id: 'victory',          name: 'Contra Force',        icon: 'üèÜ', desc: 'Complete all 7 stages',                   check: () => runStats.stagesCleared >= 7 },

  // Weapons
  { id: 'arms_dealer',      name: 'Arms Dealer',         icon: 'üéØ', desc: 'Collect 3 different weapons in one run',  check: () => runStats.weaponsCollected.size >= 3 },
  { id: 'arsenal',          name: 'Full Arsenal',        icon: 'üíé', desc: 'Collect all 7 weapon types in one run',   check: () => runStats.weaponsCollected.size >= 7 },

  // Exploration
  { id: 'treasure_hunter',  name: 'Treasure Hunter',     icon: 'üí∞', desc: 'Find 10 treasures in one run',            check: () => runStats.treasuresFound >= 10 },
  { id: 'treasure_master',  name: 'Treasure Master',     icon: 'üë∏', desc: 'Find 30 treasures in one run',            check: () => runStats.treasuresFound >= 30 },

  // Skill
  { id: 'untouchable',      name: 'Untouchable',         icon: '‚ú®', desc: 'Clear a stage without dying',             check: () => false },
  { id: 'flawless',         name: 'Flawless Victory',    icon: 'üåü', desc: 'Complete the game without dying',         check: () => false },
  { id: 'grapple_master',   name: 'Grapple Master',      icon: 'ü™ù', desc: 'Use the grapple hook 20 times in one run', check: () => runStats.grappleUses >= 20 },

  // Score
  { id: 'score10k',         name: 'Getting Rich',        icon: 'üíµ', desc: 'Score 10,000 points',                     check: () => score >= 10000 },
  { id: 'score50k',         name: 'High Roller',         icon: 'üí∏', desc: 'Score 50,000 points',                     check: () => score >= 50000 },
  { id: 'score100k',        name: 'Score Legend',         icon: 'ü§ë', desc: 'Score 100,000 points',                    check: () => score >= 100000 },

  // Speed
  { id: 'speedrun3',        name: 'Speed Demon',         icon: '‚ö°', desc: 'Clear a stage in under 60 seconds',       check: () => false },
];

// --- Achievement State (persisted in localStorage) ---
let achievements = {};

function loadAchievements() {
  try {
    const data = localStorage.getItem('contraForce_achievements');
    if (data) achievements = JSON.parse(data);
  } catch(e) { achievements = {}; }
}

function saveAchievements() {
  try { localStorage.setItem('contraForce_achievements', JSON.stringify(achievements)); } catch(e) {}
}

function unlockAchievement(id) {
  if (achievements[id]) return;
  const def = ACHIEVEMENTS.find(a => a.id === id);
  if (!def) return;
  achievements[id] = { unlocked: true, time: Date.now() };
  saveAchievements();
  showAchievementToast(def);
  updateAchHud();
  playSound('powerup');
}

function checkAchievements() {
  for (const ach of ACHIEVEMENTS) {
    if (achievements[ach.id]) continue;
    if (ach.check()) unlockAchievement(ach.id);
  }
}

// --- Achievement Toast ---
let toastQueue = [];
let toastShowing = false;

function showAchievementToast(def) {
  toastQueue.push(def);
  if (!toastShowing) processToastQueue();
}

function processToastQueue() {
  if (toastQueue.length === 0) { toastShowing = false; return; }
  toastShowing = true;
  const def = toastQueue.shift();
  const toast = document.getElementById('achievementToast');
  document.getElementById('toastIcon').textContent = def.icon;
  document.getElementById('toastName').textContent = def.name;
  document.getElementById('toastDesc').textContent = def.desc;
  toast.classList.add('show');
  setTimeout(() => {
    toast.classList.remove('show');
    setTimeout(() => processToastQueue(), 400);
  }, 3000);
}

// --- Achievement Panel ---
function toggleAchievementsPanel() {
  const panel = document.getElementById('achievementsPanel');
  panel.classList.toggle('open');
  if (panel.classList.contains('open')) {
    renderAchievementsGrid();
    document.getElementById('leaderboardPanel').classList.remove('open');
  }
}

function renderAchievementsGrid() {
  const grid = document.getElementById('achGrid');
  const unlocked = ACHIEVEMENTS.filter(a => achievements[a.id]);
  document.getElementById('achCount').textContent = `${unlocked.length} / ${ACHIEVEMENTS.length} unlocked`;
  
  grid.innerHTML = ACHIEVEMENTS.map(ach => {
    const u = achievements[ach.id];
    const cls = u ? 'unlocked' : 'locked';
    const timeStr = u ? new Date(u.time).toLocaleDateString() : '';
    let progressHtml = '';
    if (!u) {
      const progressMap = {
        'killing_spree': [runStats.kills, 25],
        'massacre': [runStats.kills, 100],
        'genocide': [runStats.kills, 250],
        'combo5': [runStats.maxCombo, 5],
        'combo15': [runStats.maxCombo, 15],
        'treasure_hunter': [runStats.treasuresFound, 10],
        'treasure_master': [runStats.treasuresFound, 30],
        'score10k': [score, 10000],
        'score50k': [score, 50000],
        'score100k': [score, 100000],
        'arms_dealer': [runStats.weaponsCollected.size, 3],
        'arsenal': [runStats.weaponsCollected.size, 7],
        'grapple_master': [runStats.grappleUses, 20],
        'boss_master': [runStats.bossKills, 3],
        'stage4': [runStats.stagesCleared, 3],
      };
      if (progressMap[ach.id]) {
        const [cur, max] = progressMap[ach.id];
        progressHtml = makeProgressBar(cur, max);
      }
    }
    return `<div class="ach-card ${cls}">
      <span class="ach-icon">${ach.icon}</span>
      <div class="ach-info">
        <span class="ach-name">${u ? ach.name : '???'}</span>
        <span class="ach-desc">${ach.desc}</span>
        ${u ? `<span class="ach-time">Unlocked ${timeStr}</span>` : ''}
        ${progressHtml}
      </div>
    </div>`;
  }).join('');
}

function makeProgressBar(current, max) {
  const pct = Math.min(100, Math.floor((current / max) * 100));
  return `<div class="ach-progress-bar"><div class="ach-progress-fill" style="width:${pct}%"></div></div>`;
}

function updateAchHud() {
  const unlocked = ACHIEVEMENTS.filter(a => achievements[a.id]).length;
  const btn = document.getElementById('achHudBtn');
  if (btn) btn.textContent = `üèÜ ${unlocked}/${ACHIEVEMENTS.length}`;
}

// --- Leaderboard ---
function getLeaderboard() {
  try {
    const data = localStorage.getItem('contraForce_leaderboard');
    return data ? JSON.parse(data) : [];
  } catch(e) { return []; }
}

function saveLeaderboardEntry(entry) {
  const lb = getLeaderboard();
  lb.push(entry);
  lb.sort((a, b) => b.score - a.score);
  while (lb.length > 20) lb.pop();
  try { localStorage.setItem('contraForce_leaderboard', JSON.stringify(lb)); } catch(e) {}
}

function clearLeaderboard() {
  if (!confirm('Clear all leaderboard scores?')) return;
  try { localStorage.removeItem('contraForce_leaderboard'); } catch(e) {}
  renderLeaderboard();
}

function toggleLeaderboardPanel() {
  const panel = document.getElementById('leaderboardPanel');
  panel.classList.toggle('open');
  if (panel.classList.contains('open')) {
    renderLeaderboard();
    document.getElementById('achievementsPanel').classList.remove('open');
  }
}

function renderLeaderboard() {
  const lb = getLeaderboard();
  const container = document.getElementById('lbContent');
  
  if (lb.length === 0) {
    container.innerHTML = '<div class="lb-empty">No scores yet. Play a game!</div>';
    return;
  }
  
  const rankIcons = ['ü•á', 'ü•à', 'ü•â'];
  const rankClasses = ['lb-rank-gold', 'lb-rank-silver', 'lb-rank-bronze'];
  
  container.innerHTML = `<table class="lb-table">
    <thead><tr>
      <th class="lb-rank">#</th>
      <th>SCORE</th>
      <th>STAGE</th>
      <th>DIFF</th>
      <th>KILLS</th>
      <th>TIME</th>
      <th>DATE</th>
    </tr></thead>
    <tbody>${lb.map((e, i) => {
      const rank = i < 3 ? `<span class="${rankClasses[i]}">${rankIcons[i]}</span>` : (i + 1);
      const mins = Math.floor((e.duration || 0) / 60);
      const secs = Math.floor((e.duration || 0) % 60);
      const timeStr = `${mins}:${String(secs).padStart(2, '0')}`;
      const dateStr = e.date ? new Date(e.date).toLocaleDateString() : '-';
      const highlight = e.isLatest ? ' highlight' : '';
      const diffLabel = e.difficulty ? (DIFFICULTY_PRESETS[e.difficulty] ? DIFFICULTY_PRESETS[e.difficulty].label : e.difficulty.toUpperCase()) : '-';
      const diffColor = e.difficulty && DIFFICULTY_PRESETS[e.difficulty] ? DIFFICULTY_PRESETS[e.difficulty].color : '#aaa';
      return `<tr class="${highlight}">
        <td class="lb-rank">${rank}</td>
        <td>${(e.score || 0).toLocaleString()}</td>
        <td>${e.stage || '?'}</td>
        <td style="color:${diffColor}; font-size:7px;">${diffLabel}</td>
        <td>${e.kills || 0}</td>
        <td>${timeStr}</td>
        <td>${dateStr}</td>
      </tr>`;
    }).join('')}</tbody>
  </table>`;
}

function submitScore(outcome) {
  const lb = getLeaderboard();
  lb.forEach(e => delete e.isLatest);
  try { localStorage.setItem('contraForce_leaderboard', JSON.stringify(lb)); } catch(e) {}
  
  const duration = (Date.now() - runStats.startTime) / 1000;
  saveLeaderboardEntry({
    score,
    stage,
    kills: runStats.kills,
    duration,
    date: Date.now(),
    outcome,
    difficulty: currentDifficulty,
    isLatest: true,
  });
}

// --- Combo System ---
function registerKill() {
  runStats.kills++;
  // Track total kills for PYRO unlock
  const tk = parseInt(localStorage.getItem('contraForce_totalKills') || '0') + 1;
  try { localStorage.setItem('contraForce_totalKills', String(tk)); } catch(e) {}
  runStats.combo++;
  runStats.comboTimer = 90;
  if (runStats.combo > runStats.maxCombo) runStats.maxCombo = runStats.combo;
  
  if (runStats.combo >= 3 && gameState === 'playing') {
    const cx = player.x + player.w / 2;
    const cy = player.y - 10;
    const comboColor = runStats.combo >= 10 ? '#ff44ff' : runStats.combo >= 5 ? '#ff8844' : '#ffcc44';
    spawnPopup(cx, cy, `${runStats.combo}x COMBO!`, comboColor, runStats.combo >= 10 ? 14 : 11);
  }
  
  // Mode hooks
  onEndlessEnemyKill();
  checkAchievements();
}

function updateCombo() {
  if (runStats.comboTimer > 0) {
    runStats.comboTimer--;
    if (runStats.comboTimer <= 0) runStats.combo = 0;
  }
}

// Stage clear time tracking
let stageStartTime = Date.now();

// Load on startup
loadAchievements();

// --- JUICE SYSTEMS ---
// Screen shake
let shakeX = 0, shakeY = 0, shakeIntensity = 0, shakeDuration = 0;
function triggerShake(intensity, duration) {
  shakeIntensity = intensity;
  shakeDuration = duration;
}
function updateShake() {
  if (shakeDuration > 0) {
    shakeX = (Math.random() - 0.5) * 2 * shakeIntensity;
    shakeY = (Math.random() - 0.5) * 2 * shakeIntensity;
    shakeDuration--;
    shakeIntensity *= 0.92;
  } else {
    shakeX = 0; shakeY = 0;
  }
}

// Hit freeze (pause frames for impact)
let freezeFrames = 0;
function triggerFreeze(frames) {
  freezeFrames = Math.max(freezeFrames, frames);
}

// Screen flash
let flashAlpha = 0, flashColor = '#fff';
function triggerFlash(color, alpha) {
  flashColor = color;
  flashAlpha = alpha;
}
function updateFlash() {
  if (flashAlpha > 0) flashAlpha *= 0.85;
  if (flashAlpha < 0.01) flashAlpha = 0;
}

// Floating score/text popups
let popups = [];
function spawnPopup(x, y, text, color, size) {
  popups.push({ x, y, text, color, size: size || 10, life: 60, maxLife: 60, vy: -2.5 });
}
function updatePopups() {
  for (let i = popups.length - 1; i >= 0; i--) {
    const p = popups[i];
    p.y += p.vy;
    p.vy *= 0.96;
    p.life--;
    if (p.life <= 0) popups.splice(i, 1);
  }
}
function drawPopups(camX) {
  for (const p of popups) {
    const alpha = p.life / p.maxLife;
    const scale = 1 + (1 - alpha) * 0.4;
    ctx.globalAlpha = alpha;
    ctx.fillStyle = p.color;
    ctx.font = `${Math.round(p.size * scale)}px "Press Start 2P"`;
    ctx.textAlign = 'center';
    ctx.shadowColor = '#000';
    ctx.shadowBlur = 4;
    ctx.fillText(p.text, p.x - camX, p.y);
    ctx.shadowBlur = 0;
  }
  ctx.globalAlpha = 1;
  ctx.textAlign = 'left';
}

// Slow motion
let slowMo = 0;
let slowMoRate = 0.3;

// ============================================================
//  VISUAL EFFECTS SYSTEMS
// ============================================================

// --- CRT / RETRO SHADER ---
let crtEnabled = false;
let crtScanlines = true;
let crtChromaticAberration = true;
let crtCurvature = true;
let crtScanlineAlpha = 0.12;
let crtAberrationAmount = 1.5;
let crtCurvatureAmount = 0.02;

// Off-screen canvas for CRT post-processing
let crtCanvas = null;
let crtCtx = null;

function initCRTCanvas() {
  if (crtCanvas) return;
  crtCanvas = document.createElement('canvas');
  crtCanvas.width = GAME_W;
  crtCanvas.height = GAME_H;
  crtCtx = crtCanvas.getContext('2d');
}

function applyCRTEffect() {
  if (!crtEnabled) return;
  initCRTCanvas();

  // Copy main canvas to CRT buffer
  crtCtx.clearRect(0, 0, GAME_W, GAME_H);

  // Chromatic aberration ‚Äî offset red and blue channels
  if (crtChromaticAberration && crtAberrationAmount > 0) {
    const ab = crtAberrationAmount;
    // Red channel (shifted left)
    crtCtx.globalCompositeOperation = 'source-over';
    crtCtx.drawImage(canvas, 0, 0);
    // Use globalCompositeOperation to simulate channel separation
    crtCtx.globalCompositeOperation = 'source-over';
    crtCtx.globalAlpha = 0.15;
    crtCtx.drawImage(canvas, -ab, 0);
    crtCtx.globalAlpha = 0.15;
    crtCtx.drawImage(canvas, ab, 0);
    crtCtx.globalAlpha = 1;
  } else {
    crtCtx.drawImage(canvas, 0, 0);
  }

  // Scanlines
  if (crtScanlines) {
    crtCtx.globalCompositeOperation = 'source-over';
    for (let y = 0; y < GAME_H; y += 2) {
      crtCtx.fillStyle = `rgba(0,0,0,${crtScanlineAlpha})`;
      crtCtx.fillRect(0, y, GAME_W, 1);
    }
  }

  // Screen curvature ‚Äî darkened edges
  if (crtCurvature) {
    const grad = crtCtx.createRadialGradient(
      GAME_W / 2, GAME_H / 2, Math.min(GAME_W, GAME_H) * 0.35,
      GAME_W / 2, GAME_H / 2, Math.max(GAME_W, GAME_H) * 0.7
    );
    grad.addColorStop(0, 'rgba(0,0,0,0)');
    grad.addColorStop(0.7, `rgba(0,0,0,${crtCurvatureAmount * 5})`);
    grad.addColorStop(1, `rgba(0,0,0,${Math.min(0.6, crtCurvatureAmount * 15)})`);
    crtCtx.globalCompositeOperation = 'source-over';
    crtCtx.fillStyle = grad;
    crtCtx.fillRect(0, 0, GAME_W, GAME_H);
  }

  // Faint horizontal flicker
  const flicker = Math.sin(Date.now() * 0.1) * 0.01;
  if (flicker > 0) {
    crtCtx.fillStyle = `rgba(255,255,255,${flicker})`;
    crtCtx.fillRect(0, 0, GAME_W, GAME_H);
  }

  // Draw CRT result back to main canvas
  ctx.clearRect(0, 0, GAME_W, GAME_H);
  ctx.drawImage(crtCanvas, 0, 0);
}

// --- WEATHER EFFECTS ---
let weatherEnabled = true;
let weatherParticles = [];
const MAX_WEATHER_PARTICLES = 300;

function getStageWeather(s) {
  const theme = getTheme(s);
  if (theme.snow) return 'snow';
  if (theme.desert) return 'sandstorm';
  if (theme.lava) return 'embers';
  if (theme.water) return 'rain';
  if (theme.alien) return 'spores';
  if (theme.name === 'JUNGLE') return 'rain';
  return null;
}

function updateWeather() {
  if (!weatherEnabled) return;
  const type = getStageWeather(stage);
  if (!type) { weatherParticles = []; return; }

  // Spawn new particles
  const spawnRate = type === 'sandstorm' ? 8 : (type === 'rain' ? 6 : (type === 'snow' ? 3 : 2));
  for (let i = 0; i < spawnRate && weatherParticles.length < MAX_WEATHER_PARTICLES; i++) {
    const wx = Math.random() * viewW();
    const wy = type === 'embers' ? viewH() + 5 : -5;
    switch (type) {
      case 'rain':
        weatherParticles.push({ x: wx, y: wy, vx: -1 + Math.random() * 0.5, vy: 8 + Math.random() * 4, size: 1, len: 6 + Math.random() * 6, life: 120, type });
        break;
      case 'snow':
        weatherParticles.push({ x: wx, y: wy, vx: Math.sin(Date.now() * 0.001 + wx) * 0.5, vy: 0.8 + Math.random() * 1.2, size: 1 + Math.random() * 2.5, life: 300, wobble: Math.random() * Math.PI * 2, type });
        break;
      case 'sandstorm':
        weatherParticles.push({ x: -5, y: Math.random() * viewH(), vx: 4 + Math.random() * 6, vy: -1 + Math.random() * 2, size: 1 + Math.random() * 2, life: 100, type });
        break;
      case 'embers':
        weatherParticles.push({ x: wx, y: wy, vx: Math.random() * 2 - 1, vy: -(1 + Math.random() * 2), size: 1 + Math.random() * 2, life: 150, flicker: Math.random(), type });
        break;
      case 'spores':
        weatherParticles.push({ x: wx, y: wy, vx: Math.sin(Date.now() * 0.002 + wx) * 0.3, vy: 0.3 + Math.random() * 0.6, size: 2 + Math.random() * 3, life: 250, pulse: Math.random() * Math.PI * 2, type });
        break;
    }
  }

  // Update existing
  for (let i = weatherParticles.length - 1; i >= 0; i--) {
    const wp = weatherParticles[i];
    wp.x += wp.vx;
    wp.y += wp.vy;
    wp.life--;
    if (wp.type === 'snow') { wp.wobble += 0.03; wp.x += Math.sin(wp.wobble) * 0.4; }
    if (wp.type === 'spores') { wp.pulse += 0.05; wp.x += Math.sin(wp.pulse) * 0.3; }
    if (wp.life <= 0 || wp.x < -20 || wp.x > viewW() + 20 || wp.y < -20 || wp.y > viewH() + 20) {
      weatherParticles.splice(i, 1);
    }
  }
}

function drawWeather() {
  if (!weatherEnabled || weatherParticles.length === 0) return;
  ctx.save();
  // Weather draws in screen-space (no camera offset)
  for (const wp of weatherParticles) {
    const alpha = Math.min(1, wp.life / 30);
    switch (wp.type) {
      case 'rain':
        ctx.globalAlpha = alpha * 0.5;
        ctx.strokeStyle = '#88bbff';
        ctx.lineWidth = wp.size;
        ctx.beginPath();
        ctx.moveTo(wp.x, wp.y);
        ctx.lineTo(wp.x + wp.vx * 0.8, wp.y + wp.len);
        ctx.stroke();
        break;
      case 'snow':
        ctx.globalAlpha = alpha * 0.7;
        ctx.fillStyle = '#eef8ff';
        ctx.beginPath();
        ctx.arc(wp.x, wp.y, wp.size, 0, Math.PI * 2);
        ctx.fill();
        // Soft glow
        ctx.globalAlpha = alpha * 0.2;
        ctx.beginPath();
        ctx.arc(wp.x, wp.y, wp.size * 2, 0, Math.PI * 2);
        ctx.fill();
        break;
      case 'sandstorm':
        ctx.globalAlpha = alpha * 0.3;
        ctx.fillStyle = '#ccaa66';
        ctx.fillRect(wp.x, wp.y, wp.size * 3, wp.size);
        break;
      case 'embers':
        const emberGlow = 0.5 + Math.sin(Date.now() * 0.01 + wp.flicker * 10) * 0.3;
        ctx.globalAlpha = alpha * emberGlow;
        ctx.fillStyle = Math.random() > 0.3 ? '#ff6622' : '#ffaa44';
        ctx.beginPath();
        ctx.arc(wp.x, wp.y, wp.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = alpha * emberGlow * 0.3;
        ctx.fillStyle = '#ff4400';
        ctx.beginPath();
        ctx.arc(wp.x, wp.y, wp.size * 2.5, 0, Math.PI * 2);
        ctx.fill();
        break;
      case 'spores':
        const sporePulse = 0.4 + Math.sin(wp.pulse) * 0.3;
        ctx.globalAlpha = alpha * sporePulse;
        ctx.fillStyle = '#aa44ff';
        ctx.beginPath();
        ctx.arc(wp.x, wp.y, wp.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = alpha * sporePulse * 0.3;
        ctx.fillStyle = '#cc66ff';
        ctx.beginPath();
        ctx.arc(wp.x, wp.y, wp.size * 2, 0, Math.PI * 2);
        ctx.fill();
        break;
    }
  }
  ctx.globalAlpha = 1;
  ctx.restore();

  // Sandstorm ambient overlay
  if (getStageWeather(stage) === 'sandstorm') {
    ctx.globalAlpha = 0.06 + Math.sin(Date.now() * 0.002) * 0.03;
    ctx.fillStyle = '#ccaa66';
    ctx.fillRect(0, 0, GAME_W, GAME_H);
    ctx.globalAlpha = 1;
  }
}

// --- SCREEN TRANSITIONS ---
let transitionActive = false;
let transitionType = 'fade'; // 'fade', 'wipe', 'circle'
let transitionPhase = 'out'; // 'out' = going black, 'in' = coming from black
let transitionProgress = 0; // 0-1
let transitionSpeed = 0.04;
let transitionCallback = null;

function startTransition(type, callback) {
  transitionActive = true;
  transitionType = type || 'fade';
  transitionPhase = 'out';
  transitionProgress = 0;
  transitionSpeed = 0.04;
  transitionCallback = callback;
}

function updateTransition() {
  if (!transitionActive) return;
  transitionProgress += transitionSpeed;
  if (transitionProgress >= 1) {
    if (transitionPhase === 'out') {
      // Fully black ‚Äî run callback (stage init) then reverse
      transitionPhase = 'in';
      transitionProgress = 0;
      if (transitionCallback) {
        transitionCallback();
        transitionCallback = null;
      }
    } else {
      // Transition complete
      transitionActive = false;
      transitionProgress = 0;
    }
  }
}

function drawTransition() {
  if (!transitionActive) return;
  const t = transitionPhase === 'out' ? transitionProgress : (1 - transitionProgress);

  switch (transitionType) {
    case 'fade':
      ctx.globalAlpha = t;
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, GAME_W, GAME_H);
      ctx.globalAlpha = 1;
      break;
    case 'wipe':
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, GAME_W * t, GAME_H);
      // Bright edge line
      if (t > 0.01 && t < 0.99) {
        ctx.fillStyle = '#ffffff';
        ctx.globalAlpha = 0.6;
        ctx.fillRect(GAME_W * t - 2, 0, 4, GAME_H);
        ctx.globalAlpha = 1;
      }
      break;
    case 'circle': {
      const maxR = Math.sqrt(GAME_W * GAME_W + GAME_H * GAME_H) / 2;
      const r = maxR * (1 - t);
      const cx = GAME_W / 2;
      const cy = GAME_H / 2;
      ctx.fillStyle = '#000';
      ctx.beginPath();
      ctx.rect(0, 0, GAME_W, GAME_H);
      ctx.arc(cx, cy, Math.max(0, r), 0, Math.PI * 2, true);
      ctx.fill();
      break;
    }
  }
}

// Wrap initGame to use transitions
function transitionToStage(callback) {
  const types = ['fade', 'wipe', 'circle'];
  const type = types[Math.floor(Math.random() * types.length)];
  startTransition(type, callback);
}

// --- DYNAMIC LIGHTING ---
let dynamicLightingEnabled = true;
let lightSources = []; // { x, y, radius, color, alpha, life }

function addLight(x, y, radius, color, alpha, life) {
  if (!dynamicLightingEnabled) return;
  lightSources.push({ x, y, radius, color, alpha: alpha || 0.6, life: life || 8, maxLife: life || 8 });
}

function updateLights() {
  for (let i = lightSources.length - 1; i >= 0; i--) {
    lightSources[i].life--;
    if (lightSources[i].life <= 0) lightSources.splice(i, 1);
  }
}

function drawLights(camXOffset) {
  if (!dynamicLightingEnabled || lightSources.length === 0) return;
  for (const l of lightSources) {
    const sx = l.x - camXOffset;
    const sy = l.y;
    const fade = l.life / l.maxLife;
    const r = l.radius * (1 + (1 - fade) * 0.3); // expand slightly as it fades
    const grad = ctx.createRadialGradient(sx, sy, 0, sx, sy, r);
    grad.addColorStop(0, l.color);
    grad.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.globalCompositeOperation = 'lighter';
    ctx.globalAlpha = l.alpha * fade;
    ctx.fillStyle = grad;
    ctx.fillRect(sx - r, sy - r, r * 2, r * 2);
  }
  ctx.globalCompositeOperation = 'source-over';
  ctx.globalAlpha = 1;
}

// --- ANIMATED WATER/LAVA TILES ---
let animatedTilesEnabled = true;
let waterAnimFrame = 0;

function updateAnimatedTiles() {
  waterAnimFrame++;
}

// ============================================================
//  ANIMATED TITLE SCREEN & DEMO MODE
// ============================================================

let titleAnimFrame = 0;
let titleStars = [];
let titleLogoY = 0;
let titleLogoScale = 1;
let titleDemoTimer = 0;
let titleDemoActive = false;
const TITLE_DEMO_DELAY = 600; // 10 seconds at 60fps before demo starts

// Initialize title screen star field
function initTitleStars() {
  titleStars = [];
  for (let i = 0; i < 120; i++) {
    titleStars.push({
      x: Math.random() * GAME_W,
      y: Math.random() * GAME_H,
      speed: 0.2 + Math.random() * 1.5,
      size: 0.5 + Math.random() * 2,
      brightness: 0.3 + Math.random() * 0.7,
      layer: Math.floor(Math.random() * 3), // 0=far, 1=mid, 2=near
    });
  }
}
initTitleStars();

function drawTitleScreen() {
  titleAnimFrame++;

  // Animated background ‚Äî gradient shift
  const hueShift = Math.sin(titleAnimFrame * 0.005) * 10;
  const grad = ctx.createLinearGradient(0, 0, 0, GAME_H);
  grad.addColorStop(0, `hsl(${240 + hueShift}, 60%, 5%)`);
  grad.addColorStop(0.4, `hsl(${260 + hueShift}, 50%, 10%)`);
  grad.addColorStop(0.7, `hsl(${280 + hueShift}, 40%, 8%)`);
  grad.addColorStop(1, `hsl(${250 + hueShift}, 60%, 3%)`);
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, GAME_W, GAME_H);

  // Parallax star layers
  for (const star of titleStars) {
    star.x -= star.speed * (0.3 + star.layer * 0.4);
    if (star.x < -2) star.x = GAME_W + 2;
    const twinkle = star.brightness + Math.sin(titleAnimFrame * 0.08 + star.x) * 0.2;
    ctx.globalAlpha = Math.max(0.1, Math.min(1, twinkle));
    ctx.fillStyle = star.layer === 2 ? '#aaccff' : (star.layer === 1 ? '#8899cc' : '#556688');
    ctx.fillRect(star.x, star.y, star.size, star.size);
  }
  ctx.globalAlpha = 1;

  // Parallax mountains silhouette
  for (let layer = 0; layer < 3; layer++) {
    const layerAlpha = 0.15 + layer * 0.08;
    const layerColor = `rgba(${20 + layer * 15}, ${10 + layer * 8}, ${40 + layer * 10}, ${layerAlpha})`;
    ctx.fillStyle = layerColor;
    ctx.beginPath();
    ctx.moveTo(0, GAME_H);
    const scrollOff = titleAnimFrame * (0.2 + layer * 0.3);
    for (let x = 0; x <= GAME_W; x += 30) {
      const h = 80 + Math.sin((x + scrollOff) * 0.01 + layer) * 50 + Math.sin((x + scrollOff) * 0.025) * 25;
      ctx.lineTo(x, GAME_H - 60 - h + layer * 35);
    }
    ctx.lineTo(GAME_W, GAME_H);
    ctx.fill();
  }

  // Ground strip
  ctx.fillStyle = '#1a1a0a';
  ctx.fillRect(0, GAME_H - 40, GAME_W, 40);
  ctx.fillStyle = '#2a2a1a';
  ctx.fillRect(0, GAME_H - 40, GAME_W, 3);

  // Animated logo ‚Äî floating with glow
  titleLogoY = GAME_H * 0.22 + Math.sin(titleAnimFrame * 0.03) * 8;
  titleLogoScale = 1 + Math.sin(titleAnimFrame * 0.02) * 0.03;

  ctx.save();
  ctx.translate(GAME_W / 2, titleLogoY);
  ctx.scale(titleLogoScale, titleLogoScale);

  // Logo glow
  ctx.shadowColor = '#ff4444';
  ctx.shadowBlur = 20 + Math.sin(titleAnimFrame * 0.05) * 10;
  ctx.font = '32px "Press Start 2P"';
  ctx.textAlign = 'center';
  ctx.fillStyle = '#ff4444';
  ctx.fillText('CONTRA', 0, 0);
  ctx.shadowColor = '#ff8800';
  ctx.shadowBlur = 15 + Math.sin(titleAnimFrame * 0.04) * 8;
  ctx.font = '24px "Press Start 2P"';
  ctx.fillStyle = '#ffcc00';
  ctx.fillText('FORCE', 0, 36);
  ctx.shadowBlur = 0;

  // Subtitle
  ctx.font = '7px "Press Start 2P"';
  ctx.fillStyle = '#888';
  ctx.globalAlpha = 0.5 + Math.sin(titleAnimFrame * 0.04) * 0.3;
  ctx.fillText('A CLASSIC SIDE-SCROLLING SHOOTER', 0, 58);
  ctx.globalAlpha = 1;
  ctx.restore();

  // Animated soldier silhouettes at bottom
  const soldierX1 = (titleAnimFrame * 1.5) % (GAME_W + 60) - 30;
  const soldierX2 = GAME_W - ((titleAnimFrame * 1.2 + 200) % (GAME_W + 60)) + 30;
  drawTitleSoldier(soldierX1, GAME_H - 42, 1);
  drawTitleSoldier(soldierX2, GAME_H - 42, -1);

  // Demo mode notification
  if (!titleDemoActive) {
    titleDemoTimer++;
    if (titleDemoTimer > TITLE_DEMO_DELAY) {
      startDemoMode();
    }
  }

  // "DEMO" indicator when demo is playing
  if (titleDemoActive) {
    ctx.font = '8px "Press Start 2P"';
    ctx.fillStyle = '#ff8844';
    ctx.textAlign = 'center';
    ctx.globalAlpha = 0.5 + Math.sin(titleAnimFrame * 0.08) * 0.3;
    ctx.fillText('‚Äî DEMO ‚Äî', GAME_W / 2, GAME_H - 8);
    ctx.globalAlpha = 1;
    ctx.textAlign = 'left';
  }
}

function drawTitleSoldier(x, y, facing) {
  ctx.save();
  ctx.translate(x, y);
  ctx.scale(facing, 1);
  // Simple soldier silhouette
  ctx.fillStyle = '#445566';
  ctx.globalAlpha = 0.5;
  // Body
  ctx.fillRect(-5, -22, 10, 14);
  // Head
  ctx.fillRect(-4, -28, 8, 6);
  // Legs (animated)
  const legPhase = Math.sin(titleAnimFrame * 0.15 + x * 0.1);
  ctx.fillRect(-5, -8, 4, 8 + legPhase * 2);
  ctx.fillRect(1, -8, 4, 8 - legPhase * 2);
  // Gun
  ctx.fillRect(5, -20, 12, 3);
  ctx.globalAlpha = 1;
  ctx.restore();
}

function drawDemoOverlay() {
  // Floating logo overlay on top of the demo gameplay
  titleAnimFrame++;
  const logoY = 60 + Math.sin(titleAnimFrame * 0.03) * 5;

  ctx.save();
  ctx.textAlign = 'center';

  // Logo with glow
  ctx.shadowColor = '#ff4444';
  ctx.shadowBlur = 15 + Math.sin(titleAnimFrame * 0.05) * 8;
  ctx.font = '24px "Press Start 2P"';
  ctx.fillStyle = '#ff4444';
  ctx.fillText('CONTRA', GAME_W / 2, logoY);
  ctx.shadowColor = '#ff8800';
  ctx.shadowBlur = 10;
  ctx.font = '18px "Press Start 2P"';
  ctx.fillStyle = '#ffcc00';
  ctx.fillText('FORCE', GAME_W / 2, logoY + 28);
  ctx.shadowBlur = 0;

  // Demo indicator
  ctx.font = '8px "Press Start 2P"';
  ctx.fillStyle = '#ff8844';
  ctx.globalAlpha = 0.5 + Math.sin(titleAnimFrame * 0.08) * 0.3;
  ctx.fillText('‚Äî DEMO ‚Äî PRESS ANY KEY TO START ‚Äî', GAME_W / 2, GAME_H - 20);
  ctx.globalAlpha = 1;

  ctx.textAlign = 'left';
  ctx.restore();
}

// Demo mode: auto-play AI
let demoAI = { moveDir: 1, jumpTimer: 0, shootTimer: 0, aimTimer: 0 };

function startDemoMode() {
  if (gameState !== 'title') return;
  titleDemoActive = true;
  overlay.classList.add('hidden');
  hud.classList.add('hidden');
  // Temporarily start a game session for demo
  gameMode = 'campaign';
  stage = Math.ceil(Math.random() * 3); // Random early stage
  applyDifficulty();
  resetRunStats();
  initGame();
  gameState = 'demo';
  if (player) player.lives = 99;
  demoAI = { moveDir: 1, jumpTimer: 0, shootTimer: 0, aimTimer: 0 };
}

function stopDemoMode() {
  titleDemoActive = false;
  titleDemoTimer = 0;
  gameState = 'title';
  demoAI = { moveDir: 1, jumpTimer: 0, shootTimer: 0, aimTimer: 0 };
  overlay.classList.remove('hidden');
  hud.classList.add('hidden');
}

function updateDemoAI() {
  if (gameState !== 'demo' || !player) return;
  const p = player;

  // Simple AI: run right, shoot occasionally, jump over gaps/enemies
  demoAI.jumpTimer--;
  demoAI.shootTimer--;
  demoAI.aimTimer--;

  // Move right, occasionally reverse at walls
  p.vx = demoAI.moveDir * playerSpeed * 0.8;
  p.facing = demoAI.moveDir;
  p.aimX = demoAI.moveDir;
  p.aimY = 0;

  // Edge detection / wall bump ‚Äî reverse occasionally
  const frontCol = Math.floor((p.x + (demoAI.moveDir > 0 ? p.w + 4 : -4)) / TILE);
  const footRow = Math.floor((p.y + p.h - 2) / TILE);
  if (frontCol >= 0 && frontCol < level.cols && footRow >= 0 && footRow < level.rows) {
    if (level.map[footRow][frontCol] === 1) {
      // Wall ahead ‚Äî jump or reverse
      if (demoAI.jumpTimer <= 0 && p.onGround) {
        p.vy = jumpForce;
        p.onGround = false;
        demoAI.jumpTimer = 30;
      }
    }
    // Gap detection
    const belowFront = footRow + 1 < level.rows ? level.map[footRow + 1][frontCol] : 0;
    if (!belowFront && p.onGround && demoAI.jumpTimer <= 0) {
      p.vy = jumpForce;
      p.onGround = false;
      demoAI.jumpTimer = 20;
    }
  }

  // Reverse at level edges
  if (p.x < 30) demoAI.moveDir = 1;
  if (p.x > (level.cols - 3) * TILE) demoAI.moveDir = -1;

  // Random direction changes
  if (Math.random() < 0.005) demoAI.moveDir *= -1;

  // Shoot at nearby enemies
  if (demoAI.shootTimer <= 0) {
    for (const e of enemies) {
      if (!e.active) continue;
      const dx = e.x - p.x;
      const dy = e.y - p.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < 300) {
        // Aim toward enemy
        p.aimX = dx > 0 ? 1 : -1;
        p.aimY = Math.abs(dy) > 40 ? (dy > 0 ? 1 : -1) : 0;
        p.facing = p.aimX;
        fireWeapon(p);
        demoAI.shootTimer = p.weapon.fireRate + Math.floor(Math.random() * 10);
        break;
      }
    }
    if (demoAI.shootTimer <= 0) {
      // Shoot forward periodically
      if (Math.random() < 0.03) {
        fireWeapon(p);
        demoAI.shootTimer = 15;
      }
    }
  }

  // Jump occasionally
  if (p.onGround && Math.random() < 0.01 && demoAI.jumpTimer <= 0) {
    p.vy = jumpForce;
    p.onGround = false;
    demoAI.jumpTimer = 40;
  }

  // Respawn if dead
  if (p.dead && p.lives > 0 && p.respawnTimer <= 0) {
    p.dead = false;
    p.invincible = 120;
    p.x = 60;
    p.y = 100;
  }
  // End demo if out of lives
  if (p.dead && p.lives <= 0) {
    stopDemoMode();
  }
}

// ============================================================
//  CREDITS ROLL
// ============================================================

let creditsActive = false;
let creditsScrollY = 0;
let creditsSpeed = 0.8;
let creditsCallback = null;
const CREDITS_DATA = [
  { type: 'title', text: 'CONTRA FORCE' },
  { type: 'subtitle', text: 'HTML5 EDITION' },
  { type: 'gap', height: 40 },
  { type: 'heading', text: '‚Äî GAME DESIGN ‚Äî' },
  { type: 'name', text: 'Custom Implementation' },
  { type: 'gap', height: 30 },
  { type: 'heading', text: '‚Äî PROGRAMMING ‚Äî' },
  { type: 'name', text: 'Game Engine & Physics' },
  { type: 'name', text: 'Enemy AI & Boss Patterns' },
  { type: 'name', text: 'Procedural Level Generation' },
  { type: 'name', text: 'Particle & Effects Systems' },
  { type: 'name', text: 'Multiplayer & Networking' },
  { type: 'gap', height: 30 },
  { type: 'heading', text: '‚Äî AUDIO ‚Äî' },
  { type: 'name', text: 'Procedural Chip-Tune Synthesis' },
  { type: 'name', text: '5 Dynamic Music Tracks' },
  { type: 'name', text: '27 Sound Effects' },
  { type: 'gap', height: 30 },
  { type: 'heading', text: '‚Äî ART & RENDERING ‚Äî' },
  { type: 'name', text: 'Sprite Sheet Generation' },
  { type: 'name', text: 'Parallax Backgrounds' },
  { type: 'name', text: 'CRT & Weather Effects' },
  { type: 'name', text: 'Dynamic Lighting' },
  { type: 'gap', height: 30 },
  { type: 'heading', text: '‚Äî GAME FEATURES ‚Äî' },
  { type: 'name', text: '10 Unique Stages' },
  { type: 'name', text: '8 Enemy Types + Bosses' },
  { type: 'name', text: '11 Weapons' },
  { type: 'name', text: '6 Playable Characters' },
  { type: 'name', text: '25 Achievements' },
  { type: 'name', text: '5 Game Modes' },
  { type: 'name', text: 'Story Mode & Cutscenes' },
  { type: 'name', text: 'Online Co-op Multiplayer' },
  { type: 'gap', height: 30 },
  { type: 'heading', text: '‚Äî SPECIAL THANKS ‚Äî' },
  { type: 'name', text: 'Konami ‚Äî Original CONTRA' },
  { type: 'name', text: 'The Retro Gaming Community' },
  { type: 'gap', height: 50 },
  { type: 'heading', text: '‚Äî YOUR STATS ‚Äî' },
  { type: 'stat', key: 'kills' },
  { type: 'stat', key: 'combo' },
  { type: 'stat', key: 'time' },
  { type: 'stat', key: 'stages' },
  { type: 'stat', key: 'deaths' },
  { type: 'gap', height: 50 },
  { type: 'title', text: 'THANK YOU' },
  { type: 'subtitle', text: 'FOR PLAYING' },
  { type: 'gap', height: 30 },
  { type: 'ending', text: 'üéÆ' },
  { type: 'gap', height: GAME_H },
];

function startCredits(callback) {
  creditsActive = true;
  creditsScrollY = GAME_H;
  creditsCallback = callback || null;
}

function updateCredits() {
  if (!creditsActive) return;
  creditsScrollY -= creditsSpeed;

  // Calculate total credits height
  let totalH = 0;
  for (const line of CREDITS_DATA) {
    if (line.type === 'gap') totalH += line.height;
    else if (line.type === 'title') totalH += 50;
    else if (line.type === 'subtitle') totalH += 30;
    else if (line.type === 'heading') totalH += 35;
    else if (line.type === 'ending') totalH += 40;
    else totalH += 20;
  }

  // Credits finished scrolling
  if (creditsScrollY < -totalH) {
    creditsActive = false;
    if (creditsCallback) {
      creditsCallback();
      creditsCallback = null;
    }
  }
}

function drawCredits() {
  if (!creditsActive) return;

  // Background ‚Äî dark with slow-moving stars
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, GAME_W, GAME_H);

  for (const star of titleStars) {
    star.y -= 0.3;
    if (star.y < -2) star.y = GAME_H + 2;
    ctx.globalAlpha = star.brightness * 0.5;
    ctx.fillStyle = '#8899bb';
    ctx.fillRect(star.x, star.y, star.size * 0.7, star.size * 0.7);
  }
  ctx.globalAlpha = 1;

  // Render credits text
  ctx.textAlign = 'center';
  let y = creditsScrollY;

  for (const line of CREDITS_DATA) {
    // Skip off-screen lines (optimization)
    const lineH = line.type === 'gap' ? line.height : (line.type === 'title' ? 50 : (line.type === 'subtitle' ? 30 : (line.type === 'heading' ? 35 : (line.type === 'ending' ? 40 : 20))));
    if (y + lineH < -20) { y += lineH; continue; }
    if (y > GAME_H + 20) { y += lineH; continue; }

    switch (line.type) {
      case 'title':
        ctx.font = '24px "Press Start 2P"';
        ctx.fillStyle = '#ff4444';
        ctx.shadowColor = '#ff0000';
        ctx.shadowBlur = 15;
        ctx.fillText(line.text, GAME_W / 2, y);
        ctx.shadowBlur = 0;
        y += 50;
        break;
      case 'subtitle':
        ctx.font = '12px "Press Start 2P"';
        ctx.fillStyle = '#ffcc00';
        ctx.fillText(line.text, GAME_W / 2, y);
        y += 30;
        break;
      case 'heading':
        ctx.font = '10px "Press Start 2P"';
        ctx.fillStyle = '#44aaff';
        ctx.fillText(line.text, GAME_W / 2, y);
        y += 35;
        break;
      case 'name':
        ctx.font = '8px "Press Start 2P"';
        ctx.fillStyle = '#cccccc';
        ctx.fillText(line.text, GAME_W / 2, y);
        y += 20;
        break;
      case 'stat': {
        ctx.font = '8px "Press Start 2P"';
        ctx.fillStyle = '#ffaa44';
        let text = '';
        if (line.key === 'kills') text = `üíÄ KILLS: ${runStats.kills}`;
        else if (line.key === 'combo') text = `üî• MAX COMBO: ${runStats.maxCombo}x`;
        else if (line.key === 'time') {
          const dur = (Date.now() - runStats.startTime) / 1000;
          text = `‚è±Ô∏è TIME: ${Math.floor(dur / 60)}:${String(Math.floor(dur % 60)).padStart(2, '0')}`;
        }
        else if (line.key === 'stages') text = `üèÅ STAGES: ${runStats.stagesCleared}`;
        else if (line.key === 'deaths') text = `‚ò†Ô∏è DEATHS: ${runStats.deaths}`;
        ctx.fillText(text, GAME_W / 2, y);
        y += 20;
        break;
      }
      case 'ending':
        ctx.font = '32px "Press Start 2P"';
        ctx.fillText(line.text, GAME_W / 2, y);
        y += 40;
        break;
      case 'gap':
        y += line.height;
        break;
    }
  }
  ctx.textAlign = 'left';

  // Skip prompt
  ctx.font = '6px "Press Start 2P"';
  ctx.fillStyle = '#666';
  ctx.textAlign = 'center';
  ctx.globalAlpha = 0.5 + Math.sin(Date.now() * 0.005) * 0.3;
  ctx.fillText('PRESS ENTER OR ESC TO SKIP', GAME_W / 2, GAME_H - 10);
  ctx.globalAlpha = 1;
  ctx.textAlign = 'left';
}

// ============================================================
//  TUTORIAL STAGE (STAGE 0)
// ============================================================

let tutorialActive = false;
let tutorialStep = 0;
let tutorialTimer = 0;
let tutorialComplete = false;
try { tutorialComplete = localStorage.getItem('contraForce_tutorialDone') === '1'; } catch(e) {}

const TUTORIAL_STEPS = [
  { msg: 'WELCOME, SOLDIER! USE ‚Üê ‚Üí OR A/D TO MOVE', check: 'move', hint: 'MOVE LEFT AND RIGHT' },
  { msg: 'PRESS X OR UP TO JUMP', check: 'jump', hint: 'JUMP OVER THE GAP' },
  { msg: 'PRESS SPACE OR Z TO SHOOT!', check: 'shoot', hint: 'DESTROY THE TARGETS' },
  { msg: 'HOLD UP/DOWN TO AIM IN 8 DIRECTIONS', check: 'aim', hint: 'AIM UP AND SHOOT' },
  { msg: 'CLIMB LADDERS WITH UP/DOWN', check: 'climb', hint: 'CLIMB THE LADDER' },
  { msg: 'PRESS C TO FIRE THE GRAPPLE HOOK', check: 'grapple', hint: 'GRAPPLE TO THE PLATFORM' },
  { msg: 'COLLECT WEAPON POWER-UPS!', check: 'weapon', hint: 'GRAB THE FLOATING ITEM' },
  { msg: 'YOU\'RE READY! DESTROY THE BOSS!', check: 'boss', hint: 'DEFEAT THE BOSS TO FINISH' },
];

let tutorialChecks = {
  moved: 0,        // frames of movement
  jumped: false,
  shot: false,
  aimedUp: false,
  climbed: false,
  grappled: false,
  weaponGot: false,
  bossKilled: false,
};

function startTutorial() {
  tutorialActive = true;
  tutorialStep = 0;
  tutorialTimer = 0;
  tutorialChecks = { moved: 0, jumped: false, shot: false, aimedUp: false, climbed: false, grappled: false, weaponGot: false, bossKilled: false };
  stage = 0;
  gameMode = 'campaign';
  applyDifficulty();
  resetRunStats();
  gameState = 'playing';
  overlay.classList.add('hidden');
  hud.classList.remove('hidden');
  initTutorialLevel();
}

function initTutorialLevel() {
  // Create a custom hand-crafted tutorial level
  const cols = 80;
  const rows = 20;
  const groundRow = 14;
  const map = [];
  for (let r = 0; r < rows; r++) {
    map[r] = [];
    for (let c = 0; c < cols; c++) {
      if (r >= groundRow) map[r][c] = 1;
      else map[r][c] = 0;
    }
  }

  // Gap for jump training (cols 18-20)
  for (let r = groundRow; r < rows; r++) {
    map[r][18] = 0; map[r][19] = 0; map[r][20] = 0;
  }

  // Target platform (wall to shoot at) ‚Äî cols 28-30
  map[groundRow - 3][30] = 1;
  map[groundRow - 2][30] = 1;
  map[groundRow - 1][30] = 1;

  // Ladder at col 38
  for (let r = groundRow - 6; r < groundRow; r++) {
    map[r][38] = 2;
  }
  // Platform at top of ladder
  for (let c = 36; c <= 42; c++) {
    map[groundRow - 6][c] = 1;
  }

  // Grapple gap ‚Äî cols 48-54, platform at col 55
  for (let r = groundRow; r < rows; r++) {
    for (let c = 48; c <= 54; c++) map[r][c] = 0;
  }
  // Ceiling bar for grapple
  map[groundRow - 5][51] = 1;

  // Weapon pickup area ‚Äî col 60-62, raised platform
  for (let c = 58; c <= 64; c++) {
    map[groundRow - 2][c] = 1;
  }

  // Boss arena ‚Äî cols 68-78
  for (let c = 68; c <= 78; c++) {
    map[groundRow - 1][c] = 1;
  }
  // Walls
  for (let r = groundRow - 8; r < groundRow; r++) {
    map[r][68] = 1;
    map[r][78] = 1;
  }

  level = {
    map, cols, rows, groundRow,
    treasureMap: {},
  };

  player = createPlayer(40, selectedCharacter);
  player.lives = 99;
  player2 = null;
  coopMode = false;

  // Place player on ground
  player.y = (groundRow - 1) * TILE - player.h;

  // Clear arrays
  enemies = [];
  bullets = [];
  enemyBullets = [];
  particles = [];
  popups = [];
  powerups = [];
  objects = [];
  decorations = [];
  treasureItems = [];
  vehicles = [];

  // Spawn tutorial targets (weak enemies that don't move)
  for (let i = 0; i < 3; i++) {
    enemies.push({
      x: 26 * TILE + i * TILE * 2, y: (groundRow - 1) * TILE - 24,
      w: 20, h: 24, hp: 1, maxHp: 1, speed: 0, score: 100,
      color: '#ff4444', etype: 'soldier', isBoss: false, active: true,
      facing: -1, fireTimer: 99999, shootRange: 0, leapTimer: 0,
      shieldHp: 0, animFrame: 0, animTimer: 0,
      patrol: false, pathDir: 0,
    });
  }

  // Spawn weapon powerup at col 61
  powerups.push({
    x: 61 * TILE, y: (groundRow - 4) * TILE,
    w: 16, h: 16, type: 'SPREAD', bobPhase: 0,
  });

  // Spawn tutorial boss at col 73
  enemies.push({
    x: 73 * TILE, y: (groundRow - 2) * TILE - 40,
    w: 40, h: 40, hp: 15, maxHp: 15, speed: 0, score: 500,
    color: '#ff0000', etype: 'boss', isBoss: true, active: true,
    facing: -1, fireTimer: 120, shootRange: 200, leapTimer: 0,
    shieldHp: 0, animFrame: 0, animTimer: 0,
    patrol: false, pathDir: 0,
    phase: 0, phaseTimer: 0,
  });

  camX = 0;
  camY = 0;
  freezeFrames = 0;
  slowMo = 0;
  shakeIntensity = 0;
  shakeDuration = 0;
  flashAlpha = 0;

  spawnPopup(player.x + 40, player.y - 20, 'TUTORIAL START!', '#44ff44', 14);
}

function updateTutorial() {
  if (!tutorialActive || gameState !== 'playing') return;
  tutorialTimer++;

  const step = TUTORIAL_STEPS[tutorialStep];
  if (!step) return;

  // Check step completion
  switch (step.check) {
    case 'move':
      if (Math.abs(player.vx) > 0.5) tutorialChecks.moved++;
      if (tutorialChecks.moved > 60) advanceTutorial();
      break;
    case 'jump':
      if (!player.onGround && player.vy < 0) tutorialChecks.jumped = true;
      if (tutorialChecks.jumped && player.x > 21 * TILE) advanceTutorial();
      break;
    case 'shoot':
      if (bullets.length > 0) tutorialChecks.shot = true;
      // Check if targets destroyed
      const targetsLeft = enemies.filter(e => e.active && !e.isBoss && e.x < 35 * TILE).length;
      if (tutorialChecks.shot && targetsLeft === 0) advanceTutorial();
      break;
    case 'aim':
      if (player.aimY !== 0) tutorialChecks.aimedUp = true;
      if (tutorialChecks.aimedUp) advanceTutorial();
      break;
    case 'climb':
      if (player.climbing) tutorialChecks.climbed = true;
      if (tutorialChecks.climbed && player.y < (level.groundRow - 4) * TILE) advanceTutorial();
      break;
    case 'grapple':
      if (player.grapple) tutorialChecks.grappled = true;
      if (tutorialChecks.grappled && player.x > 55 * TILE) advanceTutorial();
      break;
    case 'weapon':
      if (player.weapon && player.weapon.name !== 'RIFLE') tutorialChecks.weaponGot = true;
      if (tutorialChecks.weaponGot) advanceTutorial();
      break;
    case 'boss':
      const bossAlive = enemies.some(e => e.isBoss && e.active);
      if (!bossAlive && enemies.length > 0) {
        tutorialChecks.bossKilled = true;
        finishTutorial();
      }
      break;
  }
}

function advanceTutorial() {
  tutorialStep++;
  tutorialTimer = 0;
  if (tutorialStep < TUTORIAL_STEPS.length) {
    const step = TUTORIAL_STEPS[tutorialStep];
    spawnPopup(player.x + player.w / 2, player.y - 30, step.msg, '#44ffaa', 10);
  }
}

function finishTutorial() {
  tutorialActive = false;
  tutorialComplete = true;
  try { localStorage.setItem('contraForce_tutorialDone', '1'); } catch(e) {}
  spawnPopup(player.x + player.w / 2, player.y - 40, 'TUTORIAL COMPLETE!', '#ffcc00', 16);
  playSound('victory');
  triggerFlash('#ffcc00', 0.5);
  setTimeout(() => {
    stage = 1;
    gameState = 'title';
    showOverlay('CONTRA FORCE', '‚ö° RUN & GUN ‚ö°', 'PRESS ENTER TO START');
  }, 3000);
}

function drawTutorialHUD() {
  if (!tutorialActive) return;
  const step = TUTORIAL_STEPS[tutorialStep];
  if (!step) return;

  // Instruction banner at top
  ctx.fillStyle = 'rgba(0,0,0,0.7)';
  ctx.fillRect(0, 0, GAME_W, 28);

  ctx.font = '8px "Press Start 2P"';
  ctx.textAlign = 'center';
  ctx.fillStyle = '#44ffaa';
  ctx.fillText(step.msg, GAME_W / 2, 12);

  // Hint below
  ctx.font = '6px "Press Start 2P"';
  ctx.fillStyle = '#888';
  const blinkAlpha = 0.4 + Math.sin(Date.now() * 0.006) * 0.3;
  ctx.globalAlpha = blinkAlpha;
  ctx.fillText(step.hint, GAME_W / 2, 23);
  ctx.globalAlpha = 1;
  ctx.textAlign = 'left';

  // Step progress
  ctx.font = '6px "Press Start 2P"';
  ctx.fillStyle = '#666';
  ctx.fillText(`STEP ${tutorialStep + 1}/${TUTORIAL_STEPS.length}`, 6, GAME_H - 6);
}

// ============================================================
//  PARTICLE EDITOR (ADMIN PANEL)
// ============================================================

// Particle presets that can be tweaked live
let particlePresets = {
  explosion: { count: 30, speed: 6, life: 35, color: '#ff4400', size: 3, gravity: 0.2 },
  death:     { count: 40, speed: 7, life: 40, color: '#ff4400', sizeMin: 1, sizeMax: 3, gravity: 0 },
  glow:      { count: 10, speed: 4, life: 40, color: '#ff8800', sizeMin: 2, sizeMax: 4 },
  ring:      { count: 12, speed: 0.15, life: 20, color: '#ff6600', size: 3 },
  debris:    { count: 6, speed: 5, life: 60, color: '#666666', sizeMin: 3, sizeMax: 5, gravity: 0.2 },
};

function getParticlePreset(name) {
  return particlePresets[name] || particlePresets.explosion;
}

function particleEditorTestEffect(presetName) {
  const p = getParticlePreset(presetName);
  const cx = player ? player.x + player.w / 2 : GAME_W / 2;
  const cy = player ? player.y + player.h / 2 : GAME_H / 2;

  if (presetName === 'ring') {
    spawnRing(cx, cy, p.color, p.speed * 500, p.count);
  } else if (presetName === 'glow') {
    spawnGlowParticles(cx, cy, p.color, p.count, p.speed, p.life);
  } else if (presetName === 'debris') {
    spawnDebris(cx, cy, p.color, p.count);
  } else {
    spawnParticles(cx, cy, p.color, p.count, p.speed, p.life);
  }
  addLight(cx, cy, 80, 'rgba(255,100,0,0.5)', 0.5, 15);
  triggerShake(6, 8);
}

function updateParticleEditorUI() {
  const container = document.getElementById('particleEditorPresets');
  if (!container) return;
  let html = '';
  for (const [name, p] of Object.entries(particlePresets)) {
    html += `<div style="margin-bottom:8px;border:1px solid #333;padding:6px;border-radius:4px;">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:4px;">
        <span style="color:#ffaa44;font-size:8px;text-transform:uppercase;">${name}</span>
        <button class="admin-btn" onclick="particleEditorTestEffect('${name}')" style="font-size:8px;padding:2px 6px;background:#331100;color:#ff8844;border:1px solid #ff6600;">‚ñ∂ TEST</button>
      </div>
      <div class="admin-row"><label>Count</label><input type="range" min="1" max="80" step="1" value="${p.count}" oninput="particlePresets.${name}.count=+this.value;this.nextElementSibling.textContent=this.value"><span class="val">${p.count}</span></div>
      <div class="admin-row"><label>Speed</label><input type="range" min="0.5" max="15" step="0.5" value="${p.speed}" oninput="particlePresets.${name}.speed=+this.value;this.nextElementSibling.textContent=this.value"><span class="val">${p.speed}</span></div>
      <div class="admin-row"><label>Life</label><input type="range" min="5" max="120" step="5" value="${p.life}" oninput="particlePresets.${name}.life=+this.value;this.nextElementSibling.textContent=this.value"><span class="val">${p.life}</span></div>
      <div class="admin-row"><label>Color</label><input type="color" value="${p.color}" oninput="particlePresets.${name}.color=this.value" style="width:40px;height:20px;border:1px solid #555;cursor:pointer;"></div>
    </div>`;
  }
  container.innerHTML = html;
}

// ============================================================
//  MINI-BOSS TYPES
// ============================================================
const MINI_BOSS_TYPES = {
  CHARGER: {
    name: 'CHARGER', w: 32, h: 38, hp: 15, speed: 0, score: 800,
    color: '#dd4444', fireRate: 80, shootRange: 350, etype: 'miniboss',
    pattern: 'charge', // charges at player
  },
  SHIELDED: {
    name: 'SHIELDED', w: 30, h: 36, hp: 20, speed: 0.5, score: 900,
    color: '#4488dd', fireRate: 50, shootRange: 300, etype: 'miniboss',
    pattern: 'shielded', // front shield, must hit from behind
  },
  ARTILLERY: {
    name: 'ARTILLERY', w: 34, h: 32, hp: 18, speed: 0, score: 850,
    color: '#88aa44', fireRate: 35, shootRange: 500, etype: 'miniboss',
    pattern: 'artillery', // lobs arcing projectiles
  },
  SPLITTER: {
    name: 'SPLITTER', w: 28, h: 34, hp: 12, speed: 1, score: 750,
    color: '#cc44cc', fireRate: 70, shootRange: 280, etype: 'miniboss',
    pattern: 'splitter', // splits into 2 smaller enemies on death
  },
  JUMPSTOMP: {
    name: 'JUMP STOMPER', w: 30, h: 36, hp: 16, speed: 0.6, score: 850,
    color: '#dd8800', fireRate: 0, shootRange: 200, etype: 'miniboss',
    pattern: 'jumpstomp', // jumps high and ground-pounds
  },
};

function getMiniBossForStage(stageNum) {
  const types = Object.values(MINI_BOSS_TYPES);
  return types[(stageNum - 1) % types.length];
}

function spawnMiniBosses(level, stageNum) {
  const rng = seedRandom(stageNum * 31337);
  const { cols, groundRow } = level;
  // 1-2 mini-bosses per stage, placed at ~30% and ~60% of level
  const positions = [Math.floor(cols * 0.3), Math.floor(cols * 0.6)];
  const count = stageNum >= 5 ? 2 : 1;

  for (let i = 0; i < count; i++) {
    const mbType = getMiniBossForStage(stageNum + i);
    const c = positions[i] + Math.floor(rng() * 6 - 3);
    // Find ground
    let ey = 0;
    for (let r = 0; r < level.rows; r++) {
      if (level.map[r][c] === 1) { ey = r * TILE - mbType.h; break; }
    }
    if (ey <= 0) continue;
    const scaledHp = Math.round(mbType.hp * diffSettings.enemyHpMult * (1 + stageNum * 0.15));
    enemies.push({
      x: c * TILE, y: ey,
      w: mbType.w, h: mbType.h,
      hp: scaledHp, maxHp: scaledHp,
      speed: mbType.speed, score: mbType.score,
      color: mbType.color, fireRate: mbType.fireRate,
      fireTimer: Math.floor(rng() * mbType.fireRate),
      shootRange: mbType.shootRange,
      active: false, facing: -1,
      isMiniBoss: true,
      mbPattern: mbType.pattern,
      mbState: 'idle', mbTimer: 0,
      damageMult: 1,
      shieldActive: false,
      etype: 'miniboss',
      patrolStart: (c - 6) * TILE,
      patrolEnd: (c + 6) * TILE,
      dir: rng() < 0.5 ? 1 : -1,
      vy: 0, onGround: false,
      hitFlash: 0,
    });
  }
}

// ============================================================
//  ENVIRONMENTAL HAZARDS
// ============================================================
let hazards = [];

const HAZARD_TYPES = {
  MOVING_PLATFORM: { name: 'Moving Platform', w: 64, h: 12, color: '#667788', htype: 'moving_platform' },
  CRUSHER:         { name: 'Crusher', w: 48, h: 16, color: '#aa4444', htype: 'crusher' },
  SPIKE_TRAP:      { name: 'Spike Trap', w: 32, h: 10, color: '#cc6644', htype: 'spike_trap' },
  CONVEYOR_BELT:   { name: 'Conveyor Belt', w: 96, h: 8, color: '#888855', htype: 'conveyor' },
  LASER_GRID:      { name: 'Laser Grid', w: 4, h: 64, color: '#ff2244', htype: 'laser_grid' },
};

function spawnHazards(level, stageNum) {
  hazards = [];
  const rng = seedRandom(stageNum * 77777);
  const { cols, groundRow } = level;
  const hazardDensity = Math.min(1.5, 0.5 + stageNum * 0.1);

  for (let c = 20; c < cols - 20; c += 8) {
    if (rng() > 0.12 * hazardDensity) continue;
    const roll = rng();
    const baseY = groundRow * TILE;

    if (roll < 0.25) {
      // Moving Platform
      const startX = c * TILE;
      const endX = startX + (4 + Math.floor(rng() * 6)) * TILE;
      hazards.push({
        ...HAZARD_TYPES.MOVING_PLATFORM,
        x: startX, y: baseY - (3 + Math.floor(rng() * 4)) * TILE,
        startX, endX, dir: 1, speed: 0.8 + rng() * 0.6,
        phase: rng() * Math.PI * 2,
      });
    } else if (roll < 0.45) {
      // Crusher
      const cx = c * TILE;
      hazards.push({
        ...HAZARD_TYPES.CRUSHER,
        x: cx, y: baseY - 8 * TILE,
        restY: baseY - 8 * TILE, crushY: baseY - TILE - 16,
        state: 'waiting', timer: Math.floor(rng() * 120), speed: 4,
        waitTime: 90 + Math.floor(rng() * 60),
      });
    } else if (roll < 0.65) {
      // Spike Trap
      hazards.push({
        ...HAZARD_TYPES.SPIKE_TRAP,
        x: c * TILE, y: baseY - 10,
        active: true, timer: 0, interval: 60 + Math.floor(rng() * 60),
      });
    } else if (roll < 0.82) {
      // Conveyor Belt
      hazards.push({
        ...HAZARD_TYPES.CONVEYOR_BELT,
        x: c * TILE, y: baseY - 8,
        conveyorDir: rng() < 0.5 ? -1 : 1, conveyorSpeed: 1.5 + rng() * 1.5,
        animPhase: 0,
      });
    } else {
      // Laser Grid
      const lx = c * TILE + TILE / 2;
      hazards.push({
        ...HAZARD_TYPES.LASER_GRID,
        x: lx, y: baseY - 3 * TILE,
        h: (2 + Math.floor(rng() * 3)) * TILE,
        onTime: 80 + Math.floor(rng() * 60),
        offTime: 40 + Math.floor(rng() * 40),
        timer: Math.floor(rng() * 100), active: true,
      });
    }
    c += 4; // spacing
  }
}

function updateHazards() {
  for (const h of hazards) {
    switch (h.htype) {
      case 'moving_platform':
        h.phase += 0.015 * h.speed;
        h.x = h.startX + (h.endX - h.startX) * 0.5 * (1 + Math.sin(h.phase));
        break;
      case 'crusher':
        h.timer++;
        if (h.state === 'waiting' && h.timer >= h.waitTime) {
          h.state = 'crushing'; h.timer = 0;
        } else if (h.state === 'crushing') {
          h.y += h.speed;
          if (h.y >= h.crushY) { h.y = h.crushY; h.state = 'holding'; h.timer = 0; triggerShake(4, 6); }
        } else if (h.state === 'holding' && h.timer >= 30) {
          h.state = 'retracting'; h.timer = 0;
        } else if (h.state === 'retracting') {
          h.y -= h.speed * 0.5;
          if (h.y <= h.restY) { h.y = h.restY; h.state = 'waiting'; h.timer = 0; }
        }
        break;
      case 'spike_trap':
        h.timer++;
        if (h.timer >= h.interval) { h.active = !h.active; h.timer = 0; }
        break;
      case 'conveyor':
        h.animPhase += h.conveyorSpeed * h.conveyorDir * 0.05;
        break;
      case 'laser_grid':
        h.timer++;
        const cycleLen = h.onTime + h.offTime;
        const inCycle = h.timer % cycleLen;
        h.active = inCycle < h.onTime;
        break;
    }
  }
}

function checkHazardCollisions(p) {
  if (p.dead || p.invincible > 0 || godMode) return;
  for (const h of hazards) {
    if (h.x + h.w < camX - 100 || h.x > camX + viewW() + 100) continue;
    switch (h.htype) {
      case 'moving_platform':
        // Player lands on platform
        if (p.vy >= 0 && p.x + p.w > h.x && p.x < h.x + h.w &&
            p.y + p.h >= h.y && p.y + p.h <= h.y + h.h + 6) {
          p.y = h.y - p.h;
          p.vy = 0;
          p.onGround = true;
          // Move player with platform
          const prevX = h.startX + (h.endX - h.startX) * 0.5 * (1 + Math.sin(h.phase - 0.015 * h.speed));
          p.x += (h.x - prevX);
        }
        break;
      case 'crusher':
        if (h.state === 'crushing' || h.state === 'holding') {
          if (rectCollide(p, h)) killPlayer(p);
        }
        break;
      case 'spike_trap':
        if (h.active && rectCollide(p, { x: h.x, y: h.y, w: h.w, h: h.h })) {
          killPlayer(p);
        }
        break;
      case 'conveyor':
        // Push player if standing on it
        if (p.onGround && p.x + p.w > h.x && p.x < h.x + h.w &&
            Math.abs((p.y + p.h) - h.y) < 10) {
          p.x += h.conveyorDir * h.conveyorSpeed * 0.5;
        }
        break;
      case 'laser_grid':
        if (h.active && rectCollide(p, h)) killPlayer(p);
        break;
    }
  }
}

function drawHazards() {
  for (const h of hazards) {
    if (h.x + h.w < camX - 50 || h.x > camX + viewW() + 50) continue;
    const sx = h.x - camX;
    switch (h.htype) {
      case 'moving_platform': {
        ctx.fillStyle = h.color;
        ctx.fillRect(sx, h.y, h.w, h.h);
        // Rivets
        ctx.fillStyle = '#99aabb';
        for (let rx = 4; rx < h.w - 4; rx += 12) {
          ctx.fillRect(sx + rx, h.y + 3, 4, 4);
        }
        // Rail indicators
        ctx.strokeStyle = 'rgba(100,120,140,0.3)';
        ctx.setLineDash([4, 4]);
        ctx.beginPath();
        ctx.moveTo(h.startX - camX, h.y + h.h / 2);
        ctx.lineTo(h.endX + h.w - camX, h.y + h.h / 2);
        ctx.stroke();
        ctx.setLineDash([]);
        break;
      }
      case 'crusher': {
        ctx.fillStyle = h.color;
        ctx.fillRect(sx, h.y, h.w, h.h);
        // Warning stripes
        ctx.fillStyle = '#ffcc00';
        for (let s = 0; s < h.w; s += 12) {
          ctx.fillRect(sx + s, h.y + h.h - 4, 6, 4);
        }
        // Teeth at bottom
        ctx.fillStyle = '#882222';
        for (let t = 0; t < h.w; t += 10) {
          ctx.beginPath();
          ctx.moveTo(sx + t, h.y + h.h);
          ctx.lineTo(sx + t + 5, h.y + h.h + 8);
          ctx.lineTo(sx + t + 10, h.y + h.h);
          ctx.fill();
        }
        break;
      }
      case 'spike_trap': {
        if (!h.active) {
          ctx.fillStyle = '#553322';
          ctx.fillRect(sx, h.y + 6, h.w, 4);
          break;
        }
        ctx.fillStyle = h.color;
        // Draw spikes
        for (let s = 0; s < h.w; s += 8) {
          ctx.beginPath();
          ctx.moveTo(sx + s, h.y + h.h);
          ctx.lineTo(sx + s + 4, h.y);
          ctx.lineTo(sx + s + 8, h.y + h.h);
          ctx.fill();
        }
        break;
      }
      case 'conveyor': {
        ctx.fillStyle = h.color;
        ctx.fillRect(sx, h.y, h.w, h.h);
        // Animated arrows
        ctx.fillStyle = '#bbbb88';
        const arrowChar = h.conveyorDir > 0 ? '‚ñ∫' : '‚óÑ';
        ctx.font = '6px sans-serif';
        const phase = (h.animPhase % 1 + 1) % 1;
        for (let a = -1; a < h.w / 16 + 1; a++) {
          const ax = sx + (a + phase) * 16;
          if (ax >= sx && ax <= sx + h.w - 8) ctx.fillText(arrowChar, ax, h.y + 7);
        }
        break;
      }
      case 'laser_grid': {
        if (!h.active) {
          // Dim offline laser
          ctx.globalAlpha = 0.15;
          ctx.fillStyle = '#ff2244';
          ctx.fillRect(sx - 1, h.y, 3, h.h);
          ctx.globalAlpha = 1;
          break;
        }
        // Active laser beam
        const pulse = 0.6 + Math.sin(Date.now() * 0.02) * 0.4;
        ctx.globalAlpha = 0.3 * pulse;
        ctx.fillStyle = '#ff4466';
        ctx.fillRect(sx - 6, h.y, 14, h.h);
        ctx.globalAlpha = 0.6 * pulse;
        ctx.fillStyle = '#ff2244';
        ctx.fillRect(sx - 2, h.y, 6, h.h);
        ctx.globalAlpha = 1;
        ctx.fillStyle = '#ff6688';
        ctx.fillRect(sx, h.y, 2, h.h);
        // Emitter nodes
        ctx.fillStyle = '#cc2244';
        ctx.fillRect(sx - 4, h.y - 4, 10, 6);
        ctx.fillRect(sx - 4, h.y + h.h - 2, 10, 6);
        break;
      }
    }
  }
}

// ============================================================
//  WEAPON FUSION SYSTEM
// ============================================================
let fusionHeldWeapon = null; // tracks the first weapon for fusion
let fusionTimer = 0; // countdown to fusion window expiry
const FUSION_WINDOW = 300; // frames (5 seconds) to pick up second weapon

const WEAPON_FUSIONS = {
  'SPREAD+LASER':     { name: 'PRISM BURST',  fireRate: 10, damage: 4, bullets: 5, spread: 0.35, color: '#00ffcc', size: 5, type: 'pierce',    desc: 'Piercing fan of lasers' },
  'SPREAD+MACHINE':   { name: 'STORM',        fireRate: 4,  damage: 2, bullets: 3, spread: 0.4,  color: '#ffaa44', size: 3, type: 'normal',     desc: 'Rapid triple spray' },
  'LASER+FLAME':      { name: 'PLASMA BEAM',  fireRate: 3,  damage: 5, bullets: 1, spread: 0,    color: '#88ffff', size: 7, type: 'pierce',     desc: 'Continuous plasma pierce' },
  'MACHINE+ROCKET':   { name: 'GATLING RPG',  fireRate: 8,  damage: 8, bullets: 1, spread: 0.15, color: '#ff4400', size: 6, type: 'rocket',     desc: 'Rapid rockets' },
  'FLAME+SPREAD':     { name: 'INFERNO FAN',  fireRate: 5,  damage: 3, bullets: 5, spread: 0.3,  color: '#ff8800', size: 4, type: 'flame',      desc: 'Flame in all directions' },
  'HOMING+LIGHTNING': { name: 'THUNDERSTORM', fireRate: 12, damage: 6, bullets: 3, spread: 0.2,  color: '#aaffff', size: 4, type: 'lightning',   desc: 'Homing lightning bolts' },
  'ROCKET+HOMING':    { name: 'SMART MISSILE',fireRate: 20, damage: 15,bullets: 1, spread: 0,    color: '#ff66aa', size: 8, type: 'homing',      desc: 'Heavy homing rocket' },
  'WAVE+BOOMERANG':   { name: 'VORTEX',       fireRate: 14, damage: 4, bullets: 2, spread: 0.5,  color: '#44ffaa', size: 5, type: 'wave',        desc: 'Returning wave projectiles' },
  'BLACKHOLE+MINE':   { name: 'SINGULARITY',  fireRate: 40, damage: 20,bullets: 1, spread: 0,    color: '#8800ff', size: 10,type: 'blackhole',   desc: 'Massive gravity trap' },
  'LIGHTNING+WAVE':   { name: 'TESLA WAVE',   fireRate: 10, damage: 5, bullets: 2, spread: 0.3,  color: '#ccffaa', size: 5, type: 'lightning',   desc: 'Shocking sine wave' },
  'MACHINE+FLAME':    { name: 'NAPALM SPRAY', fireRate: 3,  damage: 3, bullets: 2, spread: 0.25, color: '#ff6622', size: 4, type: 'flame',      desc: 'Rapid fire napalm' },
  'ROCKET+SPREAD':    { name: 'CLUSTER BOMB', fireRate: 25, damage: 6, bullets: 5, spread: 0.5,  color: '#ff2200', size: 5, type: 'rocket',     desc: 'Explosive spread rockets' },
};

function getFusionKey(w1, w2) {
  // Try both orderings
  const k1 = w1 + '+' + w2;
  const k2 = w2 + '+' + w1;
  if (WEAPON_FUSIONS[k1]) return k1;
  if (WEAPON_FUSIONS[k2]) return k2;
  return null;
}

function tryWeaponFusion(p, newWeaponName) {
  if (newWeaponName === 'RIFLE') return false; // Can't fuse with default

  if (fusionHeldWeapon && fusionTimer > 0 && fusionHeldWeapon !== newWeaponName) {
    const key = getFusionKey(fusionHeldWeapon, newWeaponName);
    if (key) {
      const fusion = WEAPON_FUSIONS[key];
      p.weapon = { ...fusion, isFusion: true };
      const cx = p.x + p.w / 2;
      const cy = p.y + p.h / 2;
      spawnPopup(cx, cy - 30, 'FUSION: ' + fusion.name + '!', '#ffaa00', 14);
      spawnParticles(cx, cy, '#ffaa00', 40, 6, 40);
      spawnGlowParticles(cx, cy, fusion.color, 20, 5, 50);
      spawnRing(cx, cy, '#ffaa00', 50, 16);
      spawnRing(cx, cy, fusion.color, 35, 12);
      addLight(cx, cy, 120, 'rgba(255,170,0,0.6)', 0.7, 20);
      triggerShake(8, 12);
      triggerFreeze(8);
      triggerFlash('#ffaa00', 0.4);
      playSound('powerup');
      fusionHeldWeapon = null;
      fusionTimer = 0;
      return true;
    }
  }

  // No fusion available ‚Äî store this weapon and start the fusion window
  fusionHeldWeapon = newWeaponName;
  fusionTimer = FUSION_WINDOW;
  return false;
}

function updateFusionTimer() {
  if (fusionTimer > 0) {
    fusionTimer--;
    if (fusionTimer <= 0) fusionHeldWeapon = null;
  }
}

// ============================================================
//  SPEEDRUN TIMER WITH SPLITS
// ============================================================
let speedrunEnabled = false;
let speedrunTimer = 0; // total frames elapsed
let speedrunSplits = []; // { stage, time (seconds) } for current run
let speedrunPB = []; // personal best splits loaded from localStorage
let speedrunSplitDelta = null; // { delta, positive } for HUD display
let speedrunDeltaTimer = 0; // frames to show delta

function initSpeedrun() {
  speedrunTimer = 0;
  speedrunSplits = [];
  speedrunSplitDelta = null;
  speedrunDeltaTimer = 0;
  loadSpeedrunPB();
}

function loadSpeedrunPB() {
  try {
    const d = localStorage.getItem('contraForce_speedrunPB');
    if (d) speedrunPB = JSON.parse(d);
  } catch(e) {}
}

function saveSpeedrunPB() {
  try {
    localStorage.setItem('contraForce_speedrunPB', JSON.stringify(speedrunPB));
  } catch(e) {}
}

function updateSpeedrun() {
  if (!speedrunEnabled || (gameState !== 'playing')) return;
  speedrunTimer++;
  if (speedrunDeltaTimer > 0) speedrunDeltaTimer--;
}

function onSpeedrunStageClear(stageNum) {
  if (!speedrunEnabled) return;
  const timeS = speedrunTimer / 60;
  speedrunSplits.push({ stage: stageNum, time: timeS });

  // Compare to PB
  const pbSplit = speedrunPB.find(s => s.stage === stageNum);
  if (pbSplit) {
    const delta = timeS - pbSplit.time;
    speedrunSplitDelta = { delta, positive: delta > 0 };
    speedrunDeltaTimer = 180; // 3 seconds
  } else {
    speedrunSplitDelta = { delta: 0, positive: false, isNew: true };
    speedrunDeltaTimer = 180;
  }

  // Update PB if better
  if (!pbSplit || timeS < pbSplit.time) {
    const idx = speedrunPB.findIndex(s => s.stage === stageNum);
    if (idx >= 0) speedrunPB[idx].time = timeS;
    else speedrunPB.push({ stage: stageNum, time: timeS });
    saveSpeedrunPB();
  }
}

function formatSpeedrunTime(seconds) {
  const m = Math.floor(seconds / 60);
  const s = seconds % 60;
  return m.toString().padStart(2, '0') + ':' + s.toFixed(2).padStart(5, '0');
}

function drawSpeedrunHUD() {
  if (!speedrunEnabled || gameState !== 'playing') return;
  const timeS = speedrunTimer / 60;

  // Main timer - top center
  ctx.save();
  ctx.font = '10px "Press Start 2P"';
  ctx.textAlign = 'center';
  ctx.fillStyle = '#44ff88';
  ctx.fillText(formatSpeedrunTime(timeS), GAME_W / 2, 16);

  // Current stage label
  ctx.font = '6px "Press Start 2P"';
  ctx.fillStyle = '#88aa88';
  ctx.fillText('STAGE ' + stage, GAME_W / 2, 26);

  // Split delta display
  if (speedrunDeltaTimer > 0 && speedrunSplitDelta) {
    const alpha = Math.min(1, speedrunDeltaTimer / 30);
    ctx.globalAlpha = alpha;
    if (speedrunSplitDelta.isNew) {
      ctx.fillStyle = '#aaaaaa';
      ctx.fillText('NEW SPLIT', GAME_W / 2, 36);
    } else {
      const d = speedrunSplitDelta.delta;
      const sign = d >= 0 ? '+' : '';
      ctx.fillStyle = d >= 0 ? '#ff4444' : '#44ff44';
      ctx.font = '8px "Press Start 2P"';
      ctx.fillText(sign + d.toFixed(2) + 's', GAME_W / 2, 36);
    }
    ctx.globalAlpha = 1;
  }

  // Split history - right side
  ctx.textAlign = 'right';
  ctx.font = '6px "Press Start 2P"';
  const visibleSplits = speedrunSplits.slice(-5);
  for (let i = 0; i < visibleSplits.length; i++) {
    const sp = visibleSplits[i];
    const pb = speedrunPB.find(s => s.stage === sp.stage);
    const y = 50 + i * 12;
    ctx.fillStyle = '#668866';
    ctx.fillText('S' + sp.stage + ': ' + formatSpeedrunTime(sp.time), GAME_W - 8, y);
    if (pb) {
      const d = sp.time - pb.time;
      ctx.fillStyle = d <= 0 ? '#44ff44' : '#ff4444';
      const sign = d >= 0 ? '+' : '';
      ctx.fillText(sign + d.toFixed(1) + 's', GAME_W - 8, y + 8);
    }
  }
  ctx.textAlign = 'left';
  ctx.restore();
}

// ============================================================
//  ACCESSIBILITY OPTIONS
// ============================================================
let accessColorBlindMode = 'none'; // 'none', 'protanopia', 'deuteranopia', 'tritanopia'
let accessAimAssist = false;
let accessAimAssistStrength = 0.3; // 0-1
let accessInfiniteLives = false;
let accessEnemySpeedMult = 1.0;
let accessBulletTimeMult = 1.0; // slows enemy bullets
let accessHighContrastHUD = false;
let accessLargeHUD = false;
let accessScreenShakeReduced = false;

// Color-blind filter matrices (simplified LMS simulation)
const COLOR_BLIND_FILTERS = {
  none: null,
  protanopia:   [0.567, 0.433, 0, 0.558, 0.442, 0, 0, 0.242, 0.758],
  deuteranopia: [0.625, 0.375, 0, 0.7, 0.3, 0, 0, 0.3, 0.7],
  tritanopia:   [0.95, 0.05, 0, 0, 0.433, 0.567, 0, 0.475, 0.525],
};

function applyColorBlindFilter() {
  if (accessColorBlindMode === 'none') return;
  const filter = COLOR_BLIND_FILTERS[accessColorBlindMode];
  if (!filter) return;

  const imageData = ctx.getImageData(0, 0, GAME_W, GAME_H);
  const d = imageData.data;
  for (let i = 0; i < d.length; i += 4) {
    const r = d[i], g = d[i+1], b = d[i+2];
    d[i]   = Math.min(255, r * filter[0] + g * filter[1] + b * filter[2]);
    d[i+1] = Math.min(255, r * filter[3] + g * filter[4] + b * filter[5]);
    d[i+2] = Math.min(255, r * filter[6] + g * filter[7] + b * filter[8]);
  }
  ctx.putImageData(imageData, 0, 0);
}

function getAimAssistTarget(p) {
  if (!accessAimAssist || !p || p.dead) return null;
  let best = null, bestDist = 300;
  for (const e of enemies) {
    if (!e.active || e.hp <= 0) continue;
    const dx = (e.x + e.w/2) - (p.x + p.w/2);
    const dy = (e.y + e.h/2) - (p.y + p.h/2);
    const dist = Math.sqrt(dx*dx + dy*dy);
    if (dist < bestDist) { bestDist = dist; best = e; }
  }
  return best;
}

function applyAimAssist(p) {
  if (!accessAimAssist || !p || p.dead) return;
  const target = getAimAssistTarget(p);
  if (!target) return;
  const dx = (target.x + target.w/2) - (p.x + p.w/2);
  const dy = (target.y + target.h/2) - (p.y + p.h/2);
  const len = Math.sqrt(dx*dx + dy*dy);
  if (len < 1) return;
  const tx = dx / len, ty = dy / len;
  // Blend aim toward target
  p.aimX = p.aimX * (1 - accessAimAssistStrength) + tx * accessAimAssistStrength;
  p.aimY = p.aimY * (1 - accessAimAssistStrength) + ty * accessAimAssistStrength;
  // Renormalize
  const nl = Math.sqrt(p.aimX*p.aimX + p.aimY*p.aimY);
  if (nl > 0) { p.aimX /= nl; p.aimY /= nl; }
}

function drawAimAssistIndicator(p) {
  if (!accessAimAssist || !p || p.dead) return;
  const target = getAimAssistTarget(p);
  if (!target) return;
  const sx = target.x + target.w/2 - camX;
  const sy = target.y + target.h/2;
  ctx.strokeStyle = '#ff4444';
  ctx.lineWidth = 1;
  ctx.globalAlpha = 0.4 + Math.sin(Date.now() * 0.01) * 0.2;
  ctx.beginPath();
  ctx.arc(sx, sy, target.w * 0.8, 0, Math.PI * 2);
  ctx.stroke();
  // Crosshair lines
  const cs = target.w * 0.6;
  ctx.beginPath();
  ctx.moveTo(sx - cs, sy); ctx.lineTo(sx + cs, sy);
  ctx.moveTo(sx, sy - cs); ctx.lineTo(sx, sy + cs);
  ctx.stroke();
  ctx.globalAlpha = 1;
  ctx.lineWidth = 1;
}

function updateAccessibility() {
  // Infinite lives
  if (accessInfiniteLives && player && player.lives < 3) player.lives = 99;
  // Reduced screen shake
  if (accessScreenShakeReduced) {
    shakeIntensity *= 0.3;
  }
}

// ============================================================
//  MINI-BOSS AI UPDATE
// ============================================================
function updateMiniBossAI(e) {
  if (!e.isMiniBoss) return;
  const p = player;
  const dx = p.x - e.x;
  const dist = Math.abs(dx);
  e.facing = dx > 0 ? 1 : -1;
  e.mbTimer = (e.mbTimer || 0) + 1;

  switch (e.mbPattern) {
    case 'charge': {
      // Pause, then charge at player
      if (e.mbState === 'idle') {
        if (dist < e.shootRange && e.mbTimer > 60) {
          e.mbState = 'charging';
          e.mbTimer = 0;
          e.speed = 5;
        }
      } else if (e.mbState === 'charging') {
        e.x += e.facing * e.speed;
        if (e.mbTimer > 40 || dist < 10) {
          e.mbState = 'idle';
          e.mbTimer = 0;
          e.speed = 0;
          triggerShake(3, 5);
        }
      }
      break;
    }
    case 'shielded': {
      // Shield blocks frontal hits, vulnerable from behind
      e.shieldActive = (e.facing === -1 && p.x < e.x) || (e.facing === 1 && p.x > e.x);
      if (e.shieldActive) e.damageMult = 0.2; else e.damageMult = 1;
      // Slowly advance
      e.x += e.facing * 0.3;
      break;
    }
    case 'artillery': {
      // Lob arcing projectiles
      if (e.mbTimer % e.fireRate === 0 && dist < e.shootRange) {
        const angle = Math.atan2(p.y - e.y, p.x - e.x);
        enemyBullets.push({
          x: e.x + e.w/2, y: e.y,
          vx: Math.cos(angle) * 3,
          vy: -5,
          size: 5, color: '#aaff44', life: 120,
          isArc: true, gravity: 0.12,
        });
      }
      break;
    }
    case 'splitter': {
      // Normal movement, splits on death (handled in death code)
      e.x += e.facing * e.speed * 0.5;
      break;
    }
    case 'jumpstomp': {
      // Jump up and ground-pound
      if (e.mbState !== 'jumping' && e.onGround && e.mbTimer > 80 && dist < 200) {
        e.vy = -12;
        e.mbState = 'jumping';
        e.mbTimer = 0;
      }
      if (e.mbState === 'jumping' && e.onGround && e.mbTimer > 10) {
        // Ground pound impact
        triggerShake(6, 10);
        spawnParticles(e.x + e.w/2, e.y + e.h, '#ddaa44', 15, 4, 25);
        spawnRing(e.x + e.w/2, e.y + e.h, '#ddaa44', 30, 10);
        e.mbState = 'idle';
        e.mbTimer = 0;
        // Damage player if nearby
        if (dist < 60 && Math.abs(p.y - e.y) < 40) killPlayer(p);
      }
      break;
    }
  }

  // Regular shooting for non-charge/jumpstomp mini-bosses
  if (e.mbPattern !== 'charge' && e.mbPattern !== 'jumpstomp' &&
      e.fireRate > 0 && dist < e.shootRange) {
    e.fireTimer++;
    if (e.fireTimer >= e.fireRate) {
      e.fireTimer = 0;
      const angle = Math.atan2(p.y + p.h/2 - (e.y + e.h/2), p.x + p.w/2 - (e.x + e.w/2));
      const spd = (enemyBulletSpeed || 3) * (accessBulletTimeMult || 1);
      enemyBullets.push({
        x: e.x + e.w/2, y: e.y + e.h/2,
        vx: Math.cos(angle) * spd, vy: Math.sin(angle) * spd,
        size: 4, color: e.color, life: 120,
      });
    }
  }
}

// --- STAGE THEMES ---
const THEMES = {
  1: {
    name: 'JUNGLE', cols: 140,
    sky: [['#0a0a2e',0],['#1a1a4e',0.4],['#2a1a2e',0.7],['#0a0a1e',1]],
    mountains: ['#1a1a3e','#151530','#101025'],
    tileTop: '#44aa44', tileFill: '#886644', tileInner: '#776644', tileLine: '#665533',
    stars: 80, starBright: 0.7,
  },
  2: {
    name: 'RUINS', cols: 155,
    sky: [['#2e1a0a',0],['#4e2a1a',0.5],['#1e0a0a',1]],
    mountains: ['#3e2a1a','#302015','#251a10'],
    tileTop: '#998877', tileFill: '#887766', tileInner: '#776655', tileLine: '#665544',
    stars: 30, starBright: 0.4,
  },
  3: {
    name: 'WATER BASE', cols: 160,
    sky: [['#041428',0],['#0a2848',0.3],['#0c3050',0.6],['#062038',1]],
    mountains: ['#0a2040','#082838','#061828'],
    tileTop: '#2288aa', tileFill: '#446688', tileInner: '#335577', tileLine: '#2a4a66',
    stars: 20, starBright: 0.3,
    water: true,
  },
  4: {
    name: 'SPACE STATION', cols: 170,
    sky: [['#02020a',0],['#06061a',0.5],['#020210',1]],
    mountains: ['#111128','#0a0a20','#060618'],
    tileTop: '#8888aa', tileFill: '#555577', tileInner: '#444466', tileLine: '#333355',
    stars: 200, starBright: 1.0,
    space: true,
  },
  5: {
    name: 'DESERT', cols: 175,
    sky: [['#cc8844',0],['#ee9944',0.3],['#dd7733',0.6],['#aa5522',1]],
    mountains: ['#bb7733','#996622','#774411'],
    tileTop: '#ddcc88', tileFill: '#ccaa66', tileInner: '#bb9955', tileLine: '#aa8844',
    stars: 0, starBright: 0,
    desert: true,
  },
  6: {
    name: 'SNOW FORTRESS', cols: 180,
    sky: [['#aabbcc',0],['#8899bb',0.4],['#667799',0.7],['#445566',1]],
    mountains: ['#99aabb','#8899aa','#778899'],
    tileTop: '#eeeeff', tileFill: '#aabbcc', tileInner: '#99aabb', tileLine: '#8899aa',
    stars: 0, starBright: 0,
    snow: true,
  },
  7: {
    name: 'FINAL ASSAULT', cols: 210,
    sky: [['#1a0a2e',0],['#2e1a4e',0.3],['#4a1a2e',0.6],['#1a0a1e',1]],
    mountains: ['#2a1a3e','#201530','#1a1025'],
    tileTop: '#aa4444', tileFill: '#664444', tileInner: '#553333', tileLine: '#442222',
    stars: 60, starBright: 0.8,
  },
  8: {
    name: 'VOLCANO', cols: 190,
    sky: [['#2e0a00',0],['#5e1a00',0.3],['#8e2a00',0.6],['#2e0a00',1]],
    mountains: ['#4e1a00','#3e1500','#2e1000'],
    tileTop: '#883311', tileFill: '#552211', tileInner: '#441a0a', tileLine: '#331100',
    stars: 10, starBright: 0.3,
    lava: true,
  },
  9: {
    name: 'CYBER CORE', cols: 200,
    sky: [['#000a1e',0],['#001a3e',0.3],['#002a5e',0.6],['#000a1e',1]],
    mountains: ['#001a2e','#001528','#001020'],
    tileTop: '#00ccaa', tileFill: '#004444', tileInner: '#003333', tileLine: '#002222',
    stars: 120, starBright: 0.6,
    cyber: true,
  },
  10: {
    name: 'ALIEN HIVE', cols: 220,
    sky: [['#0a001e',0],['#1a0040',0.3],['#2a0060',0.5],['#1a0030',0.8],['#0a001e',1]],
    mountains: ['#1a0030','#150028','#100020'],
    tileTop: '#8844aa', tileFill: '#443366', tileInner: '#332255', tileLine: '#221144',
    stars: 80, starBright: 0.9,
    alien: true,
  },
  // --- SECRET STAGES ---
  11: {
    name: 'SHADOW REALM', cols: 250,
    sky: [['#000000',0],['#0a0014',0.3],['#140028',0.5],['#0a0014',0.8],['#000000',1]],
    mountains: ['#0a0018','#080012','#04000a'],
    tileTop: '#444466', tileFill: '#222233', tileInner: '#1a1a28', tileLine: '#111122',
    stars: 300, starBright: 1.0,
    secret: true,
  },
  12: {
    name: 'PARADISE LOST', cols: 280,
    sky: [['#ffddaa',0],['#ffcc88',0.2],['#ffaa66',0.5],['#ff8844',0.8],['#cc4422',1]],
    mountains: ['#dd8844','#cc7733','#aa5522'],
    tileTop: '#ffcc44', tileFill: '#ddaa22', tileInner: '#cc9911', tileLine: '#bb8800',
    stars: 0, starBright: 0,
    secret: true, paradise: true,
  },
};
const MAX_STAGE = 10;
const MAX_SECRET_STAGE = 12;

// Secret stage tracking
let secretsFound = {};
let returnFromSecretStage = 0; // which normal stage to return to after secret stage
try { secretsFound = JSON.parse(localStorage.getItem('contraForce_secrets') || '{}'); } catch(e) {}
function saveSecrets() { try { localStorage.setItem('contraForce_secrets', JSON.stringify(secretsFound)); } catch(e) {} }

function getTheme(s) { return THEMES[s] || THEMES[1]; }

// --- TREASURE TYPES ---
const DIG_TIME = 30; // frames to dig one tile
const TREASURES = {
  gem_small:  { label: 'üíé +500',     color: '#44ccff', score: 500 },
  gem_big:    { label: 'üíé +1500',    color: '#44ffcc', score: 1500 },
  gold:       { label: 'üí∞ +3000',    color: '#ffcc00', score: 3000 },
  shield:     { label: 'üõ°Ô∏è SHIELD',   color: '#88aaff', score: 200, effect: 'shield' },
  speed:      { label: '‚ö° SPEED UP',  color: '#ffff44', score: 100, effect: 'speed' },
  life:       { label: '‚ô• +1 LIFE',   color: '#ff4488', score: 0,   effect: 'life' },
  weapon:     { label: 'üî´ WEAPON!',  color: '#ff88ff', score: 100, effect: 'weapon' },
};
let treasureItems = []; // active treasure items bouncing in the world
let playerSpeedBoost = 0; // frames remaining of speed boost

// --- LEVEL GENERATION ---
const UNDERGROUND_ROWS = 50;

function generateLevel(stageNum) {
  const theme = getTheme(stageNum);
  const cols = theme.cols;
  const surfaceRows = Math.ceil(GAME_H / TILE);
  const rows = surfaceRows + UNDERGROUND_ROWS;
  const map = [];

  for (let r = 0; r < rows; r++) {
    map[r] = [];
    for (let c = 0; c < cols; c++) {
      map[r][c] = 0;
    }
  }

  // Ground surface + fill all underground solid
  const groundRow = surfaceRows - 2;
  for (let c = 0; c < cols; c++) {
    for (let r = groundRow; r < rows; r++) {
      map[r][c] = 1;
    }
  }

  const rng = seedRandom(stageNum * 12345);

  // Ground gaps (pits) ‚Äî cut through entire underground
  const gapChance = theme.water ? 0.05 : (theme.space ? 0.055 : 0.035);
  for (let c = 15; c < cols - 20; c++) {
    if (rng() < gapChance) {
      const gapW = (theme.water || theme.space) ? 2 + Math.floor(rng() * 3) : 2 + Math.floor(rng() * 1);
      for (let g = 0; g < gapW; g++) {
        if (c + g < cols) {
          for (let r = groundRow; r < rows; r++) {
            map[r][c + g] = 0;
          }
        }
      }
      c += gapW + 3;
    }
  }

  // Desert: dune-like raised terrain
  if (theme.desert) {
    for (let c = 8; c < cols - 10; c++) {
      if (rng() < 0.04) {
        const duneW = 6 + Math.floor(rng() * 8);
        const duneH = 1 + Math.floor(rng() * 2);
        for (let w = 0; w < duneW; w++) {
          const h = Math.round(Math.sin(w / duneW * Math.PI) * duneH);
          for (let dh = 0; dh < h; dh++) {
            if (c + w < cols && groundRow - 1 - dh >= 0)
              map[groundRow - 1 - dh][c + w] = 1;
          }
        }
        c += duneW + 3;
      }
    }
  }

  // Snow: ice bridges over gaps
  if (theme.snow) {
    for (let c = 20; c < cols - 20; c++) {
      if (rng() < 0.025) {
        const bridgeW = 4 + Math.floor(rng() * 4);
        const bridgeRow = groundRow - 2;
        for (let w = 0; w < bridgeW; w++) {
          if (c + w < cols) map[bridgeRow][c + w] = 1;
        }
        for (let w = 1; w < bridgeW - 1; w++) {
          if (c + w < cols) {
            for (let r = groundRow; r < rows; r++) {
              map[r][c + w] = 0;
            }
          }
        }
        c += bridgeW + 5;
      }
    }
  }

  // Space: more floating platforms, less ground
  if (theme.space) {
    for (let c = 10; c < cols - 10; c++) {
      if (rng() < 0.06) {
        const platRow = groundRow - 4 - Math.floor(rng() * 5);
        const platW = 2 + Math.floor(rng() * 3);
        for (let p = 0; p < platW; p++) {
          if (c + p < cols && platRow >= 1) map[platRow][c + p] = 1;
        }
        c += platW + 2;
      }
    }
  }

  // Volcano: jagged volcanic pillars and lava pools
  if (theme.lava) {
    // Volcanic pillars
    for (let c = 12; c < cols - 12; c++) {
      if (rng() < 0.04) {
        const pillarH = 3 + Math.floor(rng() * 4);
        const pillarW = 1 + Math.floor(rng() * 2);
        for (let h = 0; h < pillarH; h++) {
          for (let w = 0; w < pillarW; w++) {
            if (c + w < cols && groundRow - 1 - h >= 0)
              map[groundRow - 1 - h][c + w] = 1;
          }
        }
        c += pillarW + 4;
      }
    }
    // Lava flow gaps (wider pits that will fill with lava)
    for (let c = 20; c < cols - 25; c++) {
      if (rng() < 0.04) {
        const lavaW = 3 + Math.floor(rng() * 4);
        for (let g = 0; g < lavaW; g++) {
          if (c + g < cols) {
            for (let r = groundRow; r < rows; r++) map[r][c + g] = 0;
          }
        }
        c += lavaW + 6;
      }
    }
  }

  // Cyber Core: geometric grid platforms and data columns
  if (theme.cyber) {
    // Grid platforms (evenly spaced)
    for (let c = 10; c < cols - 10; c += 8 + Math.floor(rng() * 6)) {
      if (rng() < 0.55) {
        const platRow = groundRow - 3 - Math.floor(rng() * 5);
        const platW = 3 + Math.floor(rng() * 2);
        for (let p = 0; p < platW; p++) {
          if (c + p < cols && platRow >= 1) map[platRow][c + p] = 1;
        }
      }
    }
    // Data columns (thin tall pillars)
    for (let c = 15; c < cols - 15; c++) {
      if (rng() < 0.02) {
        const colH = 4 + Math.floor(rng() * 4);
        for (let h = 0; h < colH; h++) {
          if (groundRow - 1 - h >= 0) map[groundRow - 1 - h][c] = 1;
        }
        c += 6;
      }
    }
    // Circuit gaps (precise 2-wide pits)
    for (let c = 18; c < cols - 18; c++) {
      if (rng() < 0.03) {
        for (let r = groundRow; r < rows; r++) {
          map[r][c] = 0;
          if (c + 1 < cols) map[r][c + 1] = 0;
        }
        c += 8;
      }
    }
  }

  // Alien Hive: organic bumpy terrain and hive chambers
  if (theme.alien) {
    // Organic bumps (sinusoidal raised terrain)
    for (let c = 8; c < cols - 10; c++) {
      if (rng() < 0.05) {
        const bumpW = 8 + Math.floor(rng() * 10);
        const bumpH = 2 + Math.floor(rng() * 2);
        for (let w = 0; w < bumpW; w++) {
          const h = Math.round(Math.sin(w / bumpW * Math.PI) * bumpH);
          for (let dh = 0; dh < h; dh++) {
            if (c + w < cols && groundRow - 1 - dh >= 0)
              map[groundRow - 1 - dh][c + w] = 1;
          }
        }
        c += bumpW + 2;
      }
    }
    // Hive chambers (above-ground hollowed structures)
    for (let c = 20; c < cols - 25; c++) {
      if (rng() < 0.025) {
        const chW = 5 + Math.floor(rng() * 4);
        const chH = 4 + Math.floor(rng() * 3);
        // Build walls and roof
        for (let w = 0; w < chW; w++) {
          if (c + w < cols && groundRow - chH >= 0)
            map[groundRow - chH][c + w] = 1; // roof
        }
        for (let h = 0; h < chH; h++) {
          if (groundRow - h >= 0) {
            if (c < cols) map[groundRow - h][c] = 1; // left wall
            if (c + chW - 1 < cols) map[groundRow - h][c + chW - 1] = 1; // right wall
          }
        }
        // Entrance gap
        const mid = c + Math.floor(chW / 2);
        if (mid < cols) map[groundRow - 1][mid] = 0;
        c += chW + 6;
      }
    }
    // Hanging platforms (stalactite-like)
    for (let c = 12; c < cols - 12; c++) {
      if (rng() < 0.03) {
        const platRow = groundRow - 5 - Math.floor(rng() * 4);
        const platW = 2 + Math.floor(rng() * 3);
        for (let p = 0; p < platW; p++) {
          if (c + p < cols && platRow >= 1) {
            map[platRow][c + p] = 1;
            if (platRow - 1 >= 0) map[platRow - 1][c + p] = 1; // thicker
          }
        }
        c += platW + 4;
      }
    }
  }

  // Raised ground sections (terrain elevation)
  for (let c = 12; c < cols - 15; c++) {
    if (rng() < 0.03) {
      const raisedW = 4 + Math.floor(rng() * 6);
      const raisedH = 1 + Math.floor(rng() * 2);
      for (let h = 0; h < raisedH; h++) {
        for (let w = h; w < raisedW - h; w++) {
          if (c + w < cols && groundRow - 1 - h >= 0) {
            map[groundRow - 1 - h][c + w] = 1;
          }
        }
      }
      c += raisedW + 3;
    }
  }

  // Low platforms
  for (let c = 8; c < cols - 10; c++) {
    if (rng() < 0.07) {
      const platRow = groundRow - 2 - Math.floor(rng() * 3);
      const platW = 2 + Math.floor(rng() * 4);
      for (let p = 0; p < platW; p++) {
        if (c + p < cols && platRow >= 0) {
          map[platRow][c + p] = 1;
        }
      }
      c += platW + 2;
    }
  }

  // Mid platforms
  for (let c = 8; c < cols - 10; c++) {
    if (rng() < 0.05) {
      const platRow = groundRow - 4 - Math.floor(rng() * 3);
      const platW = 3 + Math.floor(rng() * 4);
      for (let p = 0; p < platW; p++) {
        if (c + p < cols && platRow >= 0) {
          map[platRow][c + p] = 1;
        }
      }
      c += platW + 3;
    }
  }

  // Walls / structures
  for (let c = 15; c < cols - 15; c++) {
    if (rng() < 0.025) {
      const wallH = 1 + Math.floor(rng() * 2);
      for (let h = 0; h < wallH; h++) {
        if (groundRow - 1 - h >= 0) {
          map[groundRow - 1 - h][c] = 1;
          if (rng() < 0.5) map[groundRow - 1 - h][c + 1] = 1;
        }
      }
      c += 4;
    }
  }

  // Bunkers
  for (let c = 20; c < cols - 25; c++) {
    if (rng() < 0.015) {
      const bw = 4 + Math.floor(rng() * 3);
      const bh = 2;
      for (let w = 0; w < bw; w++) {
        for (let h = 0; h < bh; h++) {
          if (c + w < cols && groundRow - 1 - h >= 0) {
            map[groundRow - 1 - h][c + w] = 1;
          }
        }
      }
      if (bw >= 4) {
        map[groundRow - 1][c + Math.floor(bw / 2)] = 0;
      }
      c += bw + 5;
    }
  }

  // Upper platforms (high)
  for (let c = 12; c < cols - 10; c++) {
    if (rng() < 0.04) {
      const platRow = groundRow - 6 - Math.floor(rng() * 3);
      const platW = 2 + Math.floor(rng() * 3);
      for (let p = 0; p < platW; p++) {
        if (c + p < cols && platRow >= 1) {
          map[platRow][c + p] = 1;
        }
      }
      c += platW + 4;
    }
  }

  // Staircase structures
  for (let c = 18; c < cols - 20; c++) {
    if (rng() < 0.015) {
      const stairDir = rng() < 0.5 ? 1 : -1;
      const steps = 3 + Math.floor(rng() * 3);
      for (let s = 0; s < steps; s++) {
        const sc = stairDir === 1 ? c + s : c + (steps - 1 - s);
        if (sc >= 0 && sc < cols && groundRow - 1 - s >= 0) {
          map[groundRow - 1 - s][sc] = 1;
        }
      }
      c += steps + 4;
    }
  }

  // --- UNDERGROUND FEATURES ---

  // Caves (air pockets underground)
  for (let c = 4; c < cols - 4; c++) {
    if (rng() < 0.02) {
      const caveRow = groundRow + 3 + Math.floor(rng() * (UNDERGROUND_ROWS - 8));
      const caveW = 3 + Math.floor(rng() * 5);
      const caveH = 2 + Math.floor(rng() * 3);
      for (let cr = 0; cr < caveH; cr++) {
        for (let cc = 0; cc < caveW; cc++) {
          const r = caveRow + cr;
          const col = c + cc;
          if (r > groundRow && r < rows - 1 && col > 0 && col < cols - 1) {
            // Elliptical shape
            const dx = (cc - caveW / 2) / (caveW / 2);
            const dy = (cr - caveH / 2) / (caveH / 2);
            if (dx * dx + dy * dy < 1) {
              map[r][col] = 0;
            }
          }
        }
      }
      c += caveW + 2;
    }
  }

  // Underground tunnels (horizontal passages)
  for (let i = 0; i < Math.floor(cols / 30); i++) {
    if (rng() < 0.4) {
      const tunnelRow = groundRow + 5 + Math.floor(rng() * (UNDERGROUND_ROWS - 12));
      const tunnelStart = 2 + Math.floor(rng() * (cols - 20));
      const tunnelLen = 6 + Math.floor(rng() * 12);
      for (let tc = tunnelStart; tc < Math.min(cols - 1, tunnelStart + tunnelLen); tc++) {
        if (tunnelRow > groundRow + 1 && tunnelRow < rows - 2) {
          map[tunnelRow][tc] = 0;
          // 2-tile high tunnel
          if (tunnelRow - 1 > groundRow) map[tunnelRow - 1][tc] = 0;
        }
      }
    }
  }

  // Vertical shafts (connect surface to underground)
  for (let c = 8; c < cols - 8; c++) {
    if (rng() < 0.012) {
      const shaftDepth = 5 + Math.floor(rng() * 15);
      for (let r = groundRow; r < Math.min(rows - 1, groundRow + shaftDepth); r++) {
        if (map[r][c] === 1) map[r][c] = 0;
      }
      c += 8;
    }
  }

  // --- LADDERS ---
  // Surface ladders
  for (let c = 2; c < cols - 2; c++) {
    for (let r = 1; r < groundRow; r++) {
      if (map[r][c] === 1 && r + 1 < rows && map[r + 1][c] === 0) {
        let hasGap = false;
        let groundBelow = -1;
        for (let below = r + 1; below < rows; below++) {
          if (map[below][c] === 1) {
            groundBelow = below;
            break;
          }
          hasGap = true;
        }
        if (hasGap && groundBelow > r + 2 && groundBelow !== -1) {
          if (rng() < 0.5) {
            for (let lr = r + 1; lr < groundBelow; lr++) {
              if (map[lr][c] === 0) map[lr][c] = 2;
            }
            c += 4;
            break;
          }
        }
      }
    }
  }

  // Underground ladders (in shafts and caves)
  for (let c = 4; c < cols - 4; c++) {
    for (let r = groundRow; r < rows - 3; r++) {
      if (map[r][c] === 1 && r + 1 < rows && map[r + 1][c] === 0) {
        let groundBelow = -1;
        for (let below = r + 1; below < Math.min(rows, r + 20); below++) {
          if (map[below][c] === 1) { groundBelow = below; break; }
        }
        if (groundBelow > r + 2 && groundBelow !== -1) {
          if (rng() < 0.6) {
            for (let lr = r + 1; lr < groundBelow; lr++) {
              if (map[lr][c] === 0) map[lr][c] = 2;
            }
            c += 6;
          }
        }
      }
    }
  }

  // --- BURIED TREASURE ---
  // tile val 4 = solid with buried treasure (behaves like solid, sparkles subtly)
  const treasureMap = {};

  // Shallow treasure (near surface, common, lower value)
  for (let c = 5; c < cols - 5; c++) {
    if (rng() < 0.04) {
      const depth = groundRow + 1 + Math.floor(rng() * 4);
      if (depth < rows && map[depth][c] === 1) {
        map[depth][c] = 4;
        const tRoll = rng();
        let ttype;
        if (tRoll < 0.40) ttype = 'gem_small';
        else if (tRoll < 0.65) ttype = 'gem_big';
        else if (tRoll < 0.80) ttype = 'shield';
        else if (tRoll < 0.90) ttype = 'speed';
        else ttype = 'life';
        treasureMap[depth + ',' + c] = ttype;
      }
      c += 3;
    }
  }

  // Medium depth treasure (5-20 rows down, moderate)
  for (let c = 3; c < cols - 3; c++) {
    if (rng() < 0.03) {
      const depth = groundRow + 5 + Math.floor(rng() * 15);
      if (depth < rows && map[depth][c] === 1) {
        map[depth][c] = 4;
        const tRoll = rng();
        let ttype;
        if (tRoll < 0.25) ttype = 'gem_big';
        else if (tRoll < 0.50) ttype = 'gold';
        else if (tRoll < 0.65) ttype = 'shield';
        else if (tRoll < 0.80) ttype = 'weapon';
        else if (tRoll < 0.90) ttype = 'life';
        else ttype = 'speed';
        treasureMap[depth + ',' + c] = ttype;
      }
      c += 4;
    }
  }

  // Deep treasure (20-45 rows down, rare, high value)
  for (let c = 3; c < cols - 3; c++) {
    if (rng() < 0.025) {
      const depth = groundRow + 20 + Math.floor(rng() * 25);
      if (depth < rows - 1 && map[depth][c] === 1) {
        map[depth][c] = 4;
        const tRoll = rng();
        let ttype;
        if (tRoll < 0.40) ttype = 'gold';
        else if (tRoll < 0.60) ttype = 'weapon';
        else if (tRoll < 0.80) ttype = 'life';
        else ttype = 'gem_big';
        treasureMap[depth + ',' + c] = ttype;
      }
      c += 5;
    }
  }

  // --- WATER FILL ---
  // Water only at surface level (in gaps)
  if (theme.water) {
    for (let c = 0; c < cols; c++) {
      if (map[groundRow][c] === 0) map[groundRow][c] = 3;
      if (groundRow + 1 < rows && map[groundRow + 1][c] === 0) map[groundRow + 1][c] = 3;
    }
  }

  // --- LAVA FILL ---
  // Lava fills surface gaps in volcano theme (uses tile 3 visually, rendered as lava by theme)
  if (theme.lava) {
    for (let c = 0; c < cols; c++) {
      if (map[groundRow][c] === 0) map[groundRow][c] = 3;
      if (groundRow + 1 < rows && map[groundRow + 1][c] === 0) map[groundRow + 1][c] = 3;
    }
  }

  return { map, cols, rows, groundRow, treasureMap };
}

function seedRandom(seed) {
  let s = seed;
  return function() {
    s = (s * 1664525 + 1013904223) & 0xffffffff;
    return (s >>> 0) / 0xffffffff;
  };
}

// --- WEAPON TYPES ---
const WEAPONS = {
  RIFLE:   { name: 'RIFLE',   fireRate: 8,  damage: 1, bullets: 1, spread: 0,    color: '#ffff00', size: 3, type: 'normal' },
  SPREAD:  { name: 'SPREAD',  fireRate: 12, damage: 1, bullets: 5, spread: 0.3,  color: '#ff8800', size: 3, type: 'normal' },
  LASER:   { name: 'LASER',   fireRate: 4,  damage: 2, bullets: 1, spread: 0,    color: '#00ffff', size: 5, type: 'pierce' },
  MACHINE: { name: 'MACHINE', fireRate: 3,  damage: 1, bullets: 1, spread: 0.05, color: '#ff4444', size: 2, type: 'normal' },
  FLAME:   { name: 'FLAME',   fireRate: 2,  damage: 0.5, bullets: 1, spread: 0.15, color: '#ff6600', size: 4, type: 'flame' },
  ROCKET:  { name: 'ROCKET',  fireRate: 30, damage: 5, bullets: 1, spread: 0,    color: '#ff2222', size: 6, type: 'rocket' },
  HOMING:  { name: 'HOMING',  fireRate: 14, damage: 2, bullets: 1, spread: 0,    color: '#ff44ff', size: 4, type: 'homing' },
  WAVE:    { name: 'WAVE',    fireRate: 10, damage: 1.5, bullets: 2, spread: 0,  color: '#44ff88', size: 4, type: 'wave' },
  LIGHTNING: { name: 'LIGHTNING', fireRate: 12, damage: 1.5, bullets: 1, spread: 0, color: '#88eeff', size: 3, type: 'lightning' },
  BOOMERANG: { name: 'BOOMERANG', fireRate: 20, damage: 2,  bullets: 1, spread: 0, color: '#ffdd44', size: 5, type: 'boomerang' },
  BLACKHOLE: { name: 'BLACKHOLE', fireRate: 40, damage: 0.5, bullets: 1, spread: 0, color: '#9944ff', size: 8, type: 'blackhole' },
  MINE:      { name: 'MINE',     fireRate: 25, damage: 4,   bullets: 1, spread: 0, color: '#ff8888', size: 5, type: 'mine' },
};

// --- VEHICLE DEFINITIONS ---
const VEHICLES = {
  HOVERBIKE: {
    name: 'HOVERBIKE', hp: 8, speed: 6, jumpForce: -9,
    w: 48, h: 24, color: '#44ccff',
    fireRate: 6, damage: 2, bulletSpeed: 14, bulletColor: '#88eeff',
    desc: 'Fast hover vehicle ‚Äî double speed, rapid fire!'
  },
  TANK: {
    name: 'TANK', hp: 20, speed: 2.5, jumpForce: -6,
    w: 56, h: 32, color: '#88aa55',
    fireRate: 20, damage: 6, bulletSpeed: 10, bulletColor: '#ffcc44',
    desc: 'Heavy tank ‚Äî massive armor, explosive shells!'
  }
};
let vehiclePickups = [];

// --- UNLOCKABLE CHARACTERS ---
const CHARACTERS = {
  COMMANDO: {
    name: 'COMMANDO',
    desc: 'Balanced all-rounder',
    color: '#338833',
    speedMult: 1.0,
    damageMult: 1.0,
    livesBonus: 0,
    startWeapon: 'RIFLE',
    ability: null,
    unlockDesc: 'Available from start',
    unlocked: true
  },
  SCOUT: {
    name: 'SCOUT',
    desc: 'Fast & agile ‚Äî machine gun start',
    color: '#33cccc',
    speedMult: 1.35,
    damageMult: 0.85,
    livesBonus: -1,
    startWeapon: 'MACHINE',
    ability: 'doubleJump',
    unlockDesc: 'Beat Stage 3',
    unlocked: false
  },
  HEAVY: {
    name: 'HEAVY',
    desc: 'Tough & resilient ‚Äî extra lives',
    color: '#cc6633',
    speedMult: 0.8,
    damageMult: 1.0,
    livesBonus: 2,
    startWeapon: 'RIFLE',
    ability: 'damageResist',
    unlockDesc: 'Beat Stage 5',
    unlocked: false
  },
  GHOST: {
    name: 'GHOST',
    desc: 'Glass cannon ‚Äî double damage, fragile',
    color: '#cc33cc',
    speedMult: 1.0,
    damageMult: 2.0,
    livesBonus: -2,
    startWeapon: 'SPREAD',
    ability: null,
    unlockDesc: 'Beat the game',
    unlocked: false
  },
  NINJA: {
    name: 'NINJA',
    desc: 'Silent & swift ‚Äî wall master',
    color: '#333366',
    speedMult: 1.2,
    damageMult: 0.9,
    livesBonus: 0,
    startWeapon: 'WAVE',
    ability: 'wallMaster',
    unlockDesc: 'Find a secret stage',
    unlocked: false
  },
  PYRO: {
    name: 'PYRO',
    desc: 'Fire specialist ‚Äî flame start',
    color: '#cc3333',
    speedMult: 1.0,
    damageMult: 1.1,
    livesBonus: 0,
    startWeapon: 'FLAME',
    ability: 'fireResist',
    unlockDesc: 'Kill 500 enemies total',
    unlocked: false
  }
};

let selectedCharacter = 'COMMANDO';
let selectedCharacter2 = 'COMMANDO';
let unlockedCharacters = {};
try { unlockedCharacters = JSON.parse(localStorage.getItem('contraForce_characters') || '{}'); } catch(e) {}
function saveCharacterUnlocks() { try { localStorage.setItem('contraForce_characters', JSON.stringify(unlockedCharacters)); } catch(e) {} }
function isCharUnlocked(id) { return CHARACTERS[id].unlocked || unlockedCharacters[id]; }
function unlockCharacter(id) {
  if (!unlockedCharacters[id]) {
    unlockedCharacters[id] = true;
    saveCharacterUnlocks();
  }
}

// Check unlock conditions (called periodically)
function checkCharacterUnlocks() {
  // SCOUT: beat stage 3
  if (stage > 3) unlockCharacter('SCOUT');
  // HEAVY: beat stage 5
  if (stage > 5) unlockCharacter('HEAVY');
  // GHOST: beat the game (stage > MAX_STAGE checked at victory)
  // NINJA: find a secret stage
  if (Object.keys(secretsFound).length > 0) unlockCharacter('NINJA');
  // PYRO: 500 total kills
  const totalKills = parseInt(localStorage.getItem('contraForce_totalKills') || '0');
  if (totalKills >= 500) unlockCharacter('PYRO');
}

// --- PARTICLE SYSTEM ---
let particles = [];

function spawnParticles(x, y, color, count, speed, life) {
  for (let i = 0; i < count; i++) {
    const angle = Math.random() * Math.PI * 2;
    const spd = Math.random() * speed;
    particles.push({
      x, y,
      vx: Math.cos(angle) * spd,
      vy: Math.sin(angle) * spd - 1,
      life: Math.random() * life,
      maxLife: life,
      color,
      size: 1 + Math.random() * 3,
      type: 'normal',
    });
  }
}

// Glowing ember particles
function spawnGlowParticles(x, y, color, count, speed, life) {
  for (let i = 0; i < count; i++) {
    const angle = Math.random() * Math.PI * 2;
    const spd = 0.5 + Math.random() * speed;
    particles.push({
      x, y,
      vx: Math.cos(angle) * spd,
      vy: Math.sin(angle) * spd - 2,
      life: life * 0.5 + Math.random() * life * 0.5,
      maxLife: life,
      color,
      size: 2 + Math.random() * 4,
      type: 'glow',
    });
  }
}

// Ring explosion
function spawnRing(x, y, color, radius, count) {
  for (let i = 0; i < count; i++) {
    const angle = (Math.PI * 2 / count) * i;
    particles.push({
      x, y,
      vx: Math.cos(angle) * radius * 0.15,
      vy: Math.sin(angle) * radius * 0.15,
      life: 20,
      maxLife: 20,
      color,
      size: 3,
      type: 'ring',
    });
  }
}

// Debris chunks
function spawnDebris(x, y, color, count) {
  for (let i = 0; i < count; i++) {
    const angle = Math.random() * Math.PI * 2;
    const spd = 2 + Math.random() * 5;
    particles.push({
      x, y,
      vx: Math.cos(angle) * spd,
      vy: Math.sin(angle) * spd - 3,
      life: 30 + Math.random() * 30,
      maxLife: 60,
      color,
      size: 3 + Math.random() * 5,
      type: 'debris',
      rot: Math.random() * 6.28,
      rotSpd: (Math.random() - 0.5) * 0.3,
    });
  }
}

function updateParticles() {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    if (p.type === 'debris') {
      p.vy += 0.2;
      p.rot += p.rotSpd;
    } else if (p.type === 'ring') {
      p.vx *= 0.92;
      p.vy *= 0.92;
    } else if (p.type === 'glow') {
      p.vy -= 0.02; // float up
      p.vx *= 0.98;
    } else {
      p.vy += 0.1;
    }
    p.life--;
    if (p.life <= 0) particles.splice(i, 1);
  }
}

function drawParticles(camX) {
  for (const p of particles) {
    const alpha = Math.min(1, p.life / p.maxLife * 1.5);
    const sx = p.x - camX;

    if (p.type === 'glow') {
      // Glowing particle with bloom
      ctx.globalAlpha = alpha * 0.3;
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(sx, p.y, p.size * 2.5, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = alpha;
      ctx.beginPath();
      ctx.arc(sx, p.y, p.size, 0, Math.PI * 2);
      ctx.fill();
    } else if (p.type === 'ring') {
      ctx.globalAlpha = alpha;
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(sx, p.y, p.size, 0, Math.PI * 2);
      ctx.fill();
    } else if (p.type === 'debris') {
      ctx.globalAlpha = alpha;
      ctx.fillStyle = p.color;
      ctx.save();
      ctx.translate(sx, p.y);
      ctx.rotate(p.rot);
      ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size);
      ctx.restore();
    } else {
      ctx.globalAlpha = alpha;
      ctx.fillStyle = p.color;
      ctx.fillRect(sx, p.y, p.size, p.size);
    }
  }
  ctx.globalAlpha = 1;
}

// --- PLAYER ---
let player;
let player2; // Second player in co-op mode

function createPlayer(startX = 60, charId = 'COMMANDO') {
  const char = CHARACTERS[charId] || CHARACTERS.COMMANDO;
  return {
    x: startX, y: 0,
    w: 20, h: 32,
    vx: 0, vy: 0,
    onGround: false,
    facing: 1,
    aimX: 1, aimY: 0,
    weapon: WEAPONS[char.startWeapon] || WEAPONS.RIFLE,
    fireTimer: 0,
    lives: Math.max(1, diffSettings.lives + char.livesBonus),
    invincible: 0,
    dead: false,
    respawnTimer: 0,
    animFrame: 0,
    animTimer: 0,
    prone: false,
    shooting: false,
    onLadder: false,
    climbFrame: 0,
    digTimer: 0,
    digging: false,
    digCol: -1,
    digRow: -1,
    digDirX: 0,
    digDirY: 1,
    // Wall climbing
    wallClimbing: false,
    wallClimbDir: 0,
    wallClimbFrame: 0,
    // Grapple hook
    grapple: null,
    grappleCooldown: 0,
    // Vehicle
    inVehicle: false,
    vehicleType: null,
    vehicleHP: 0,
    vehicleMaxHP: 0,
    vehicleFireTimer: 0,
    vehicleHitFlash: 0,
    // Character
    charId: charId,
    speedMult: char.speedMult,
    damageMult: char.damageMult,
    ability: char.ability,
    charColor: char.color,
  };
}

// --- ENEMIES ---
let enemies = [];
let enemyBullets = [];

const ENEMY_TYPES = {
  SOLDIER: { w: 18, h: 30, hp: 2, speed: 1, score: 100, color: '#cc4444', fireRate: 90, shootRange: 300, etype: 'soldier' },
  RUNNER:  { w: 18, h: 28, hp: 1, speed: 2.5, score: 150, color: '#cc8844', fireRate: 0, shootRange: 0, etype: 'runner' },
  TURRET:  { w: 24, h: 24, hp: 4, speed: 0, score: 200, color: '#888888', fireRate: 50, shootRange: 400, etype: 'turret' },
  SNIPER:  { w: 18, h: 30, hp: 2, speed: 0.5, score: 250, color: '#4444cc', fireRate: 120, shootRange: 500, etype: 'sniper' },
  HEAVY:   { w: 26, h: 34, hp: 6, speed: 0.8, score: 300, color: '#884488', fireRate: 40, shootRange: 250, etype: 'heavy' },
  BOMBER:  { w: 20, h: 28, hp: 3, speed: 0.6, score: 250, color: '#448844', fireRate: 80, shootRange: 200, etype: 'bomber' },
  JUMPER:  { w: 18, h: 26, hp: 2, speed: 2, score: 200, color: '#cc8800', fireRate: 0, shootRange: 0, etype: 'jumper' },
  SHIELD:  { w: 22, h: 32, hp: 8, speed: 0.7, score: 350, color: '#4488aa', fireRate: 70, shootRange: 280, etype: 'shield' },
  DRONE:   { w: 20, h: 16, hp: 2, speed: 1.5, score: 200, color: '#88ccee', fireRate: 60, shootRange: 350, etype: 'drone', flying: true },
  TELEPORTER: { w: 18, h: 30, hp: 3, speed: 0, score: 300, color: '#bb44ff', fireRate: 80, shootRange: 320, etype: 'teleporter' },
  CLOAKER: { w: 18, h: 28, hp: 2, speed: 1.2, score: 250, color: '#446666', fireRate: 70, shootRange: 250, etype: 'cloaker' },
  SHIELDPAIR: { w: 24, h: 30, hp: 5, speed: 0.8, score: 400, color: '#cc8844', fireRate: 60, shootRange: 280, etype: 'shieldpair' },
};

function spawnEnemies(level, stageNum) {
  enemies = [];
  const rng = seedRandom(stageNum * 54321);
  const { cols, groundRow } = level;
  const diffMult = Math.min(2.2, 0.7 + stageNum * 0.2); // gradual difficulty across 7 stages

  for (let c = 10; c < cols - 15; c++) {
    if (rng() < 0.065 * diffMult * diffSettings.enemySpawnMult) {
      const typeRoll = rng();
      let type;
      if (typeRoll < 0.16) type = ENEMY_TYPES.SOLDIER;
      else if (typeRoll < 0.26) type = ENEMY_TYPES.RUNNER;
      else if (typeRoll < 0.34) type = ENEMY_TYPES.TURRET;
      else if (typeRoll < 0.42) type = ENEMY_TYPES.SNIPER;
      else if (typeRoll < 0.50) type = ENEMY_TYPES.HEAVY;
      else if (typeRoll < 0.58) type = ENEMY_TYPES.BOMBER;
      else if (typeRoll < 0.66) type = ENEMY_TYPES.JUMPER;
      else if (typeRoll < 0.74) type = ENEMY_TYPES.SHIELD;
      else if (typeRoll < 0.80) type = ENEMY_TYPES.DRONE;
      else if (typeRoll < 0.86) type = ENEMY_TYPES.TELEPORTER;
      else if (typeRoll < 0.93) type = ENEMY_TYPES.CLOAKER;
      else type = ENEMY_TYPES.SHIELDPAIR;

      // Find ground y (or sky y for flying)
      let ey = 0;
      if (type.flying) {
        // Drones spawn in the air
        ey = (2 + Math.floor(rng() * 4)) * TILE;
      } else {
        for (let r = 0; r < level.rows; r++) {
          if (level.map[r][c] === 1) {
            ey = r * TILE - type.h;
            break;
          }
        }
      }
      if (ey > 0 || type.flying) {
        const scaledHp = Math.round(type.hp * diffSettings.enemyHpMult);
        const scaledFireRate = Math.max(10, Math.round(type.fireRate * diffSettings.enemyFireRateMult));
        enemies.push({
          x: c * TILE, y: ey,
          ...type,
          hp: scaledHp,
          maxHp: scaledHp,
          fireRate: scaledFireRate,
          fireTimer: Math.floor(rng() * scaledFireRate),
          active: false,
          facing: -1,
          patrolStart: (c - 5) * TILE,
          patrolEnd: (c + 5) * TILE,
          dir: rng() < 0.5 ? 1 : -1,
          vy: 0,
          onGround: false,
          jumpTimer: 0,
          shieldFacing: -1,
          teleportTimer: 0,
          cloakAlpha: 1,
          pairBuddy: null,
          pairOffset: 0,
          flyY: ey,
          flyPhase: rng() * Math.PI * 2,
        });
      }
      c += 3;
    }
  }

  // Boss at end
  const bossX = (cols - 8) * TILE;
  let bossY = 0;
  for (let r = 0; r < level.rows; r++) {
    if (level.map[r][cols - 8] === 1) { bossY = r * TILE - 64; break; }
  }
  enemies.push({
    x: bossX, y: bossY,
    w: 48, h: 64,
    hp: Math.round((30 + stageNum * 15) * diffSettings.bossHpMult),
    maxHp: Math.round((30 + stageNum * 15) * diffSettings.bossHpMult),
    speed: 1,
    score: 2000,
    color: '#ff2222',
    fireRate: 25,
    fireTimer: 0,
    shootRange: 500,
    active: false,
    facing: -1,
    isBoss: true,
    etype: 'boss',
    patrolStart: (cols - 12) * TILE,
    patrolEnd: (cols - 5) * TILE,
    dir: -1,
    phase: 0,
    phaseTimer: 0,
    vy: 0,
    onGround: false,
  });
}

// --- POWERUPS ---
let powerups = [];

function spawnPowerups(level, stageNum) {
  powerups = [];
  const rng = seedRandom(stageNum * 99999);
  const { cols, groundRow } = level;

  for (let c = 10; c < cols - 10; c++) {
    if (rng() < 0.025 * diffSettings.powerupSpawnMult) {
      const typeRoll = rng();
      let type;
      if (typeRoll < 0.10) type = 'SPREAD';
      else if (typeRoll < 0.18) type = 'LASER';
      else if (typeRoll < 0.26) type = 'MACHINE';
      else if (typeRoll < 0.33) type = 'FLAME';
      else if (typeRoll < 0.40) type = 'ROCKET';
      else if (typeRoll < 0.47) type = 'HOMING';
      else if (typeRoll < 0.54) type = 'WAVE';
      else if (typeRoll < 0.60) type = 'LIGHTNING';
      else if (typeRoll < 0.66) type = 'BOOMERANG';
      else if (typeRoll < 0.72) type = 'BLACKHOLE';
      else if (typeRoll < 0.78) type = 'MINE';
      else type = 'LIFE';

      let py = 0;
      for (let r = 0; r < level.rows; r++) {
        if (level.map[r][c] === 1) { py = r * TILE - 48; break; }
      }
      if (py > 0) {
        powerups.push({
          x: c * TILE, y: py,
          w: 20, h: 20,
          type,
          bobPhase: rng() * Math.PI * 2,
        });
      }
      c += 7;
    }
  }
}

// --- BULLETS ---
let bullets = [];

// --- DESTRUCTIBLE OBJECTS ---
let objects = []; // crates, barrels, sandbags

function spawnObjects(level, stageNum) {
  objects = [];
  const rng = seedRandom(stageNum * 77777);
  const { cols, groundRow } = level;

  for (let c = 8; c < cols - 10; c++) {
    if (rng() < 0.05) {
      const roll = rng();
      let otype, ow, oh, hp, ocolor;
      if (roll < 0.3) {
        otype = 'crate'; ow = 24; oh = 24; hp = 3; ocolor = '#aa8844';
      } else if (roll < 0.55) {
        otype = 'barrel'; ow = 20; oh = 26; hp = 2; ocolor = '#666666';
      } else if (roll < 0.75) {
        otype = 'sandbag'; ow = 28; oh = 18; hp = 6; ocolor = '#998866';
      } else {
        otype = 'explbarrel'; ow = 20; oh = 26; hp = 1; ocolor = '#cc3333';
      }
      // Find ground
      let oy = 0;
      for (let r = 0; r < level.rows; r++) {
        if (level.map[r][c] === 1) { oy = r * TILE - oh; break; }
      }
      if (oy > 0) {
        objects.push({ x: c * TILE + 4, y: oy, w: ow, h: oh, hp, maxHp: hp, type: otype, color: ocolor });
      }
      c += 3;
    }
  }
}

// --- VEHICLE PICKUPS ---
function spawnVehicles(level, stageNum) {
  vehiclePickups = [];
  // Vehicles appear on stages 3, 5, 7, 9 (every other stage from 3)
  if (stageNum < 3 || stageNum % 2 === 0) return;
  const rng = seedRandom(stageNum * 55555);
  const { cols, groundRow } = level;
  // Place 1-2 vehicles per eligible stage
  const count = stageNum >= 7 ? 2 : 1;
  for (let v = 0; v < count; v++) {
    const col = 30 + Math.floor(rng() * (cols - 80)) + v * 40;
    const vType = rng() < 0.5 ? 'HOVERBIKE' : 'TANK';
    const vDef = VEHICLES[vType];
    let py = 0;
    for (let r = 0; r < level.rows; r++) {
      if (level.map[r][col] === 1) { py = r * TILE - vDef.h; break; }
    }
    if (py > 0) {
      vehiclePickups.push({
        x: col * TILE, y: py, w: vDef.w, h: vDef.h,
        type: vType, collected: false,
        bobPhase: rng() * Math.PI * 2,
      });
    }
  }
}

// --- SECRET EXITS ---
let secretExits = [];
function spawnSecretExits(level, stageNum) {
  secretExits = [];
  // Secret exits appear in stages 3 (‚Üí stage 11), 7 (‚Üí stage 12)
  const secretMap = { 3: 11, 7: 12 };
  if (!secretMap[stageNum]) return;
  // Don't show if already in a secret stage
  if (stageNum > MAX_STAGE) return;
  const rng = seedRandom(stageNum * 12321);
  const { cols, groundRow, map } = level;
  // Place one hidden wall section near the end of the level (2/3 through)
  const col = Math.floor(cols * 0.65) + Math.floor(rng() * 20);
  // Build a destructible wall 3 tiles high at ground level
  const wallCol = Math.min(col, cols - 5);
  let wallY = 0;
  for (let r = 0; r < level.rows; r++) {
    if (map[r][wallCol] === 1) { wallY = r * TILE - 3 * TILE; break; }
  }
  if (wallY > 0) {
    secretExits.push({
      x: wallCol * TILE, y: wallY, w: TILE * 2, h: TILE * 3,
      hp: 8, maxHp: 8, targetStage: secretMap[stageNum],
      revealed: false, portalTimer: 0,
    });
  }
}

// --- DECORATIONS ---
let decorations = [];

function spawnDecorations(level, stageNum) {
  decorations = [];
  const rng = seedRandom(stageNum * 33333);
  const { cols, groundRow } = level;
  const theme = getTheme(stageNum);

  // Theme-specific decoration pools
  const decoPool = [];
  if (theme.desert) {
    decoPool.push({dtype:'cactus',dw:14,dh:36,dcolor:'#338833'});
    decoPool.push({dtype:'rocks',dw:30,dh:14,dcolor:'#aa8866'});
    decoPool.push({dtype:'skull',dw:12,dh:12,dcolor:'#ccccaa'});
    decoPool.push({dtype:'deadtree',dw:16,dh:44,dcolor:'#886644'});
    decoPool.push({dtype:'sign',dw:14,dh:28,dcolor:'#886644'});
  } else if (theme.snow) {
    decoPool.push({dtype:'tree',dw:20,dh:48,dcolor:'#446644'});
    decoPool.push({dtype:'rocks',dw:30,dh:14,dcolor:'#99aabb'});
    decoPool.push({dtype:'sign',dw:14,dh:28,dcolor:'#886644'});
    decoPool.push({dtype:'flag',dw:8,dh:36,dcolor:'#2266cc'});
    decoPool.push({dtype:'fence',dw:32,dh:24,dcolor:'#bbccdd'});
  } else if (theme.space) {
    decoPool.push({dtype:'sign',dw:14,dh:28,dcolor:'#888888'});
    decoPool.push({dtype:'rocks',dw:30,dh:14,dcolor:'#555577'});
    decoPool.push({dtype:'flag',dw:8,dh:36,dcolor:'#ff4444'});
    decoPool.push({dtype:'antenna',dw:6,dh:40,dcolor:'#aaaacc'});
  } else if (theme.water) {
    decoPool.push({dtype:'rocks',dw:30,dh:14,dcolor:'#556677'});
    decoPool.push({dtype:'bush',dw:24,dh:16,dcolor:'#226644'});
    decoPool.push({dtype:'sign',dw:14,dh:28,dcolor:'#667788'});
    decoPool.push({dtype:'flag',dw:8,dh:36,dcolor:'#cc6622'});
    decoPool.push({dtype:'fence',dw:32,dh:24,dcolor:'#667788'});
  } else {
    decoPool.push({dtype:'tree',dw:20,dh:48,dcolor:'#226622'});
    decoPool.push({dtype:'deadtree',dw:16,dh:44,dcolor:'#554433'});
    decoPool.push({dtype:'bush',dw:24,dh:16,dcolor:'#337733'});
    decoPool.push({dtype:'rocks',dw:30,dh:14,dcolor:'#777777'});
    decoPool.push({dtype:'sign',dw:14,dh:28,dcolor:'#886644'});
    decoPool.push({dtype:'skull',dw:12,dh:12,dcolor:'#ccccaa'});
    decoPool.push({dtype:'fence',dw:32,dh:24,dcolor:'#997744'});
    decoPool.push({dtype:'flag',dw:8,dh:36,dcolor:'#cc2222'});
  }

  for (let c = 3; c < cols - 5; c++) {
    if (rng() < 0.08) {
      const pick = decoPool[Math.floor(rng() * decoPool.length)];
      const { dtype, dw, dh, dcolor } = pick;
      let dy = 0;
      for (let r = 0; r < level.rows; r++) {
        if (level.map[r][c] === 1) { dy = r * TILE - dh; break; }
      }
      if (dy > 0) {
        decorations.push({ x: c * TILE, y: dy, w: dw, h: dh, type: dtype, color: dcolor, phase: rng() * 6.28 });
      }
      c += 2;
    }
  }
}

// --- LEVEL DATA ---
let level;
let camX = 0;
let camY = 0;

// --- DRAWING HELPERS ---
function drawRect(x, y, w, h, color) {
  ctx.fillStyle = color;
  ctx.fillRect(Math.round(x - camX), Math.round(y), w, h);
}

function drawVehicle(p) {
  const sx = Math.round(p.x - camX);
  const sy = Math.round(p.y);
  const vDef = VEHICLES[p.vehicleType];
  const flash = p.vehicleHitFlash > 0 && Math.floor(p.vehicleHitFlash / 2) % 2;

  if (p.vehicleType === 'HOVERBIKE') {
    // --- HOVERBIKE ---
    // Body
    ctx.fillStyle = flash ? '#ffffff' : '#44ccff';
    ctx.fillRect(sx + 4, sy + 6, 40, 10);
    // Windshield
    ctx.fillStyle = flash ? '#cccccc' : '#88eeff';
    ctx.fillRect(sx + (p.facing > 0 ? 32 : 8), sy + 2, 8, 8);
    // Nose cone
    ctx.fillStyle = flash ? '#ffffff' : '#3399cc';
    ctx.beginPath();
    if (p.facing > 0) {
      ctx.moveTo(sx + 44, sy + 6); ctx.lineTo(sx + 48, sy + 11); ctx.lineTo(sx + 44, sy + 16);
    } else {
      ctx.moveTo(sx + 4, sy + 6); ctx.lineTo(sx, sy + 11); ctx.lineTo(sx + 4, sy + 16);
    }
    ctx.fill();
    // Hover glow (pulsing)
    const pulse = 0.5 + Math.sin(Date.now() * 0.01) * 0.5;
    ctx.globalAlpha = 0.3 + pulse * 0.3;
    ctx.fillStyle = '#44eeff';
    ctx.fillRect(sx + 8, sy + 18, 32, 3);
    ctx.globalAlpha = 0.15 + pulse * 0.15;
    ctx.fillRect(sx + 4, sy + 20, 40, 4);
    ctx.globalAlpha = 1;
    // Engine exhaust (rear)
    const exX = p.facing > 0 ? sx : sx + 44;
    if (Math.random() < 0.5) {
      ctx.fillStyle = '#88eeff';
      ctx.fillRect(exX - 4, sy + 8, 6, 6);
    }
    // Rider silhouette
    ctx.fillStyle = '#338833';
    ctx.fillRect(sx + 18, sy - 2, 10, 8); // torso
    ctx.fillRect(sx + 20, sy - 6, 6, 5);  // head
    // Gun barrel
    ctx.fillStyle = '#aaaaaa';
    const gunX = p.facing > 0 ? sx + 38 : sx + 2;
    ctx.fillRect(gunX, sy + 4, 10 * p.facing, 3);
  } else {
    // --- TANK ---
    // Treads
    ctx.fillStyle = flash ? '#cccccc' : '#555555';
    ctx.fillRect(sx, sy + 22, 56, 10);
    // Tread detail
    ctx.fillStyle = '#333333';
    for (let i = 0; i < 7; i++) {
      ctx.fillRect(sx + 2 + i * 8, sy + 24, 2, 6);
    }
    // Hull
    ctx.fillStyle = flash ? '#ffffff' : '#88aa55';
    ctx.fillRect(sx + 6, sy + 10, 44, 14);
    // Hull detail
    ctx.fillStyle = '#6b8844';
    ctx.fillRect(sx + 8, sy + 12, 40, 2);
    // Turret
    ctx.fillStyle = flash ? '#cccccc' : '#779944';
    ctx.fillRect(sx + 16, sy + 2, 24, 10);
    // Barrel
    ctx.fillStyle = '#555555';
    const barrelX = p.facing > 0 ? sx + 40 : sx + 2;
    const barrelLen = 16;
    ctx.fillRect(barrelX, sy + 4, barrelLen * p.facing, 4);
    // Muzzle
    ctx.fillStyle = '#888888';
    ctx.fillRect(barrelX + barrelLen * p.facing - 2 * p.facing, sy + 3, 4, 6);
    // Hatch
    ctx.fillStyle = '#668833';
    ctx.fillRect(sx + 24, sy, 8, 4);
    // Armor rivets
    ctx.fillStyle = '#aabb77';
    ctx.fillRect(sx + 12, sy + 16, 3, 3);
    ctx.fillRect(sx + 42, sy + 16, 3, 3);
  }

  // Vehicle HP bar
  const hpPct = p.vehicleHP / p.vehicleMaxHP;
  const barW = p.w;
  ctx.fillStyle = '#333';
  ctx.fillRect(sx, sy - 8, barW, 4);
  ctx.fillStyle = hpPct > 0.5 ? '#44ff44' : hpPct > 0.25 ? '#ffaa00' : '#ff3333';
  ctx.fillRect(sx, sy - 8, barW * hpPct, 4);
  ctx.strokeStyle = '#222';
  ctx.lineWidth = 0.5;
  ctx.strokeRect(sx, sy - 8, barW, 4);
}

function drawPixelChar(x, y, w, h, color, facing, prone, animFrame, shooting, aimY) {
  const sx = Math.round(x - camX);
  const sy = Math.round(y);

  ctx.save();
  if (facing === -1) {
    ctx.translate(sx + w / 2, 0);
    ctx.scale(-1, 1);
    ctx.translate(-(sx + w / 2), 0);
  }

  if (prone) {
    // Prone sprite
    ctx.fillStyle = '#225522';
    ctx.fillRect(sx - 4, sy + h - 12, w + 16, 12);
    ctx.fillStyle = '#338833';
    ctx.fillRect(sx, sy + h - 14, w + 8, 8);
    // Head
    ctx.fillStyle = '#ddbb88';
    ctx.fillRect(sx + w + 4, sy + h - 16, 8, 8);
    // Gun
    ctx.fillStyle = '#666';
    ctx.fillRect(sx + w + 12, sy + h - 13, 10, 3);
  } else {
    // Legs
    const legOff = Math.sin(animFrame * 0.3) * 4;
    ctx.fillStyle = '#225522';
    ctx.fillRect(sx + 3, sy + h - 12, 6, 12);
    ctx.fillRect(sx + w - 9, sy + h - 12 + (animFrame ? legOff : 0), 6, 12);

    // Body
    ctx.fillStyle = '#338833';
    ctx.fillRect(sx + 2, sy + 10, w - 4, h - 22);

    // Head
    ctx.fillStyle = '#ddbb88';
    ctx.fillRect(sx + 4, sy, w - 8, 12);
    // Headband
    ctx.fillStyle = '#cc2222';
    ctx.fillRect(sx + 3, sy + 4, w - 6, 3);

    // Eyes
    ctx.fillStyle = '#000';
    ctx.fillRect(sx + w - 7, sy + 3, 2, 2);

    // Gun arm
    ctx.fillStyle = '#666';
    const gunY = shooting ? sy + 14 : sy + 16;
    if (aimY < -0.5) {
      // Aim up
      ctx.fillRect(sx + w / 2 - 1, sy - 8, 3, 14);
    } else if (aimY > 0.5 && !prone) {
      // Aim down (if in air)
      ctx.fillRect(sx + w / 2 - 1, sy + h - 4, 3, 12);
    } else {
      // Aim forward
      ctx.fillRect(sx + w - 2, gunY, 12, 3);
    }
  }

  ctx.restore();
}

function drawWallClimbingChar(x, y, w, h, climbFrame, wallDir) {
  // wallDir: -1 = wall on left (player faces left), +1 = wall on right (player faces right)
  const sx = Math.round(x - camX);
  const sy = Math.round(y);
  const armOff = Math.sin(climbFrame * 3) * 4;
  const flip = wallDir; // which side the wall is on

  // Arms reaching toward wall
  ctx.fillStyle = '#ddbb88';
  if (flip === 1) {
    // Wall on right: right arm up, left arm down
    ctx.fillRect(sx + w - 2, sy + 4 - armOff, 5, 7);
    ctx.fillRect(sx - 3, sy + 10 + armOff, 5, 7);
  } else {
    // Wall on left: left arm up, right arm down
    ctx.fillRect(sx - 3, sy + 4 - armOff, 5, 7);
    ctx.fillRect(sx + w - 2, sy + 10 + armOff, 5, 7);
  }

  // Body (pressed against wall)
  ctx.fillStyle = '#338833';
  ctx.fillRect(sx + 2, sy + 8, w - 4, h - 20);

  // Head
  ctx.fillStyle = '#ddbb88';
  ctx.fillRect(sx + 4, sy - 2, w - 8, 12);
  // Headband
  ctx.fillStyle = '#cc2222';
  ctx.fillRect(sx + 3, sy + 2, w - 6, 3);

  // Legs bent, pressed against wall
  const legOff = Math.sin(climbFrame * 3) * 3;
  ctx.fillStyle = '#225522';
  ctx.fillRect(sx + 3, sy + h - 12 + legOff, 6, 12);
  ctx.fillRect(sx + w - 9, sy + h - 12 - legOff, 6, 12);

  // Hands gripping wall
  ctx.fillStyle = '#ccaa77';
  if (flip === 1) {
    ctx.fillRect(sx + w, sy + 4 - armOff, 3, 4);
    ctx.fillRect(sx - 3, sy + 10 + armOff, 3, 4);
  } else {
    ctx.fillRect(sx - 3, sy + 4 - armOff, 3, 4);
    ctx.fillRect(sx + w, sy + 10 + armOff, 3, 4);
  }

  // Knees against wall
  ctx.fillStyle = '#225522';
  if (flip === 1) {
    ctx.fillRect(sx + w - 4, sy + h - 8 + legOff, 5, 4);
  } else {
    ctx.fillRect(sx - 1, sy + h - 8 + legOff, 5, 4);
  }
}

function drawClimbingChar(x, y, w, h, climbFrame) {
  const sx = Math.round(x - camX);
  const sy = Math.round(y);
  const armOff = Math.sin(climbFrame) * 5;

  // Arms reaching up alternating
  ctx.fillStyle = '#ddbb88';
  ctx.fillRect(sx - 2, sy + 2 - armOff, 6, 8);
  ctx.fillRect(sx + w - 4, sy + 2 + armOff, 6, 8);

  // Body
  ctx.fillStyle = '#338833';
  ctx.fillRect(sx + 2, sy + 8, w - 4, h - 20);

  // Head
  ctx.fillStyle = '#ddbb88';
  ctx.fillRect(sx + 4, sy - 2, w - 8, 12);
  // Headband
  ctx.fillStyle = '#cc2222';
  ctx.fillRect(sx + 3, sy + 2, w - 6, 3);

  // Legs alternating
  const legOff = Math.sin(climbFrame) * 4;
  ctx.fillStyle = '#225522';
  ctx.fillRect(sx + 3, sy + h - 12 + legOff, 6, 12);
  ctx.fillRect(sx + w - 9, sy + h - 12 - legOff, 6, 12);

  // Hands gripping
  ctx.fillStyle = '#ccaa77';
  ctx.fillRect(sx - 2, sy + 2 - armOff, 4, 4);
  ctx.fillRect(sx + w - 2, sy + 2 + armOff, 4, 4);
}

function drawEnemy(e) {
  const sx = Math.round(e.x - camX);
  const sy = Math.round(e.y);

  if (e.isBoss) {
    // Boss
    const hpRatio = e.hp / e.maxHp;

    // Body
    ctx.fillStyle = hpRatio < 0.3 ? '#ff4444' : (hpRatio < 0.6 ? '#cc6644' : '#884444');
    ctx.fillRect(sx + 4, sy + 10, e.w - 8, e.h - 20);

    // Armored shell
    ctx.fillStyle = '#666';
    ctx.fillRect(sx, sy + 5, e.w, 8);
    ctx.fillRect(sx + 2, sy + 13, e.w - 4, e.h - 30);

    // Head / sensor
    ctx.fillStyle = '#ff0000';
    ctx.fillRect(sx + 16, sy, 16, 10);
    ctx.fillStyle = '#ffff00';
    const blinkPhase = Math.sin(Date.now() * 0.01);
    if (blinkPhase > 0) ctx.fillRect(sx + 20, sy + 2, 8, 4);

    // Gun barrels
    ctx.fillStyle = '#444';
    ctx.fillRect(sx - 8, sy + 20, 12, 4);
    ctx.fillRect(sx - 8, sy + 35, 12, 4);
    ctx.fillRect(sx + e.w - 4, sy + 28, 12, 4);

    // Legs
    ctx.fillStyle = '#555';
    ctx.fillRect(sx + 6, sy + e.h - 14, 10, 14);
    ctx.fillRect(sx + e.w - 16, sy + e.h - 14, 10, 14);

    // HP bar
    ctx.fillStyle = '#333';
    ctx.fillRect(sx, sy - 10, e.w, 5);
    ctx.fillStyle = hpRatio < 0.3 ? '#ff0000' : (hpRatio < 0.6 ? '#ffaa00' : '#00ff00');
    ctx.fillRect(sx, sy - 10, e.w * hpRatio, 5);

    return;
  }

  // Regular enemies
  ctx.save();
  if (e.facing === 1) {
    ctx.translate(sx + e.w / 2, 0);
    ctx.scale(-1, 1);
    ctx.translate(-(sx + e.w / 2), 0);
  }

  // Body
  ctx.fillStyle = e.color;
  ctx.fillRect(sx + 2, sy + 8, e.w - 4, e.h - 16);

  // Head
  ctx.fillStyle = '#ddaa77';
  ctx.fillRect(sx + 3, sy, e.w - 6, 10);

  // Helmet
  ctx.fillStyle = darkenColor(e.color, 0.6);
  ctx.fillRect(sx + 2, sy, e.w - 4, 5);

  // Eyes
  ctx.fillStyle = '#fff';
  ctx.fillRect(sx + e.w - 6, sy + 3, 3, 2);

  // Legs
  ctx.fillStyle = darkenColor(e.color, 0.7);
  ctx.fillRect(sx + 3, sy + e.h - 10, 5, 10);
  ctx.fillRect(sx + e.w - 8, sy + e.h - 10, 5, 10);

  // Gun
  if (e.fireRate > 0 && e.etype !== 'bomber') {
    ctx.fillStyle = '#555';
    ctx.fillRect(sx + e.w - 2, sy + 12, 8, 3);
  }

  // Bomber backpack
  if (e.etype === 'bomber') {
    ctx.fillStyle = '#556644';
    ctx.fillRect(sx - 4, sy + 8, 6, 14);
    ctx.fillStyle = '#ff8844';
    ctx.fillRect(sx + e.w - 2, sy + 14, 6, 4);
  }

  // Jumper legs (spring-like)
  if (e.etype === 'jumper' && !e.onGround) {
    ctx.fillStyle = '#ffcc00';
    ctx.fillRect(sx + 4, sy + e.h - 4, e.w - 8, 4);
  }

  // Shield (front barrier)
  if (e.etype === 'shield') {
    ctx.fillStyle = '#66aacc';
    ctx.globalAlpha = 0.7;
    ctx.fillRect(sx + e.w - 2, sy + 2, 5, e.h - 6);
    ctx.fillStyle = '#88ccee';
    ctx.fillRect(sx + e.w - 1, sy + 4, 3, e.h - 10);
    ctx.globalAlpha = 1;
  }

  // Drone (propellers + sensor eye)
  if (e.etype === 'drone') {
    // Propeller blades
    ctx.fillStyle = '#aaddff';
    const bladeOff = Math.sin(Date.now() * 0.05) * 3;
    ctx.fillRect(sx - 3 + bladeOff, sy - 4, e.w + 6, 3);
    ctx.fillRect(sx + e.w / 2 - 5, sy - 6, 10, 2);
    // Sensor eye
    ctx.fillStyle = '#ff4444';
    ctx.fillRect(sx + e.w / 2 - 2, sy + 4, 4, 4);
  }

  // Teleporter (purple glow rings)
  if (e.etype === 'teleporter') {
    ctx.globalAlpha = 0.4 + Math.sin(Date.now() * 0.006) * 0.3;
    ctx.strokeStyle = '#bb44ff';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(sx + e.w / 2, sy + e.h / 2, e.w * 0.8, 0, Math.PI * 2);
    ctx.stroke();
    ctx.globalAlpha = 1;
    ctx.lineWidth = 1;
  }

  // Cloaker (shimmer overlay ‚Äî draws semi-transparent)
  if (e.etype === 'cloaker') {
    // Already drawn above; the draw() wrapper handles alpha
  }

  // Shielded Pair (buddy shield in front)
  if (e.etype === 'shieldpair') {
    // Buddy shield pulsing
    const shPulse = Math.sin((e.pairOffset || 0)) * 0.15;
    ctx.globalAlpha = 0.6 + shPulse;
    ctx.fillStyle = '#ffaa44';
    ctx.fillRect(sx + e.w - 2, sy, 6, e.h);
    ctx.fillStyle = '#ffcc88';
    ctx.fillRect(sx + e.w - 1, sy + 3, 4, e.h - 6);
    ctx.globalAlpha = 1;
    // Buddy soldier silhouette behind shield
    ctx.fillStyle = '#aa6622';
    ctx.fillRect(sx + e.w + 4, sy + 4, 8, e.h - 8);
  }

  ctx.restore();
}

function darkenColor(hex, factor) {
  const r = parseInt(hex.slice(1, 3), 16);
  const g = parseInt(hex.slice(3, 5), 16);
  const b = parseInt(hex.slice(5, 7), 16);
  return `rgb(${Math.floor(r * factor)},${Math.floor(g * factor)},${Math.floor(b * factor)})`;
}

// ============================================================
//  ANIMATED SPRITE SHEET SYSTEM
// ============================================================
// Generates sprite sheets procedurally at init. Each entity type
// gets an offscreen canvas with all animation frames laid out in
// a grid. At runtime, drawImage() blits from the sheet ‚Äî faster
// than the per-frame procedural fillRect calls and enables proper
// multi-frame animations (enemies, boss, player run cycle, etc.).

let useSprites = true;
const SPR = {}; // sprite sheet registry

function lightenColor(hex, factor) {
  if (hex[0] !== '#') return hex;
  const r = Math.min(255, Math.floor(parseInt(hex.slice(1,3), 16) * factor));
  const g = Math.min(255, Math.floor(parseInt(hex.slice(3,5), 16) * factor));
  const b = Math.min(255, Math.floor(parseInt(hex.slice(5,7), 16) * factor));
  return `rgb(${r},${g},${b})`;
}

// Pixel fill shorthand for sprite ctx
function _px(s, x, y, w, h, c) { s.fillStyle = c; s.fillRect(x, y, w, h); }

// ---- Sheet infrastructure ----

function sprSheet(fw, fh, cols, rows) {
  const c = document.createElement('canvas');
  c.width = cols * fw; c.height = rows * fh;
  const x = c.getContext('2d');
  x.imageSmoothingEnabled = false;
  return { img: c, ctx: x, fw, fh, cols, anims: {}, ax: 0, ay: 0 };
}

function sprAnim(sheet, name, row, col, frames, speed, loop) {
  sheet.anims[name] = { r: row, c: col, n: frames, spd: speed, loop: loop !== false };
}

// Draw one frame from sheet onto the game canvas
function sprDraw(sheet, anim, frame, wx, wy, ew, flipH) {
  const a = sheet.anims[anim];
  if (!a) return;
  const fi = frame % a.n;
  const sx = (a.c + fi) * sheet.fw;
  const sy = a.r * sheet.fh;
  const dx = Math.round(wx - camX) - sheet.ax;
  const dy = Math.round(wy) - sheet.ay;
  if (flipH) {
    const cx = Math.round(wx - camX) + ew / 2;
    ctx.save();
    ctx.translate(cx, 0);
    ctx.scale(-1, 1);
    ctx.translate(-cx, 0);
    ctx.drawImage(sheet.img, sx, sy, sheet.fw, sheet.fh, dx, dy, sheet.fw, sheet.fh);
    ctx.restore();
  } else {
    ctx.drawImage(sheet.img, sx, sy, sheet.fw, sheet.fh, dx, dy, sheet.fw, sheet.fh);
  }
}

// Advance animation state ‚Äî returns current frame index
function sprTick(e, animName, sheet) {
  if (e._sa !== animName) { e._sa = animName; e._sf = 0; e._st = 0; }
  const a = sheet.anims[animName];
  if (!a) return 0;
  if (++e._st >= a.spd) {
    e._st = 0;
    e._sf++;
    if (e._sf >= a.n) e._sf = a.loop !== false ? 0 : a.n - 1;
  }
  return e._sf;
}

// ---- Player sprite generator ----

function genPlayerSheet(bodyColor) {
  const dk = darkenColor(bodyColor, 0.65);
  const lt = lightenColor(bodyColor, 1.3);
  const sk = '#ddbb88', dsk = '#bb9966', hb = '#cc2222';
  const gn = '#666666', dgn = '#444444', bt = '#554433';
  const hr = '#331a00', bk = '#000000', wt = '#ffffff', belt = '#443322';

  const sheet = sprSheet(48, 48, 8, 4);
  sheet.ax = 14; sheet.ay = 8;

  sprAnim(sheet, 'idle',       0, 0, 4, 12);
  sprAnim(sheet, 'run',        0, 4, 4, 5);
  sprAnim(sheet, 'jump_up',    1, 0, 1, 1);
  sprAnim(sheet, 'jump_fall',  1, 1, 1, 1);
  sprAnim(sheet, 'shoot',      1, 2, 2, 6);
  sprAnim(sheet, 'shoot_up',   1, 4, 2, 6);
  sprAnim(sheet, 'shoot_down', 1, 6, 2, 6);
  sprAnim(sheet, 'prone',      2, 0, 2, 10);
  sprAnim(sheet, 'prone_shoot',2, 2, 2, 5);
  sprAnim(sheet, 'climb',      2, 4, 4, 8);
  sprAnim(sheet, 'wall_climb', 3, 0, 4, 8);

  const s = sheet.ctx;

  // Standing / running / jumping / shooting frame renderer
  function standing(row, col, o) {
    o = o || {};
    const ox = col * 48, oy = row * 48;
    const x = ox + 14, y = oy + 8 + (o.bob || 0);
    const lo = o.lo || 0, lo2 = o.lo2 !== undefined ? o.lo2 : -lo;

    // Legs
    _px(s, x + 3, y + 20 + Math.max(0, lo), 6, 12 - Math.abs(lo), dk);
    _px(s, x + 11, y + 20 + Math.max(0, lo2), 6, 12 - Math.abs(lo2), dk);
    _px(s, x + 3, y + 30 + lo, 7, 2, bt);
    _px(s, x + 11, y + 30 + lo2, 7, 2, bt);

    // Body
    _px(s, x + 2, y + 10, 16, 12, bodyColor);
    _px(s, x + 2, y + 10, 16, 2, lt);
    _px(s, x + 2, y + 20, 16, 2, belt);
    // Vest straps
    _px(s, x + 4, y + 12, 2, 7, dk);
    _px(s, x + 14, y + 12, 2, 7, dk);
    // Shoulder
    _px(s, x + 1, y + 10, 3, 4, dk);
    _px(s, x + 16, y + 10, 3, 4, dk);

    // Head
    _px(s, x + 4, y, 12, 12, sk);
    _px(s, x + 4, y + 8, 12, 4, dsk);
    _px(s, x + 4, y, 12, 3, hr);
    // Headband
    _px(s, x + 3, y + 3, 14, 3, hb);
    _px(s, x, y + 4, 3, 2, hb);
    // Eye
    _px(s, x + 14, y + 4, 2, 2, bk);
    _px(s, x + 13, y + 4, 1, 1, wt);

    // Gun arm
    if (o.up) {
      _px(s, x + 8, y - 8, 3, 16, gn);
      _px(s, x + 9, y - 8, 1, 16, dgn);
      if (o.mz) { _px(s, x + 6, y - 12, 7, 4, '#ffff44'); _px(s, x + 8, y - 11, 3, 2, wt); }
    } else if (o.dn) {
      _px(s, x + 8, y + 28, 3, 14, gn);
      _px(s, x + 9, y + 28, 1, 14, dgn);
      if (o.mz) { _px(s, x + 6, y + 42, 7, 4, '#ffff44'); }
    } else {
      const gy = y + (o.sh ? 13 : 15);
      _px(s, x + 18, gy, 14, 3, gn);
      _px(s, x + 18, gy + 1, 14, 1, dgn);
      if (o.mz) { _px(s, x + 32, gy - 2, 4, 7, '#ffff44'); _px(s, x + 33, gy - 1, 2, 5, wt); }
    }
    // Non-gun arm
    const ay = y + 12 + (o.arm || 0);
    _px(s, x, ay, 4, 8, sk);
    _px(s, x, ay, 4, 2, dsk);
  }

  // Prone frame renderer
  function prone(row, col, o) {
    o = o || {};
    const ox = col * 48, oy = row * 48;
    const x = ox + 14, y = oy + 8;
    _px(s, x - 4, y + 19, 36, 13, dk);
    _px(s, x - 2, y + 17, 30, 9, bodyColor);
    _px(s, x, y + 17, 26, 2, lt);
    _px(s, x + 24, y + 15, 8, 8, sk);
    _px(s, x + 24, y + 15, 8, 2, dsk);
    _px(s, x + 23, y + 18, 10, 3, hb);
    _px(s, x + 30, y + 17, 2, 2, bk);
    if (o.sh) {
      _px(s, x + 32, y + 18, 14, 3, gn);
      _px(s, x + 32, y + 19, 14, 1, dgn);
      if (o.mz) _px(s, x + 46, y + 16, 4, 7, '#ffff44');
    } else {
      _px(s, x + 32, y + 18, 10, 3, gn);
    }
    _px(s, x + 22, y + 26, 6, 6, bt);
  }

  // Climb (ladder) frame renderer
  function climb(row, col, phase) {
    const ox = col * 48, oy = row * 48;
    const x = ox + 14, y = oy + 8;
    const ao = Math.sin(phase) * 5;
    _px(s, x - 2, y + 2 - ao, 6, 8, sk);
    _px(s, x + 16, y + 2 + ao, 6, 8, sk);
    _px(s, x - 2, y + 2 - ao, 4, 4, '#ccaa77');
    _px(s, x + 18, y + 2 + ao, 4, 4, '#ccaa77');
    _px(s, x + 2, y + 8, 16, 12, bodyColor);
    _px(s, x + 2, y + 8, 16, 2, lt);
    _px(s, x + 4, y - 2, 12, 12, sk);
    _px(s, x + 3, y + 2, 14, 3, hb);
    _px(s, x + 4, y - 2, 12, 3, hr);
    const lo = Math.sin(phase) * 4;
    _px(s, x + 3, y + 20 + lo, 6, 12, dk);
    _px(s, x + 11, y + 20 - lo, 6, 12, dk);
    _px(s, x + 3, y + 30 + lo, 7, 2, bt);
    _px(s, x + 11, y + 30 - lo, 7, 2, bt);
  }

  // Wall climb frame renderer
  function wallClimb(row, col, phase) {
    const ox = col * 48, oy = row * 48;
    const x = ox + 14, y = oy + 8;
    const ao = Math.sin(phase * 3) * 4;
    _px(s, x + 18, y + 4 - ao, 5, 7, sk);
    _px(s, x - 3, y + 10 + ao, 5, 7, sk);
    _px(s, x + 20, y + 4 - ao, 3, 4, '#ccaa77');
    _px(s, x - 3, y + 10 + ao, 3, 4, '#ccaa77');
    _px(s, x + 2, y + 8, 16, 14, bodyColor);
    _px(s, x + 2, y + 8, 16, 2, lt);
    _px(s, x + 4, y - 2, 12, 12, sk);
    _px(s, x + 3, y + 2, 14, 3, hb);
    _px(s, x + 4, y - 2, 12, 3, hr);
    const lo = Math.sin(phase * 3) * 3;
    _px(s, x + 3, y + 20 + lo, 6, 12, dk);
    _px(s, x + 11, y + 20 - lo, 6, 12, dk);
    _px(s, x + 16, y + 24 + lo, 5, 4, dk);
  }

  // === Generate all frames ===

  // Row 0: idle(4) + run(4)
  for (let f = 0; f < 4; f++) standing(0, f, { bob: [0, -1, 0, 1][f] });
  for (let f = 0; f < 4; f++) {
    const ph = f / 4 * Math.PI * 2;
    standing(0, 4 + f, { lo: Math.sin(ph) * 5, lo2: Math.sin(ph + Math.PI) * 5, arm: Math.sin(ph + Math.PI) * 3 });
  }

  // Row 1: jump_up + jump_fall + shoot(2) + shoot_up(2) + shoot_down(2)
  standing(1, 0, { lo: -4, lo2: -4 });
  standing(1, 1, { lo: 3, lo2: 5 });
  standing(1, 2, { sh: true });
  standing(1, 3, { sh: true, mz: true });
  standing(1, 4, { up: true });
  standing(1, 5, { up: true, mz: true });
  standing(1, 6, { dn: true });
  standing(1, 7, { dn: true, mz: true });

  // Row 2: prone(2) + prone_shoot(2) + climb(4)
  prone(2, 0);
  prone(2, 1);
  prone(2, 2, { sh: true });
  prone(2, 3, { sh: true, mz: true });
  for (let f = 0; f < 4; f++) climb(2, 4 + f, f / 4 * Math.PI * 2);

  // Row 3: wall_climb(4) + (padding)
  for (let f = 0; f < 4; f++) wallClimb(3, f, f / 4 * Math.PI * 2);

  return sheet;
}

// ---- Enemy sprite generator ----

function genEnemySheet(ekey) {
  const et = ENEMY_TYPES[ekey];
  if (!et) return null;
  const col = et.color;
  const dk = darkenColor(col, 0.6);
  const dkk = darkenColor(col, 0.45);
  const lt = lightenColor(col, 1.25);

  const sheet = sprSheet(40, 44, 8, 2);
  sheet.ax = 10; sheet.ay = 5;

  sprAnim(sheet, 'idle',  0, 0, 2, 14);
  sprAnim(sheet, 'walk',  0, 2, 4, 7);
  sprAnim(sheet, 'shoot', 0, 6, 2, 8);
  sprAnim(sheet, 'die',   1, 0, 4, 6, false);

  const s = sheet.ctx;
  const ew = et.w, eh = et.h;

  function eBase(r, c, o) {
    o = o || {};
    const bx = c * 40 + 10, by = r * 44 + 5;
    const lo = o.lo || 0, lo2 = o.lo2 !== undefined ? o.lo2 : 0;

    // Legs with walk animation
    _px(s, bx + 3, by + eh - 10 + Math.max(0, lo), 5, 10 - Math.abs(lo), dk);
    _px(s, bx + ew - 8, by + eh - 10 + Math.max(0, lo2), 5, 10 - Math.abs(lo2), dk);
    _px(s, bx + 2, by + eh - 2 + lo, 6, 2, '#332211');
    _px(s, bx + ew - 9, by + eh - 2 + lo2, 6, 2, '#332211');

    // Body
    _px(s, bx + 2, by + 8, ew - 4, eh - 16, col);
    _px(s, bx + 2, by + 8, ew - 4, 2, lt);
    _px(s, bx + 2, by + eh - 10, ew - 4, 2, dk);

    // Head
    _px(s, bx + 3, by, ew - 6, 10, '#ddaa77');
    _px(s, bx + 3, by + 7, ew - 6, 3, '#bb9966');
    // Helmet
    _px(s, bx + 2, by, ew - 4, 5, dkk);
    _px(s, bx + 2, by, ew - 4, 1, dk);
    // Eyes
    _px(s, bx + ew - 6, by + 3, 3, 2, '#fff');
    _px(s, bx + ew - 5, by + 3, 2, 2, '#000');

    // Gun
    if (et.fireRate > 0 && et.etype !== 'bomber') {
      _px(s, bx + ew - 2, by + 12, 10, 3, '#555');
      _px(s, bx + ew - 2, by + 13, 10, 1, '#333');
      if (o.mz) {
        _px(s, bx + ew + 8, by + 10, 3, 7, '#ffff44');
        _px(s, bx + ew + 9, by + 11, 1, 5, '#fff');
      }
    }

    // Type-specific features
    if (et.etype === 'bomber') {
      _px(s, bx - 4, by + 8, 6, 14, '#556644');
      _px(s, bx + ew - 2, by + 14, 6, 4, '#ff8844');
    }
    if (et.etype === 'jumper' && o.jump) {
      _px(s, bx + 4, by + eh - 4, ew - 8, 4, '#ffcc00');
      _px(s, bx + 5, by + eh - 3, ew - 10, 2, '#ffee66');
    }
    if (et.etype === 'shield') {
      s.globalAlpha = 0.7;
      _px(s, bx + ew - 2, by + 2, 5, eh - 6, '#66aacc');
      _px(s, bx + ew - 1, by + 4, 3, eh - 10, '#88ccee');
      s.globalAlpha = 1;
    }
    if (et.etype === 'heavy') {
      _px(s, bx, by + 7, 4, 6, dk);
      _px(s, bx + ew - 4, by + 7, 4, 6, dk);
      _px(s, bx + 3, by + 10, ew - 6, 2, dkk);
    }
    if (et.etype === 'sniper') {
      _px(s, bx + ew - 4, by + 1, 4, 2, '#44ff44');
      _px(s, bx + ew - 2, by + 12, 14, 2, '#555');
    }
    if (et.etype === 'turret') {
      _px(s, bx, by + eh - 6, ew, 6, '#666');
      _px(s, bx + 2, by + eh - 8, ew - 4, 4, '#888');
    }
    // Drone: propellers + sensor
    if (et.etype === 'drone') {
      _px(s, bx - 2, by - 3, ew + 4, 3, '#aaddff');
      _px(s, bx + ew / 2 - 2, by + 4, 4, 4, '#ff4444');
    }
    // Teleporter: purple glow
    if (et.etype === 'teleporter') {
      s.globalAlpha = 0.4;
      _px(s, bx - 2, by - 2, ew + 4, eh + 4, '#8822cc');
      s.globalAlpha = 1;
    }
    // Cloaker: subtle outline
    if (et.etype === 'cloaker') {
      s.globalAlpha = 0.3;
      _px(s, bx - 1, by - 1, ew + 2, eh + 2, '#446666');
      s.globalAlpha = 1;
    }
    // Shielded Pair: buddy shield + soldier
    if (et.etype === 'shieldpair') {
      s.globalAlpha = 0.6;
      _px(s, bx + ew - 2, by, 6, eh, '#ffaa44');
      _px(s, bx + ew - 1, by + 3, 4, eh - 6, '#ffcc88');
      s.globalAlpha = 1;
      _px(s, bx + ew + 4, by + 4, 8, eh - 8, '#aa6622');
    }
  }

  // Row 0: idle(2) + walk(4) + shoot(2)
  eBase(0, 0);
  eBase(0, 1, { lo: 1 });
  for (let f = 0; f < 4; f++) {
    const ph = f / 4 * Math.PI * 2;
    eBase(0, 2 + f, {
      lo: Math.sin(ph) * 4,
      lo2: Math.sin(ph + Math.PI) * 4,
      jump: (et.etype === 'jumper' && f === 1)
    });
  }
  eBase(0, 6);
  eBase(0, 7, { mz: true });

  // Row 1: die(4)
  for (let f = 0; f < 4; f++) {
    s.globalAlpha = 1 - f * 0.22;
    eBase(1, f);
    s.globalAlpha = Math.max(0, 0.6 - f * 0.15);
    _px(s, f * 40 + 10, 44 + 5, ew, eh, f < 2 ? '#ff4444' : '#ff8800');
    s.globalAlpha = 1;
  }

  return sheet;
}

// ---- Boss sprite generator ----

function genBossSheet() {
  const sheet = sprSheet(72, 80, 6, 2);
  sheet.ax = 12; sheet.ay = 8;

  sprAnim(sheet, 'idle',    0, 0, 3, 10);
  sprAnim(sheet, 'attack',  0, 3, 3, 6);
  sprAnim(sheet, 'damaged', 1, 0, 2, 4);
  sprAnim(sheet, 'die',     1, 2, 4, 8, false);

  const s = sheet.ctx;
  const bw = 48, bh = 64;

  function bossF(r, c, o) {
    o = o || {};
    const ox = c * 72 + 12, oy = r * 80 + 8;
    const bc = o.dmg ? '#ff4444' : (o.atk ? '#cc6644' : '#884444');
    const bob = o.bob || 0;

    // Legs
    _px(s, ox + 6, oy + bh - 14 + bob, 10, 14, '#555');
    _px(s, ox + bw - 16, oy + bh - 14 + bob, 10, 14, '#555');
    _px(s, ox + 5, oy + bh - 2 + bob, 12, 2, '#333');
    _px(s, ox + bw - 17, oy + bh - 2 + bob, 12, 2, '#333');

    // Body
    _px(s, ox + 4, oy + 10 + bob, bw - 8, bh - 20, bc);
    // Armor
    _px(s, ox, oy + 5 + bob, bw, 8, '#666');
    _px(s, ox + 2, oy + 13 + bob, bw - 4, bh - 30, '#777');
    // Rivets
    for (let i = 0; i < 4; i++) _px(s, ox + 6 + i * 11, oy + 7 + bob, 2, 2, '#999');
    // Panel lines
    _px(s, ox + bw / 2 - 1, oy + 13 + bob, 2, bh - 30, '#555');

    // Guns
    const gb = o.atk ? 2 : 0;
    _px(s, ox - 8, oy + 20 + bob + gb, 12, 4, '#444');
    _px(s, ox - 8, oy + 35 + bob - gb, 12, 4, '#444');
    _px(s, ox + bw - 4, oy + 28 + bob, 12, 4, '#444');
    if (o.mz) {
      _px(s, ox - 12, oy + 18 + bob, 6, 8, '#ffff44');
      _px(s, ox - 12, oy + 33 + bob, 6, 8, '#ffff44');
      _px(s, ox + bw + 8, oy + 26 + bob, 6, 8, '#ffff44');
    }

    // Head / sensor
    _px(s, ox + 16, oy + bob, 16, 10, '#ff0000');
    _px(s, ox + 17, oy + 1 + bob, 14, 8, '#cc0000');
    if (!o.blink) {
      _px(s, ox + 20, oy + 2 + bob, 8, 4, '#ffff00');
      _px(s, ox + 22, oy + 3 + bob, 4, 2, wt);
    }

    // Damage cracks
    if (o.dmg) {
      _px(s, ox + 10, oy + 20 + bob, 2, 15, '#220000');
      _px(s, ox + 30, oy + 15 + bob, 2, 20, '#220000');
      _px(s, ox + 20, oy + 30 + bob, 15, 2, '#220000');
    }
  }

  const wt = '#ffffff';

  // Row 0: idle(3) + attack(3)
  bossF(0, 0);
  bossF(0, 1, { bob: -1, blink: true });
  bossF(0, 2, { bob: 1 });
  bossF(0, 3, { atk: true, bob: -2 });
  bossF(0, 4, { atk: true, mz: true });
  bossF(0, 5, { atk: true, bob: 1, mz: true });

  // Row 1: damaged(2) + die(4)
  bossF(1, 0, { dmg: true });
  bossF(1, 1, { dmg: true, blink: true });
  for (let f = 0; f < 4; f++) {
    s.globalAlpha = 1 - f * 0.2;
    bossF(1, 2 + f, { dmg: true });
    s.globalAlpha = Math.max(0, 0.5 - f * 0.12);
    _px(s, (2 + f) * 72 + 12, 80 + 8, 48, 64, f < 2 ? '#ff8800' : '#ff4444');
    s.globalAlpha = 1;
  }

  return sheet;
}

// ---- Explosion sprite generator ----

function genExplosionSheet() {
  const sheet = sprSheet(32, 32, 8, 1);
  sheet.ax = 16; sheet.ay = 16;
  sprAnim(sheet, 'boom', 0, 0, 8, 3, false);

  const s = sheet.ctx;
  for (let f = 0; f < 8; f++) {
    const cx = f * 32 + 16, cy = 16;
    const r = 4 + f * 2;
    s.globalAlpha = Math.max(0, 1.0 - f * 0.12);
    s.fillStyle = '#ff4400';
    s.beginPath(); s.arc(cx, cy, r, 0, Math.PI * 2); s.fill();
    s.fillStyle = '#ffcc00';
    s.beginPath(); s.arc(cx, cy, r * 0.6, 0, Math.PI * 2); s.fill();
    if (f < 5) {
      s.fillStyle = '#ffffff';
      s.beginPath(); s.arc(cx, cy, r * 0.25, 0, Math.PI * 2); s.fill();
    }
    s.globalAlpha = 1;
  }
  return sheet;
}

// ---- Init all sprite sheets ----

function initSpriteSheets() {
  SPR.p1 = genPlayerSheet('#338833');
  SPR.p2 = genPlayerSheet('#3366ff');
  // Generate character-specific sprite sheets
  for (const key of Object.keys(CHARACTERS)) {
    SPR['char_' + key] = genPlayerSheet(CHARACTERS[key].color);
  }
  for (const key of Object.keys(ENEMY_TYPES)) {
    SPR['e_' + ENEMY_TYPES[key].etype] = genEnemySheet(key);
  }
  SPR.boss = genBossSheet();
  SPR.explosion = genExplosionSheet();
}

// Show sprite sheet canvases in admin panel for debug
function showSpriteSheetPreview() {
  const el = document.getElementById('spriteSheetPreview');
  if (!el) return;
  if (el.children.length > 0) { el.innerHTML = ''; return; }
  const labels = { p1: 'Player 1', p2: 'Player 2', boss: 'Boss', explosion: 'Explosion' };
  for (const [key, sheet] of Object.entries(SPR)) {
    const label = labels[key] || key.replace('e_', 'Enemy: ');
    const div = document.createElement('div');
    div.style.cssText = 'margin:4px 0;';
    div.innerHTML = `<div style="font-size:7px;color:#aaa;margin-bottom:2px;">${label} (${sheet.img.width}√ó${sheet.img.height})</div>`;
    const img = document.createElement('img');
    img.src = sheet.img.toDataURL();
    img.style.cssText = 'max-width:100%;image-rendering:pixelated;border:1px solid #333;background:#111;';
    div.appendChild(img);
    el.appendChild(div);
  }
}

// ---- Animation state helpers ----

function getPlayerAnimName(p) {
  if (p.onLadder)     return 'climb';
  if (p.wallClimbing) return 'wall_climb';
  if (p.prone)        return p.shooting ? 'prone_shoot' : 'prone';
  if (!p.onGround && !p.grapple) return p.vy < 0 ? 'jump_up' : 'jump_fall';
  if (p.shooting) {
    if (p.aimY < -0.5) return 'shoot_up';
    if (p.aimY > 0.5)  return 'shoot_down';
    return 'shoot';
  }
  if (p.animFrame > 0) return 'run';
  return 'idle';
}

function getEnemyAnimName(e) {
  if (e.isBoss) {
    const hpR = e.hp / e.maxHp;
    if (hpR < 0.3) return 'damaged';
    if (e.phaseTimer && e.phaseTimer % 120 < 40) return 'attack';
    return 'idle';
  }
  if (e.speed > 0 && !e.isBoss) return 'walk';
  return 'idle';
}

// ---- Sprite draw wrappers ----

function drawPlayerSprite(p, sheetKey) {
  const sheet = SPR[sheetKey];
  if (!sheet) return false;
  const animName = getPlayerAnimName(p);
  const frame = sprTick(p, animName, sheet);
  sprDraw(sheet, animName, frame, p.x, p.y, p.w, p.facing === -1);
  return true;
}

function drawEnemySprite(e) {
  const sheet = e.isBoss ? SPR.boss : SPR['e_' + e.etype];
  if (!sheet) { drawEnemy(e); return; }
  const animName = getEnemyAnimName(e);
  const frame = sprTick(e, animName, sheet);
  const flipH = e.isBoss ? false : (e.facing === 1);
  sprDraw(sheet, animName, frame, e.x, e.y, e.w, flipH);
}

// --- BACKGROUND ---
function drawBackground(stageNum) {
  const theme = getTheme(stageNum);
  const vw = viewW(), vh = viewH();
  const grad = ctx.createLinearGradient(0, 0, 0, vh);
  for (const [color, stop] of theme.sky) grad.addColorStop(stop, color);
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, vw, vh);

  // Stars
  if (theme.stars > 0) {
    const starSeed = seedRandom(stageNum * 777);
    ctx.fillStyle = '#ffffff';
    for (let i = 0; i < theme.stars; i++) {
      const sx = ((starSeed() * vw * 3 - camX * 0.1) % vw + vw) % vw;
      const sy = starSeed() * vh * 0.6;
      const size = starSeed() < 0.1 ? 2 : 1;
      ctx.globalAlpha = (0.3 + starSeed() * 0.7) * theme.starBright;
      ctx.fillRect(sx, sy, size, size);
      // Twinkle big stars in space theme
      if (theme.space && size === 2) {
        ctx.globalAlpha *= (0.5 + 0.5 * Math.sin(Date.now() * 0.003 + i));
        ctx.fillRect(sx - 1, sy, 4, 1);
        ctx.fillRect(sx, sy - 1, 1, 4);
      }
    }
    ctx.globalAlpha = 1;
  }

  // Desert: sun
  if (theme.desert) {
    ctx.globalAlpha = 0.8;
    ctx.fillStyle = '#ffee66';
    const sunX = vw * 0.8 - camX * 0.02;
    ctx.beginPath();
    ctx.arc(sunX, vh * 0.15, 30, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#ffffaa';
    ctx.globalAlpha = 0.15;
    ctx.beginPath();
    ctx.arc(sunX, vh * 0.15, 60, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
  }

  // Space: nebula glow
  if (theme.space) {
    ctx.globalAlpha = 0.08;
    const nebSeed = seedRandom(stageNum * 555);
    for (let i = 0; i < 5; i++) {
      const nx = ((nebSeed() * vw * 2 - camX * 0.05) % (vw * 1.5) + vw * 1.5) % (vw * 1.5) - vw * 0.25;
      const ny = nebSeed() * vh * 0.5;
      const nr = 40 + nebSeed() * 80;
      const colors = ['#6622aa','#2244aa','#aa2266','#2288aa'];
      ctx.fillStyle = colors[i % 4];
      ctx.beginPath();
      ctx.arc(nx, ny, nr, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;
  }

  // Snow: falling snowflakes
  if (theme.snow) {
    ctx.fillStyle = '#ffffff';
    for (let i = 0; i < 60; i++) {
      const sx = ((i * 73.7 + Date.now() * 0.02 * (0.5 + (i % 3) * 0.3)) % vw + vw) % vw;
      const sy = ((i * 137.3 + Date.now() * 0.03 * (0.3 + (i % 4) * 0.2)) % vh + vh) % vh;
      ctx.globalAlpha = 0.3 + (i % 5) * 0.1;
      const sz = i % 3 === 0 ? 2 : 1;
      ctx.fillRect(sx, sy, sz, sz);
    }
    ctx.globalAlpha = 1;
  }

  // Mountains (parallax)
  drawMountains(stageNum);

  // Water: animated waves at bottom
  if (theme.water) {
    const waterY = vh - 80;
    ctx.globalAlpha = 0.3;
    ctx.fillStyle = '#0066aa';
    ctx.beginPath();
    ctx.moveTo(0, vh);
    for (let x = 0; x <= vw; x += 8) {
      const wy = waterY + Math.sin((x + camX * 0.3 + Date.now() * 0.002) * 0.05) * 8;
      ctx.lineTo(x, wy);
    }
    ctx.lineTo(vw, vh);
    ctx.fill();
    ctx.globalAlpha = 0.15;
    ctx.fillStyle = '#44aaff';
    ctx.beginPath();
    ctx.moveTo(0, vh);
    for (let x = 0; x <= vw; x += 8) {
      const wy = waterY + 10 + Math.sin((x + camX * 0.2 + Date.now() * 0.003) * 0.04) * 6;
      ctx.lineTo(x, wy);
    }
    ctx.lineTo(vw, vh);
    ctx.fill();
    ctx.globalAlpha = 1;
  }
}

function drawMountains(stageNum) {
  const theme = getTheme(stageNum);
  const vw = viewW(), vh = viewH();
  const colors = theme.mountains;

  // Desert: flat mesa shapes; Snow: rounded; Space: angular; Water: wave-like
  for (let layer = 0; layer < 3; layer++) {
    const parallax = 0.1 + layer * 0.1;
    const offsetX = -camX * parallax;
    ctx.fillStyle = colors[layer];
    ctx.beginPath();
    ctx.moveTo(0, vh);
    for (let x = 0; x <= vw + 40; x += 40) {
      const worldX = x - (offsetX % 200);
      let h;
      if (theme.desert) {
        // Flat-topped mesas
        h = 60 + Math.abs(Math.sin(worldX * 0.008 + layer * 2)) * 50 + layer * 10;
      } else if (theme.snow) {
        // Rounded gentle peaks
        h = 90 + Math.sin(worldX * 0.007 + layer * 1.5) * 60 + Math.sin(worldX * 0.02) * 15;
      } else if (theme.space) {
        // Jagged angular
        h = 50 + ((Math.sin(worldX * 0.015 + layer) > 0 ? 1 : -1) * 30) + Math.sin(worldX * 0.03) * 20 + layer * 15;
      } else {
        h = 80 + Math.sin(worldX * 0.01 + layer * 2) * 40 + Math.sin(worldX * 0.023 + layer) * 25;
      }
      ctx.lineTo(x, vh - 100 - layer * 30 - h);
    }
    ctx.lineTo(vw, vh);
    ctx.fill();
  }

  // Snow: white mountain caps
  if (theme.snow) {
    ctx.fillStyle = '#ddeeff';
    ctx.globalAlpha = 0.4;
    const parallax = 0.15;
    const offsetX = -camX * parallax;
    ctx.beginPath();
    ctx.moveTo(0, vh);
    for (let x = 0; x <= vw + 40; x += 40) {
      const worldX = x - (offsetX % 200);
      const h = 90 + Math.sin(worldX * 0.007 + 1.5) * 60 + Math.sin(worldX * 0.02) * 15;
      const peakY = vh - 130 - h;
      ctx.lineTo(x, peakY + 15);
    }
    ctx.lineTo(vw, vh);
    ctx.fill();
    ctx.globalAlpha = 1;
  }
}

// --- TILE DRAWING ---
function drawTiles(level) {
  const theme = getTheme(stage);
  const startCol = Math.max(0, Math.floor(camX / TILE) - 1);
  const endCol = Math.min(level.cols, Math.ceil((camX + viewW()) / TILE) + 1);
  const startRow = Math.max(0, Math.floor(camY / TILE) - 1);
  const endRow = Math.min(level.rows, Math.ceil((camY + viewH()) / TILE) + 1);

  for (let r = startRow; r < endRow; r++) {
    for (let c = startCol; c < endCol; c++) {
      const tileVal = level.map[r][c];
      if (!tileVal) continue;

      const tx = c * TILE - camX;
      const ty = r * TILE;

      if (tileVal === 3) {
        // --- WATER / LAVA TILE ---
        const t = animatedTilesEnabled ? waterAnimFrame : 0;
        const wave = Math.sin((c * 0.8 + t * 0.05)) * 3;
        if (theme.lava) {
          // Lava rendering ‚Äî animated flow
          ctx.globalAlpha = 0.75;
          const lavaFlicker = Math.sin(t * 0.1 + c * 1.2) * 0.1;
          const lavaFlow = animatedTilesEnabled ? Math.sin(t * 0.03 + c * 0.5) * 2 : 0;
          ctx.fillStyle = '#cc3300';
          ctx.fillRect(tx, ty + wave * 0.5, TILE, TILE);
          ctx.fillStyle = '#ff6600';
          ctx.globalAlpha = 0.5 + lavaFlicker;
          ctx.fillRect(tx, ty + wave * 0.5, TILE, 5);
          // Animated lava streaks
          if (animatedTilesEnabled) {
            ctx.fillStyle = '#ff4400';
            ctx.globalAlpha = 0.3 + Math.sin(t * 0.07 + c * 2) * 0.2;
            const streakX = ((t * 0.5 + c * 7) % TILE);
            ctx.fillRect(tx + streakX, ty + lavaFlow + 6, 6, 2);
            ctx.fillRect(tx + ((streakX + 10) % TILE), ty + lavaFlow + 12, 4, 2);
          }
          // Lava glow
          ctx.fillStyle = '#ffaa00';
          ctx.globalAlpha = 0.2 + Math.sin(t * 0.13 + c * 0.7) * 0.15;
          ctx.fillRect(tx + (c * 5 % 16), ty + wave * 0.5 + 3, 10, 3);
          // Lava bubble
          if (animatedTilesEnabled && Math.sin(t * 0.04 + c * 3.7) > 0.92) {
            ctx.fillStyle = '#ffcc00';
            ctx.globalAlpha = 0.6;
            const bx = tx + ((c * 13 + Math.floor(t * 0.2)) % (TILE - 4));
            ctx.beginPath();
            ctx.arc(bx + 2, ty + 4 + wave * 0.3, 2, 0, Math.PI * 2);
            ctx.fill();
          }
          ctx.globalAlpha = 1;
        } else {
          // Water rendering ‚Äî animated flow
          const waterFlow = animatedTilesEnabled ? Math.sin(t * 0.04 + c * 0.3) * 1.5 : 0;
          ctx.globalAlpha = 0.55;
          ctx.fillStyle = '#0055aa';
          ctx.fillRect(tx, ty + wave, TILE, TILE);
          ctx.fillStyle = '#44aaff';
          ctx.globalAlpha = 0.2;
          ctx.fillRect(tx, ty + wave, TILE, 3);
          // Animated ripples
          if (animatedTilesEnabled) {
            ctx.fillStyle = '#66ccff';
            ctx.globalAlpha = 0.12 + Math.sin(t * 0.06 + c * 1.8) * 0.08;
            const rippleX = ((t * 0.3 + c * 11) % TILE);
            ctx.fillRect(tx + rippleX, ty + wave + 4 + waterFlow, 8, 1);
            ctx.fillRect(tx + ((rippleX + 12) % TILE), ty + wave + 10 + waterFlow, 6, 1);
          }
          // Shimmer
          ctx.fillStyle = '#88ddff';
          ctx.globalAlpha = 0.15 + Math.sin(t * 0.08 + c) * 0.1;
          ctx.fillRect(tx + (c * 7 % 20), ty + wave + 5, 8, 2);
          // Foam highlight (surface)
          if (animatedTilesEnabled && r > 0 && level.map[r-1][c] !== 3) {
            ctx.fillStyle = '#cceeFF';
            ctx.globalAlpha = 0.2 + Math.sin(t * 0.05 + c * 2) * 0.1;
            ctx.fillRect(tx, ty + wave - 1, TILE, 2);
          }
          ctx.globalAlpha = 1;
        }

      } else if (tileVal === 2) {
        // --- LADDER ---
        const ladderMetal = theme.space || theme.snow || theme.cyber;
        const ladderOrganic = theme.alien;
        const railColor = ladderMetal ? '#8888aa' : (ladderOrganic ? '#6b3a7d' : (theme.lava ? '#8B4513' : '#8B6914'));
        const railHL = ladderMetal ? '#aaaacc' : (ladderOrganic ? '#8855aa' : (theme.lava ? '#A0522D' : '#A87D20'));
        const rungColor = ladderMetal ? '#7777aa' : (ladderOrganic ? '#5a2d6a' : (theme.lava ? '#7B3F00' : '#9B7418'));
        const rungHL = ladderMetal ? '#9999bb' : (ladderOrganic ? '#7744aa' : (theme.lava ? '#8B5A2B' : '#B8891E'));

        ctx.fillStyle = railColor;
        ctx.fillRect(tx + 2, ty, 4, TILE);
        ctx.fillRect(tx + TILE - 6, ty, 4, TILE);
        ctx.fillStyle = railHL;
        ctx.fillRect(tx + 2, ty, 2, TILE);
        ctx.fillRect(tx + TILE - 6, ty, 2, TILE);
        ctx.fillStyle = rungColor;
        const rungSpacing = TILE / 3;
        for (let rg = 0; rg < 3; rg++) {
          const ry = ty + 4 + rg * rungSpacing;
          ctx.fillRect(tx + 6, ry, TILE - 12, 3);
          ctx.fillStyle = rungHL;
          ctx.fillRect(tx + 6, ry, TILE - 12, 1);
          ctx.fillStyle = rungColor;
        }
        ctx.fillStyle = 'rgba(0,0,0,0.15)';
        ctx.fillRect(tx + 4, ty, 1, TILE);
        ctx.fillRect(tx + TILE - 3, ty, 1, TILE);

      } else {
        // --- SOLID TILE (1) or TREASURE TILE (4) ---
        const isTop = r === 0 || (level.map[r - 1][c] !== 1 && level.map[r - 1][c] !== 4);
        if (isTop) {
          ctx.fillStyle = theme.tileTop;
          ctx.fillRect(tx, ty, TILE, 4);
          ctx.fillStyle = theme.tileFill;
          ctx.fillRect(tx, ty + 4, TILE, TILE - 4);
          // Snow cap
          if (theme.snow) {
            ctx.fillStyle = '#eef4ff';
            ctx.fillRect(tx, ty, TILE, 3);
            ctx.fillStyle = '#ddeeff';
            ctx.fillRect(tx + 2, ty + 3, TILE - 4, 2);
          }
        } else {
          ctx.fillStyle = theme.tileInner;
          ctx.fillRect(tx, ty, TILE, TILE);
        }

        // Brick / pattern lines
        ctx.fillStyle = theme.tileLine;
        if (!isTop) {
          if (theme.space) {
            // Tech grid pattern
            ctx.fillRect(tx, ty, TILE, 1);
            ctx.fillRect(tx, ty, 1, TILE);
            ctx.fillRect(tx + TILE - 1, ty, 1, TILE);
            // Panel light
            if ((r + c) % 4 === 0) {
              ctx.fillStyle = 'rgba(100,200,255,0.08)';
              ctx.fillRect(tx + 4, ty + 4, TILE - 8, TILE - 8);
            }
          } else if (theme.desert) {
            // Sandy cracks
            ctx.fillRect(tx + TILE * 0.3, ty + 2, 1, TILE * 0.6);
            ctx.fillRect(tx + TILE * 0.7, ty + TILE * 0.3, 1, TILE * 0.5);
          } else if (theme.lava) {
            // Volcanic cracks with glow
            ctx.fillRect(tx + TILE * 0.4, ty, 1, TILE);
            ctx.fillRect(tx, ty + TILE * 0.6, TILE, 1);
            if ((r + c) % 3 === 0) {
              ctx.fillStyle = 'rgba(255,100,0,0.08)';
              ctx.fillRect(tx + 2, ty + 2, TILE - 4, TILE - 4);
            }
          } else if (theme.cyber) {
            // Circuit board pattern
            ctx.fillRect(tx, ty, TILE, 1);
            ctx.fillRect(tx, ty, 1, TILE);
            ctx.fillRect(tx + TILE - 1, ty, 1, TILE);
            ctx.fillRect(tx, ty + TILE - 1, TILE, 1);
            // Circuit trace
            if ((r + c) % 3 === 0) {
              ctx.fillStyle = 'rgba(0,255,200,0.1)';
              ctx.fillRect(tx + 3, ty + TILE / 2, TILE - 6, 1);
            }
            if ((r * 3 + c) % 5 === 0) {
              ctx.fillStyle = 'rgba(0,200,255,0.12)';
              ctx.fillRect(tx + TILE / 2, ty + 3, 1, TILE - 6);
            }
          } else if (theme.alien) {
            // Organic texture
            const organicOff = (r * 7 + c * 11) % 13;
            ctx.fillRect(tx + organicOff, ty + 3, 2, TILE * 0.4);
            ctx.fillRect(tx + 2, ty + organicOff, TILE * 0.5, 1);
            // Bioluminescent spots
            if ((r + c) % 4 === 0) {
              ctx.fillStyle = 'rgba(180,0,255,0.1)';
              ctx.fillRect(tx + 4, ty + 4, 4, 4);
            }
          } else {
            ctx.fillRect(tx + TILE / 2, ty, 1, TILE);
            ctx.fillRect(tx, ty + TILE / 2, TILE, 1);
          }
        }

        // Edge highlight
        ctx.fillStyle = 'rgba(255,255,255,0.05)';
        ctx.fillRect(tx, ty, TILE, 1);
        ctx.fillRect(tx, ty, 1, TILE);

        // Treasure sparkle (subtle hint)
        if (tileVal === 4) {
          const sparkle = Math.sin(Date.now() * 0.004 + c * 3 + r * 7);
          if (sparkle > 0.7) {
            ctx.globalAlpha = (sparkle - 0.7) * 2;
            ctx.fillStyle = '#ffff88';
            const sx = tx + ((c * 13 + r * 7) % (TILE - 4)) + 2;
            const sy = ty + ((r * 11 + c * 5) % (TILE - 4)) + 2;
            ctx.fillRect(sx, sy, 2, 2);
            ctx.fillRect(sx - 1, sy + 1, 1, 1);
            ctx.fillRect(sx + 2, sy + 1, 1, 1);
            ctx.globalAlpha = 1;
          }
        }

        // Underground depth darkening
        if (r > level.groundRow) {
          const depth = r - level.groundRow;
          const darken = Math.min(0.65, depth * 0.015);
          ctx.fillStyle = `rgba(0,0,0,${darken})`;
          ctx.fillRect(tx, ty, TILE, TILE);

          // Rock speckle texture for deep tiles
          if (depth > 3) {
            const speckleHash = (c * 7 + r * 13) % 17;
            ctx.fillStyle = `rgba(255,255,255,${0.02 + (speckleHash % 3) * 0.01})`;
            ctx.fillRect(tx + (speckleHash % TILE), ty + ((speckleHash * 3) % TILE), 2, 1);
            ctx.fillRect(tx + ((speckleHash * 7) % (TILE - 2)), ty + ((speckleHash * 5) % (TILE - 2)), 1, 2);
          }
        }
      }
    }
  }
}

// --- COLLISION ---
function tileAt(level, x, y) {
  const c = Math.floor(x / TILE);
  const r = Math.floor(y / TILE);
  if (r < 0 || r >= level.rows || c < 0 || c >= level.cols) return 0;
  const v = level.map[r][c];
  return (v === 1 || v === 4) ? 1 : 0; // solid tiles and treasure tiles block
}

function ladderAt(level, x, y) {
  const c = Math.floor(x / TILE);
  const r = Math.floor(y / TILE);
  if (r < 0 || r >= level.rows || c < 0 || c >= level.cols) return false;
  return level.map[r][c] === 2;
}

function rectCollide(a, b) {
  return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
}

// --- GAME INIT ---
function initGame() {
  player = createPlayer(40, selectedCharacter);
  if (coopMode) {
    player2 = createPlayer(80, selectedCharacter2);
  } else {
    player2 = null;
  }
  level = generateLevel(stage);
  spawnEnemies(level, stage);
  spawnPowerups(level, stage);
  spawnObjects(level, stage);
  spawnDecorations(level, stage);
  spawnVehicles(level, stage);
  spawnSecretExits(level, stage);
  spawnHazards(level, stage);
  spawnMiniBosses(level, stage);
  bullets = [];
  enemyBullets = [];
  particles = [];
  popups = [];
  treasureItems = [];
  playerSpeedBoost = 0;
  freezeFrames = 0;
  slowMo = 0;
  shakeIntensity = 0;
  shakeDuration = 0;
  flashAlpha = 0;
  camX = 0;
  camY = 0;
  fusionHeldWeapon = null;
  fusionTimer = 0;

  // Place player on ground
  const col1 = Math.floor(player.x / TILE);
  for (let r = 0; r < level.rows; r++) {
    if (col1 >= 0 && col1 < level.cols && level.map[r][col1] === 1) {
      player.y = r * TILE - player.h;
      break;
    }
  }
  
  // Place player2 on ground (co-op)
  if (player2) {
    const col2 = Math.floor(player2.x / TILE);
    for (let r = 0; r < level.rows; r++) {
      if (col2 >= 0 && col2 < level.cols && level.map[r][col2] === 1) {
        player2.y = r * TILE - player2.h;
        break;
      }
    }
  }
}

// --- UPDATE ---
function update() {
  if (gameState !== 'playing' && gameState !== 'demo') return;

  // Guest in online multiplayer: don't run simulation locally (state comes from host)
  if (mpRole === 'guest' && mpConnected) return;

  updatePlayer(player, isLeft, isRight, isUp, isDown, isJump, isJumpKey, isShoot, isGrapple);
  
  if (coopMode && player2) {
    // Online host: use remote inputs from the guest
    if (mpRole === 'host' && mpConnected) {
      updatePlayer(player2, mpRemoteLeft, mpRemoteRight, mpRemoteUp, mpRemoteDown,
                   mpRemoteJump, mpRemoteJumpKey, mpRemoteShoot, mpRemoteGrapple);
    } else {
      updatePlayer(player2, isLeft2, isRight2, isUp2, isDown2, isJump2, isJumpKey2, isShoot2, isGrapple2);
    }
  }

  // Check game over: all players dead
  if (player.dead && player.lives <= 0) {
    if (coopMode && player2 && !player2.dead && player2.lives > 0) {
      // Player 2 still alive
    } else {
      handleModeGameOver();
      return;
    }
  }
  if (coopMode && player2 && player2.dead && player2.lives <= 0) {
    if (!player.dead && player.lives > 0) {
      // Player 1 still alive
    } else {
      handleModeGameOver();
      return;
    }
  }

  updateEnemiesAndBullets();
  updateHazards();
  updateParticles();
  updateCombo();
  updateFusionTimer();
  updateSpeedrun();
  updateAccessibility();
  checkAchievements();
  // Hazard collisions
  if (player && !player.dead) checkHazardCollisions(player);
  if (coopMode && player2 && !player2.dead) checkHazardCollisions(player2);
  // Mode-specific updates
  updateEndlessMode();
  updateTimeAttack();
  if (gameMode === 'bossrush') bossRushTimer++;
  checkChallengeCompletion();
}

function updatePlayer(p, getLeft, getRight, getUp, getDown, getJump, getJumpKey, getShoot, getGrapple) {

  if (p.dead) {
    p.respawnTimer--;
    if (p.respawnTimer <= 0) {
      if (p.lives <= 0) {
        // In co-op, don't game-over if the other player is still alive
        // (update() handles the combined game-over check)
        return;
      }
      p.dead = false;
      p.x = camX + 60;
      p.invincible = diffSettings.respawnInvincibility;
      p.weapon = WEAPONS.RIFLE;
      p.grapple = null;
      p.grappleCooldown = 0;
      p.digging = false;
      p.digTimer = 0;
      p.wallClimbing = false;
      p.wallClimbDir = 0;
      // Reset vehicle state on respawn
      p.inVehicle = false;
      p.vehicleType = null;
      p.vehicleHP = 0;
      p.vehicleMaxHP = 0;
      p.w = 20;
      p.h = 32;
      for (let r = 0; r < level.rows; r++) {
        if (tileAt(level, p.x + p.w / 2, r * TILE)) {
          p.y = r * TILE - p.h;
          break;
        }
      }
      p.vy = 0;
      p.onLadder = false;
      // Reset camera to surface if player died underground
      if (camY > level.groundRow * TILE - viewH()) {
        camY = 0;
      }
    }
    return;
  }

  // Invincibility countdown
  if (p.invincible > 0) p.invincible--;

  // Check if player center overlaps a ladder
  const pCenterX = p.x + p.w / 2;
  const pFeetY = p.y + p.h;
  const pMidY = p.y + p.h / 2;
  const ladderCol = Math.floor(pCenterX / TILE);
  const ladderCenterX = ladderCol * TILE + TILE / 2;
  const distToLadderCenter = Math.abs(pCenterX - ladderCenterX);
  const onLadderTile = ladderAt(level, pCenterX, pMidY);
  const ladderBelow = ladderAt(level, pCenterX, pFeetY + 2);
  const movingHorizontally = getLeft() || getRight();

  // Enter ladder: press Up/Down WITHOUT moving left/right, and be close to ladder center
  if (!p.onLadder) {
    if (getUp() && !movingHorizontally && onLadderTile && distToLadderCenter < 10) {
      p.onLadder = true;
      p.wallClimbing = false; p.wallClimbDir = 0;
      p.x = ladderCenterX - p.w / 2;
      p.vx = 0; p.vy = 0;
    }
    if (getDown() && !movingHorizontally && p.onGround && ladderBelow && distToLadderCenter < 10) {
      p.onLadder = true;
      p.wallClimbing = false; p.wallClimbDir = 0;
      p.y += 4;
      p.x = ladderCenterX - p.w / 2;
      p.vx = 0; p.vy = 0;
      p.onGround = false;
    }
  }

  if (p.onLadder) {
    // --- LADDER CLIMBING MODE ---
    p.prone = false;
    p.vy = 0;
    p.vx = 0;

    // Climb up/down
    if (getUp()) {
      p.vy = -climbSpeed;
      p.climbFrame += 0.15;
    } else if (getDown()) {
      p.vy = climbSpeed;
      p.climbFrame += 0.15;
    }

    // Walk off ladder by holding left/right
    if (getLeft() || getRight()) {
      p.onLadder = false;
      p.vx = (getLeft() ? -1 : 1) * playerSpeed;
      p.facing = getLeft() ? -1 : 1;
      // Don't re-enter immediately
    } else {
      // Update facing for aiming
      if (getLeft()) p.facing = -1;
      if (getRight()) p.facing = 1;
    }

    // Jump off ladder
    if (p.onLadder && getJumpKey()) {
      p.onLadder = false;
      p.vy = jumpForce * 0.7;
      if (getLeft()) p.vx = -playerSpeed;
      else if (getRight()) p.vx = playerSpeed;
      playSound('jump');
    }

    if (p.onLadder) {
      // Move Y
      p.y += p.vy;

      const updatedCenterX = p.x + p.w / 2;
      const ladCol = Math.floor(updatedCenterX / TILE);

      if (p.vy < 0) {
        // --- CLIMBING UP ---
        // Check if head entered a solid tile
        const headRow = Math.floor(p.y / TILE);
        if (headRow >= 0 && headRow < level.rows && level.map[headRow][ladCol] === 1) {
          // Is there a ladder tile directly below this solid? ‚Üí top of ladder exit
          if (headRow + 1 < level.rows && level.map[headRow + 1][ladCol] === 2) {
            // Land on top of the platform
            p.onLadder = false;
            p.vy = 0;
            p.y = headRow * TILE - p.h;
            p.onGround = true;
          } else {
            // Regular ceiling ‚Äî just stop
            p.y = (headRow + 1) * TILE;
            p.vy = 0;
          }
        } else {
          // No ceiling hit ‚Äî check if we left ladder tiles entirely
          const stillOnLadder = ladderAt(level, updatedCenterX, p.y + p.h / 2) ||
                                ladderAt(level, updatedCenterX, p.y + p.h - 4);
          if (!stillOnLadder) {
            p.onLadder = false;
            p.vy = 0;
            // Try to land on nearest solid below
            for (let searchR = Math.max(0, Math.floor(p.y / TILE)); searchR < level.rows; searchR++) {
              if (level.map[searchR][ladCol] === 1) {
                p.y = searchR * TILE - p.h;
                p.onGround = true;
                break;
              }
            }
          }
        }

      } else if (p.vy > 0) {
        // --- CLIMBING DOWN ---
        // Check ground collision at feet
        let hitGround = false;
        for (let checkX = p.x + 2; checkX < p.x + p.w - 2; checkX += 8) {
          if (tileAt(level, checkX, p.y + p.h)) {
            p.y = Math.floor((p.y + p.h) / TILE) * TILE - p.h;
            p.vy = 0;
            p.onGround = true;
            p.onLadder = false;
            hitGround = true;
            break;
          }
        }
        // Check if we left ladder tiles (fell off bottom)
        if (!hitGround) {
          const stillOnLadder = ladderAt(level, updatedCenterX, p.y + p.h / 2) ||
                                ladderAt(level, updatedCenterX, p.y + p.h - 4);
          if (!stillOnLadder) {
            p.onLadder = false;
          }
        }
      }
      // If vy === 0 (holding still), nothing to check
    }

    // Aim direction on ladder
    if (p.onLadder) {
      if (getUp()) { p.aimX = 0; p.aimY = -1; }
      else if (getDown()) { p.aimX = 0; p.aimY = 1; }
      else { p.aimX = p.facing; p.aimY = 0; }
    }

  } else if (p.wallClimbing) {
    // --- WALL CLIMBING MODE ---
    p.prone = false;
    const wallClimbSpeed = climbSpeed * 0.7 * (p.ability === 'wallMaster' ? 1.5 : 1);

    // Check wall still exists on the side we're climbing
    let wallStillThere = false;
    for (let checkY = p.y + 2; checkY < p.y + p.h; checkY += 8) {
      if (p.wallClimbDir === 1 && tileAt(level, p.x + p.w + 1, checkY)) { wallStillThere = true; break; }
      if (p.wallClimbDir === -1 && tileAt(level, p.x - 1, checkY)) { wallStillThere = true; break; }
    }

    // Check ground beneath
    let touchingGround = false;
    for (let checkX = p.x + 2; checkX < p.x + p.w - 2; checkX += 8) {
      if (tileAt(level, checkX, p.y + p.h + 1)) { touchingGround = true; break; }
    }

    if (!wallStillThere || touchingGround) {
      // Wall gone or landed ‚Äî exit wall climb
      p.wallClimbing = false;
      p.wallClimbDir = 0;
      if (touchingGround) {
        p.onGround = true;
        p.vy = 0;
      }
    } else {
      // Climb up
      if (getUp()) {
        p.vy = -wallClimbSpeed;
        p.wallClimbFrame += 0.15;
        if (Math.floor(p.wallClimbFrame * 10) % 15 === 0) playSound('wall_climb');
      } else if (getDown()) {
        // Slide down slowly
        p.vy = wallClimbSpeed * 0.8;
        p.wallClimbFrame += 0.1;
      } else {
        // Cling to wall ‚Äî slow slide
        p.vy = 0.3;
        p.wallClimbFrame += 0.02;
      }
      p.vx = 0;

      // Wall jump ‚Äî press jump to leap away from wall
      if (getJumpKey()) {
        p.wallClimbing = false;
        p.vy = jumpForce * 0.85;
        p.vx = -p.wallClimbDir * playerSpeed * 1.2;
        p.facing = -p.wallClimbDir;
        p.wallClimbDir = 0;
        playSound('jump');
      }

      // Move Y
      p.y += p.vy;

      // Y collision ‚Äî ceiling
      if (p.vy < 0) {
        for (let checkX = p.x + 2; checkX < p.x + p.w - 2; checkX += 8) {
          if (tileAt(level, checkX, p.y)) {
            p.y = Math.floor(p.y / TILE) * TILE + TILE;
            p.vy = 0;
          }
        }
      }
      // Y collision ‚Äî floor
      if (p.vy > 0) {
        for (let checkX = p.x + 2; checkX < p.x + p.w - 2; checkX += 8) {
          if (tileAt(level, checkX, p.y + p.h)) {
            p.y = Math.floor((p.y + p.h) / TILE) * TILE - p.h;
            p.vy = 0;
            p.onGround = true;
            p.wallClimbing = false;
            p.wallClimbDir = 0;
          }
        }
      }

      // Aim direction while wall climbing
      p.aimX = -p.wallClimbDir;
      p.aimY = 0;
      if (getUp()) p.aimY = -0.7;
      if (getDown()) p.aimY = 0.7;
    }

  } else if (p.inVehicle) {
    // --- VEHICLE MOVEMENT ---
    const vDef = VEHICLES[p.vehicleType];
    const vSpeed = vDef.speed;
    if (p.vehicleHitFlash > 0) p.vehicleHitFlash--;

    // Horizontal
    if (getLeft()) { p.vx = -vSpeed; p.facing = -1; }
    else if (getRight()) { p.vx = vSpeed; p.facing = 1; }
    else p.vx = 0;

    // Aim (simplified ‚Äî horizontal + up)
    if (getUp() && !getLeft() && !getRight()) { p.aimX = 0; p.aimY = -1; }
    else if (getUp() && (getLeft() || getRight())) { p.aimX = p.facing; p.aimY = -0.7; }
    else { p.aimX = p.facing; p.aimY = 0; }
    const aimLen = Math.sqrt(p.aimX * p.aimX + p.aimY * p.aimY);
    if (aimLen > 0) { p.aimX /= aimLen; p.aimY /= aimLen; }

    // Jump
    if (p.vehicleType === 'HOVERBIKE') {
      // Hoverbike: hold jump to hover upward, release to drift down
      if (getJump()) { p.vy = Math.max(p.vy - 0.8, vDef.jumpForce); }
      else { p.vy += gravity * 0.6; }
    } else {
      // Tank: standard jump but weaker
      if (getJump() && p.onGround) {
        p.vy = vDef.jumpForce;
        p.onGround = false;
        playSound('jump');
      }
      p.vy += gravity;
    }
    if (p.vy > maxFall) p.vy = maxFall;

    // Move X
    p.x += p.vx;
    if (p.x < 0) p.x = 0;
    if (p.x + p.w > level.cols * TILE) p.x = level.cols * TILE - p.w;
    // X collision
    for (let checkY = p.y + 2; checkY < p.y + p.h; checkY += 8) {
      if (p.vx > 0 && tileAt(level, p.x + p.w, checkY)) {
        p.x = Math.floor((p.x + p.w) / TILE) * TILE - p.w;
        p.vx = 0;
      }
      if (p.vx < 0 && tileAt(level, p.x, checkY)) {
        p.x = Math.floor(p.x / TILE) * TILE + TILE;
        p.vx = 0;
      }
    }
    // Move Y
    p.y += p.vy;
    p.onGround = false;
    if (p.vy > 0) {
      for (let checkX = p.x + 2; checkX < p.x + p.w - 2; checkX += 8) {
        if (tileAt(level, checkX, p.y + p.h)) {
          p.y = Math.floor((p.y + p.h) / TILE) * TILE - p.h;
          p.vy = 0;
          p.onGround = true;
        }
      }
    }
    if (p.vy < 0) {
      for (let checkX = p.x + 2; checkX < p.x + p.w - 2; checkX += 8) {
        if (tileAt(level, checkX, p.y)) {
          p.y = Math.floor(p.y / TILE) * TILE + TILE;
          p.vy = 0;
        }
      }
    }

    // Vehicle auto-fire
    if (p.vehicleFireTimer > 0) p.vehicleFireTimer--;
    if (getShoot() && p.vehicleFireTimer <= 0) {
      p.vehicleFireTimer = vDef.fireRate;
      const bx = p.x + p.w / 2 + p.aimX * (p.w / 2);
      const by = p.y + (p.vehicleType === 'TANK' ? 6 : p.h / 2) + p.aimY * 10;
      const bvx = p.aimX * vDef.bulletSpeed;
      const bvy = p.aimY * vDef.bulletSpeed;
      bullets.push({
        x: bx, y: by, vx: bvx, vy: bvy,
        damage: vDef.damage, owner: p,
        w: p.vehicleType === 'TANK' ? 8 : 4,
        h: p.vehicleType === 'TANK' ? 8 : 4,
        life: 80, color: vDef.bulletColor,
        btype: p.vehicleType === 'TANK' ? 'tank_shell' : 'vehicle',
      });
      if (p.vehicleType === 'TANK') {
        triggerShake(4, 4);
        spawnParticles(bx, by, '#ffcc44', 8, 4, 15);
        playSound('rocket');
      } else {
        playSound('laser');
      }
    }

    // Exit vehicle with grapple key
    if (getGrapple()) {
      exitVehicle(p);
    }

    // Hoverbike hover particles
    if (p.vehicleType === 'HOVERBIKE' && !p.onGround && Math.random() < 0.3) {
      spawnParticles(p.x + p.w / 2 + (Math.random() - 0.5) * 20, p.y + p.h, '#44ccff', 1, 2, 12);
    }
    // Tank treads particles
    if (p.vehicleType === 'TANK' && Math.abs(p.vx) > 0 && p.onGround && Math.random() < 0.4) {
      spawnParticles(p.x + (p.facing < 0 ? p.w : 0), p.y + p.h, '#886644', 2, 1.5, 15);
    }

  } else {
    // --- NORMAL GROUND MOVEMENT ---
    // Movement
    p.prone = getDown() && p.onGround;
    const speed = p.prone ? 0 : (playerSpeed * (playerSpeedBoost > 0 ? 1.6 : 1) * (p.speedMult || 1));

    // --- DIGGING (all directions) ---
    // Dig-up only when a solid tile is directly above player's head
    // Dig-left/right only when pressed against a wall
    // Dig-down while prone
    let digTargetC = -1, digTargetR = -1, digDirX = 0, digDirY = 0;

    // Check for solid tile directly above player head
    const headC = Math.floor((p.x + p.w / 2) / TILE);
    const headR = Math.floor((p.y - 2) / TILE);
    const solidAbove = headR >= 0 && headR < level.rows && headC >= 0 && headC < level.cols &&
                       (level.map[headR][headC] === 1 || level.map[headR][headC] === 4);

    if (p.prone && p.onGround) {
      // Dig DOWN (while prone)
      digTargetC = Math.floor((p.x + p.w / 2) / TILE);
      digTargetR = Math.floor((p.y + p.h + 2) / TILE);
      digDirX = 0; digDirY = 1;
    } else if (getUp() && !getLeft() && !getRight() && p.onGround && solidAbove) {
      // Dig UP ‚Äî only when there's a solid tile right above your head
      digTargetC = headC;
      digTargetR = headR;
      digDirX = 0; digDirY = -1;
    } else if (getLeft() && p.onGround && !p.prone) {
      // Dig LEFT ‚Äî check if tile is directly adjacent
      const edgeX = p.x - 1;
      const checkC = Math.floor(edgeX / TILE);
      const checkR = Math.floor((p.y + p.h * 0.5) / TILE);
      if (checkC >= 0 && checkR >= 0 && checkR < level.rows && checkC < level.cols &&
          (level.map[checkR][checkC] === 1 || level.map[checkR][checkC] === 4)) {
        const tileRight = (checkC + 1) * TILE;
        if (p.x - tileRight < 3) {
          digTargetC = checkC; digTargetR = checkR;
          digDirX = -1; digDirY = 0;
        }
      }
    } else if (getRight() && p.onGround && !p.prone) {
      // Dig RIGHT
      const edgeX = p.x + p.w + 1;
      const checkC = Math.floor(edgeX / TILE);
      const checkR = Math.floor((p.y + p.h * 0.5) / TILE);
      if (checkC >= 0 && checkR >= 0 && checkR < level.rows && checkC < level.cols &&
          (level.map[checkR][checkC] === 1 || level.map[checkR][checkC] === 4)) {
        const tileLeft = checkC * TILE;
        if (tileLeft - (p.x + p.w) < 3) {
          digTargetC = checkC; digTargetR = checkR;
          digDirX = 1; digDirY = 0;
        }
      }
    }

    // Check if target is diggable
    const canDig = digTargetR >= 0 && digTargetR < level.rows && digTargetC >= 0 && digTargetC < level.cols &&
                   (level.map[digTargetR][digTargetC] === 1 || level.map[digTargetR][digTargetC] === 4);

    if (canDig && digTargetC === p.digCol && digTargetR === p.digRow) {
      p.digTimer++;
      p.digging = true;
      p.digDirX = digDirX;
      p.digDirY = digDirY;

      // Dig particles
      if (p.digTimer % 6 === 0) {
        const theme = getTheme(stage);
        const dirtColor = theme.desert ? '#ccaa66' : theme.snow ? '#ccddee' : theme.space ? '#555577' : '#886644';
        const px = digTargetC * TILE + TILE / 2;
        const py = digTargetR * TILE + TILE / 2;
        spawnParticles(px, py, dirtColor, 2, 2, 10);
        playSound('dig');
      }

      if (p.digTimer >= DIG_TIME) {
        // Break tile!
        const tileVal = level.map[digTargetR][digTargetC];
        const tx = digTargetC * TILE + TILE / 2;
        const ty = digTargetR * TILE + TILE / 2;
        const theme = getTheme(stage);
        const dirtColor = theme.desert ? '#ccaa66' : theme.snow ? '#ccddee' : theme.space ? '#555577' : '#886644';

        spawnParticles(tx, ty, dirtColor, 10, 4, 20);
        spawnDebris(tx, ty, dirtColor, 6);
        triggerShake(3, 5);

        if (tileVal === 4) {
          playSound('treasure');
          const tKey = digTargetR + ',' + digTargetC;
          if (!level.treasureMap) level.treasureMap = {};
          const tType = level.treasureMap[tKey] || 'gem_small';
          treasureItems.push({
            x: tx - 10, y: ty - 10,
            w: 20, h: 20,
            vy: digDirY <= 0 ? -6 : -8,
            vx: -digDirX * 3 + (Math.random() - 0.5) * 2,
            type: tType,
            life: 300,
            onGround: false,
            bobPhase: Math.random() * Math.PI * 2,
          });
          spawnGlowParticles(tx, ty, '#ffff44', 15, 5, 30);
          spawnRing(tx, ty, '#ffcc00', 40, 12);
        } else {
          playSound('explosion');
          addScore(10);
          spawnPopup(tx, ty - 10, '+10', '#ccaa66', 10);
        }

        level.map[digTargetR][digTargetC] = 0;
        p.digTimer = 0;
        p.digging = false;
        p.digCol = -1;
        p.digRow = -1;
      }
    } else if (canDig) {
      p.digTimer = 0;
      p.digCol = digTargetC;
      p.digRow = digTargetR;
      p.digging = true;
      p.digDirX = digDirX;
      p.digDirY = digDirY;
    } else {
      p.digTimer = 0;
      p.digging = false;
      p.digCol = -1;
      p.digRow = -1;
    }

    // Speed boost timer
    if (playerSpeedBoost > 0) playerSpeedBoost--;

    if (getLeft() && !p.prone) { p.vx = -speed; p.facing = -1; }
    else if (getRight() && !p.prone) { p.vx = speed; p.facing = 1; }
    else p.vx = 0;

    // Aim direction
    if (getUp() && !getLeft() && !getRight()) { p.aimX = 0; p.aimY = -1; }
    else if (getDown() && !p.onGround) { p.aimX = 0; p.aimY = 1; }
    else if (getUp() && (getLeft() || getRight())) { p.aimX = p.facing; p.aimY = -0.7; }
    else if (getDown() && (getLeft() || getRight()) && !p.onGround) { p.aimX = p.facing; p.aimY = 0.7; }
    else { p.aimX = p.facing; p.aimY = 0; }

    // Normalize aim
    const aimLen = Math.sqrt(p.aimX * p.aimX + p.aimY * p.aimY);
    if (aimLen > 0) { p.aimX /= aimLen; p.aimY /= aimLen; }

    // Jump ‚Äî works everywhere. Dig-up only blocks jump when actively digging upward
    const digUpActive = p.digging && p.digDirY === -1;
    if (getJump() && p.onGround && !p.prone && !digUpActive) {
      p.vy = jumpForce;
      p.onGround = false;
      p.hasDoubleJump = (p.ability === 'doubleJump');
      playSound('jump');
    }
    // Double jump (SCOUT ability)
    if (p.ability === 'doubleJump' && p.hasDoubleJump && getJump() && !p.onGround && !p._djPressed) {
      p.vy = jumpForce * 0.8;
      p.hasDoubleJump = false;
      p._djPressed = true;
      spawnParticles(p.x + p.w / 2, p.y + p.h, '#33cccc', 6, 3, 15);
      playSound('jump');
    }
    if (!getJump()) p._djPressed = false;

    // Gravity
    p.vy += gravity;
    if (p.vy > maxFall) p.vy = maxFall;

    // Move X
    p.x += p.vx;
    if (p.x < 0) p.x = 0;
    if (p.x + p.w > level.cols * TILE) p.x = level.cols * TILE - p.w;

    // X collision
    const checkH = p.prone ? p.h - 8 : p.h;
    for (let checkY = p.y + 2; checkY < p.y + checkH; checkY += 8) {
      if (p.vx > 0 && tileAt(level, p.x + p.w, checkY)) {
        p.x = Math.floor((p.x + p.w) / TILE) * TILE - p.w;
        p.vx = 0;
      }
      if (p.vx < 0 && tileAt(level, p.x, checkY)) {
        p.x = Math.floor(p.x / TILE) * TILE + TILE;
        p.vx = 0;
      }
    }

    // Move Y
    p.y += p.vy;
    p.onGround = false;

    // Y collision
    if (p.vy > 0) {
      for (let checkX = p.x + 2; checkX < p.x + p.w - 2; checkX += 8) {
        if (tileAt(level, checkX, p.y + p.h)) {
          p.y = Math.floor((p.y + p.h) / TILE) * TILE - p.h;
          p.vy = 0;
          p.onGround = true;
        }
      }
    }
    if (p.vy < 0) {
      for (let checkX = p.x + 2; checkX < p.x + p.w - 2; checkX += 8) {
        if (tileAt(level, checkX, p.y)) {
          p.y = Math.floor(p.y / TILE) * TILE + TILE;
          p.vy = 0;
        }
      }
    }

    // --- WALL CLIMB ENTRY ---
    // If airborne and pressing up against a wall, start wall climbing
    if (!p.onGround && !p.prone && getUp() && !p.digging) {
      let wallDir = 0;
      // Check wall on right
      for (let checkY = p.y + 2; checkY < p.y + p.h; checkY += 8) {
        if (tileAt(level, p.x + p.w + 1, checkY)) { wallDir = 1; break; }
      }
      // Check wall on left (only if no wall on right)
      if (!wallDir) {
        for (let checkY = p.y + 2; checkY < p.y + p.h; checkY += 8) {
          if (tileAt(level, p.x - 1, checkY)) { wallDir = -1; break; }
        }
      }
      if (wallDir !== 0) {
        p.wallClimbing = true;
        p.wallClimbDir = wallDir;
        p.wallClimbFrame = 0;
        p.vy = 0;
        p.vx = 0;
        p.facing = wallDir;
      }
    }
  }

  // --- GRAPPLE HOOK ---
  if (p.grappleCooldown > 0) p.grappleCooldown--;

  if (getGrapple() && !p.grapple && p.grappleCooldown <= 0 && !p.dead && !p.digging) {
    // Fire grapple in aim direction
    let gx = p.aimX, gy = p.aimY;
    // If aiming straight down, default to up
    if (gy > 0.5 && Math.abs(gx) < 0.3) { gx = 0; gy = -1; }
    const gLen = Math.sqrt(gx * gx + gy * gy);
    if (gLen > 0) { gx /= gLen; gy /= gLen; }

    const hookSpeed = 14;
    runStats.grappleUses++;
    checkAchievements();
    p.grapple = {
      x: p.x + p.w / 2,
      y: p.y + 4,
      vx: gx * hookSpeed,
      vy: gy * hookSpeed,
      anchorX: 0, anchorY: 0,
      anchorR: -1, anchorC: -1,
      isCeiling: false, // latched to world ceiling
      state: 'firing', // firing ‚Üí latched ‚Üí pulling ‚Üí hanging
      life: 50,
      retractTimer: 0,
      ropeLen: 0, // for hanging physics
      swingAngle: 0,
      swingVel: 0,
    };
    p.grappleCooldown = 5;
    playSound('grapple_fire');
  }

  if (p.grapple) {
    const g = p.grapple;

    if (g.state === 'firing') {
      g.x += g.vx;
      g.y += g.vy;
      g.life--;

      // Check if hook hit a solid tile
      const hc = Math.floor(g.x / TILE);
      const hr = Math.floor(g.y / TILE);
      let latched = false;

      if (hr >= 0 && hr < level.rows && hc >= 0 && hc < level.cols &&
          (level.map[hr][hc] === 1 || level.map[hr][hc] === 4)) {
        // Latch onto solid tile
        g.anchorX = hc * TILE + TILE / 2;
        g.anchorY = hr * TILE + TILE / 2;
        g.anchorR = hr;
        g.anchorC = hc;
        g.isCeiling = false;
        latched = true;
      } else if (g.y <= 0 && g.vy < 0) {
        // Latch to world ceiling
        g.anchorX = g.x;
        g.anchorY = 0;
        g.anchorR = -1;
        g.anchorC = -1;
        g.isCeiling = true;
        latched = true;
      }

      if (latched) {
        g.state = 'latched';
        g.retractTimer = 4;
        playSound('grapple_latch');
        spawnParticles(g.anchorX, Math.max(4, g.anchorY), '#aaaaaa', 6, 2, 12);
      } else if (g.life <= 0 || g.x < 0 || g.x > level.cols * TILE || g.y > level.rows * TILE) {
        p.grapple = null;
        p.grappleCooldown = 12;
      }
    } else if (g.state === 'latched') {
      g.retractTimer--;
      if (g.retractTimer <= 0) {
        g.state = 'pulling';
        playSound('grapple_pull');
      }
    } else if (g.state === 'pulling') {
      // Pull player toward a hanging position below anchor
      const hangX = g.anchorX - p.w / 2;
      const hangY = g.anchorY + (g.isCeiling ? 4 : TILE / 2 + 2);

      const dx = hangX - p.x;
      const dy = hangY - p.y;
      const dist = Math.sqrt(dx * dx + dy * dy);

      if (dist < 8) {
        // Arrived ‚Äî transition to hanging
        p.x = hangX;
        p.y = hangY;
        p.vx = 0;
        p.vy = 0;
        g.state = 'hanging';
        g.ropeLen = hangY - g.anchorY + p.h / 2;
        g.swingAngle = 0;
        g.swingVel = 0;
        p.onGround = false;
        p.onLadder = false;
      } else {
        // Move toward hang point
        const pullSpeed = 7;
        const nx = dx / dist;
        const ny = dy / dist;
        const newX = p.x + nx * pullSpeed;
        const newY = p.y + ny * pullSpeed;

        // Collision check
        let blocked = false;
        for (let cy = newY + 2; cy < newY + p.h - 2; cy += 6) {
          for (let cx = newX + 2; cx < newX + p.w - 2; cx += 6) {
            if (tileAt(level, cx, cy)) { blocked = true; break; }
          }
          if (blocked) break;
        }

        if (blocked) {
          // Can't reach ‚Äî just hang at current position
          g.state = 'hanging';
          g.ropeLen = Math.sqrt(Math.pow(p.x + p.w / 2 - g.anchorX, 2) + Math.pow(p.y + p.h / 2 - g.anchorY, 2));
          g.swingAngle = Math.atan2(p.x + p.w / 2 - g.anchorX, p.y + p.h / 2 - g.anchorY);
          g.swingVel = 0;
          p.vx = 0; p.vy = 0;
          p.onGround = false;
        } else {
          p.x = newX;
          p.y = newY;
          p.vx = 0; p.vy = 0;
          p.onGround = false;
          p.onLadder = false;
          if (Math.random() < 0.2) {
            spawnGlowParticles(p.x + p.w / 2 + dx * 0.3, p.y + dy * 0.3, '#88aacc', 1, 1, 10);
          }
        }
      }
    } else if (g.state === 'hanging') {
      // --- HANGING PHYSICS ---
      // Player dangles from anchor with pendulum swing
      const swingGravity = 0.008;
      const swingDamping = 0.995;
      const swingControl = 0.006;

      // Player input swings left/right
      if (getLeft())  g.swingVel -= swingControl;
      if (getRight()) g.swingVel += swingControl;

      // Pendulum physics
      g.swingVel -= Math.sin(g.swingAngle) * swingGravity;
      g.swingVel *= swingDamping;
      g.swingAngle += g.swingVel;

      // Clamp swing to prevent full rotation
      const maxSwing = Math.PI * 0.4;
      if (g.swingAngle > maxSwing) { g.swingAngle = maxSwing; g.swingVel *= -0.3; }
      if (g.swingAngle < -maxSwing) { g.swingAngle = -maxSwing; g.swingVel *= -0.3; }

      // Position player based on pendulum
      const targetX = g.anchorX + Math.sin(g.swingAngle) * g.ropeLen - p.w / 2;
      const targetY = g.anchorY + Math.cos(g.swingAngle) * g.ropeLen - p.h / 2;

      // Check if target position is blocked
      let hangBlocked = false;
      for (let cy = targetY + 2; cy < targetY + p.h - 2; cy += 8) {
        for (let cx = targetX + 2; cx < targetX + p.w - 2; cx += 8) {
          if (tileAt(level, cx, cy)) { hangBlocked = true; break; }
        }
        if (hangBlocked) break;
      }

      if (!hangBlocked) {
        p.x = targetX;
        p.y = targetY;
      } else {
        g.swingVel *= -0.5; // bounce off walls
      }

      p.vx = 0; p.vy = 0;
      p.onGround = false;
      p.onLadder = false;

      // Face direction of swing
      if (Math.abs(g.swingVel) > 0.001) {
        p.facing = g.swingVel > 0 ? 1 : -1;
      }

      // Aim while hanging
      if (getUp() && !getLeft() && !getRight()) { p.aimX = 0; p.aimY = -1; }
      else if (getDown() && !getLeft() && !getRight()) { p.aimX = 0; p.aimY = 1; }
      else if (getUp() && (getLeft() || getRight())) { p.aimX = p.facing; p.aimY = -0.7; }
      else if (getDown() && (getLeft() || getRight())) { p.aimX = p.facing; p.aimY = 0.7; }
      else { p.aimX = p.facing; p.aimY = 0; }
      const hangAimLen = Math.sqrt(p.aimX * p.aimX + p.aimY * p.aimY);
      if (hangAimLen > 0) { p.aimX /= hangAimLen; p.aimY /= hangAimLen; }

      // Rope trail sparkle
      if (Math.random() < 0.05) {
        spawnGlowParticles(g.anchorX, Math.max(4, g.anchorY), '#88aacc', 1, 1, 12);
      }

      // Let go if player presses Down
      if (getDown() && !getLeft() && !getRight()) {
        // Drop from grapple
        p.vy = 1;
        p.vx = g.swingVel * g.ropeLen * 0.5; // carry swing momentum
        p.grapple = null;
        p.grappleCooldown = 15;
      }
    }

    // Release grapple on jump ‚Äî launch with momentum
    if (p.grapple && getJump() && (g.state === 'pulling' || g.state === 'hanging' || g.state === 'latched')) {
      const launchVx = g.state === 'hanging' ? g.swingVel * g.ropeLen * 0.8 : 0;
      p.vy = jumpForce * 0.7;
      p.vx = launchVx;
      p.grapple = null;
      p.grappleCooldown = 10;
      p.onGround = false;
      playSound('jump');
    }

    // Release grapple on grapple key press while hanging (re-fire)
    if (p.grapple && g.state === 'hanging' && getGrapple()) {
      // Will be caught next frame by the fire check since we null it
      p.vx = g.swingVel * g.ropeLen * 0.4;
      p.vy = -2;
      p.grapple = null;
      p.grappleCooldown = 3; // short cooldown for re-fire
    }
  }

  // Skip normal gravity/collision when grappling
  if (p.grapple && (p.grapple.state === 'pulling' || p.grapple.state === 'latched' || p.grapple.state === 'hanging')) {
    // Already handled above
  } else {

  // Fell off screen
  if (p.y > level.rows * TILE + 50) {
    killPlayer(p);
  }

  // Water kill (tile type 3)
  const theme = getTheme(stage);
  if (theme.water) {
    const feetCol = Math.floor((p.x + p.w / 2) / TILE);
    const feetRow = Math.floor((p.y + p.h) / TILE);
    if (feetRow >= 0 && feetRow < level.rows && feetCol >= 0 && feetCol < level.cols) {
      if (level.map[feetRow][feetCol] === 3) {
        // Splash particles
        spawnParticles(p.x + p.w/2, p.y + p.h, '#44aaff', 12, 3, 20);
        killPlayer(p);
      }
    }
  }

  } // end grapple-skip-else

  // Shooting
  p.shooting = getShoot();
  if (p.fireTimer > 0) p.fireTimer--;
  if (getShoot() && p.fireTimer <= 0) {
    applyAimAssist(p);
    fireWeapon(p);
    p.fireTimer = p.weapon.fireRate;
  }

  // Animation
  if (Math.abs(p.vx) > 0) {
    p.animTimer++;
    if (p.animTimer > 5) { p.animTimer = 0; p.animFrame++; }
  } else {
    p.animFrame = 0;
  }

  // --- World-scope updates: camera, bullets, enemies ---
  // Only run once per frame (for the primary player call)
  if (p === player) {

  // Camera with lookahead - frame both players in co-op
  const vw = viewW();
  const vh = viewH();

  let targetCamX, targetCamY;
  
  if (coopMode && player2 && !player.dead && !player2.dead) {
    // Frame both players in co-op mode
    const bothX = Math.min(player.x, player2.x);
    const bothMaxX = Math.max(player.x + player.w, player2.x + player2.w);
    const centerX = (bothX + bothMaxX) / 2;
    const bothY = Math.min(player.y, player2.y);
    const bothMaxY = Math.max(player.y + player.h, player2.y + player2.h);
    const centerY = (bothY + bothMaxY) / 2;
    
    targetCamX = centerX - vw * 0.5;
    targetCamY = centerY - vh * 0.5;
  } else {
    // Single player or active player in co-op
    const activePlr = (!player.dead && player.lives > 0) ? player : (player2 && !player2.dead && player2.lives > 0) ? player2 : player;
    const lookaheadAmount = Math.max(0, (zoom - 0.8)) * 180;
    const lookahead = activePlr.facing * lookaheadAmount;
    targetCamX = activePlr.x + activePlr.w / 2 + lookahead - vw * 0.35;
    const worldH = level.rows * TILE;
    targetCamY = activePlr.y + activePlr.h / 2 - vh / 2;
  }

  // Smooth camera
  if (targetCamX > camX) {
    camX += (targetCamX - camX) * 0.12;
  } else {
    camX += (targetCamX - camX) * 0.06;
  }
  if (camX < 0) camX = 0;
  const maxCam = level.cols * TILE - vw;
  if (camX > maxCam) camX = Math.max(0, maxCam);

  // Vertical camera
  const worldH = level.rows * TILE;
  if (camY < 0) camY = 0;
  if (camY > worldH - vh) camY = Math.max(0, worldH - vh);
  camY += (targetCamY - camY) * 0.1;
  if (camY < 0) camY = 0;
  if (camY > worldH - vh) camY = Math.max(0, worldH - vh);

  // Continue with existing update logic for bullets, etc.

  // Update bullets
  for (let i = bullets.length - 1; i >= 0; i--) {
    const b = bullets[i];

    // Special bullet behaviors
    if (b.btype === 'flame') {
      b.vx *= 0.97; b.vy *= 0.97;
      b.size *= 1.02;
      if (Math.random() < 0.3) spawnParticles(b.x, b.y, '#ff4400', 1, 1, 8);
    }
    if (b.btype === 'rocket') {
      if (Math.random() < 0.5) spawnParticles(b.x - b.vx * 0.5, b.y - b.vy * 0.5, '#888888', 1, 1, 12);
    }
    if (b.btype === 'homing' && b.life < 70) {
      // Find nearest enemy
      let nearest = null, nearDist = 300;
      for (const e of enemies) {
        if (!e.active) continue;
        const dx = (e.x + e.w/2) - b.x, dy = (e.y + e.h/2) - b.y;
        const d = Math.sqrt(dx*dx + dy*dy);
        if (d < nearDist) { nearDist = d; nearest = e; }
      }
      if (nearest) {
        const dx = (nearest.x + nearest.w/2) - b.x;
        const dy = (nearest.y + nearest.h/2) - b.y;
        const a = Math.atan2(dy, dx);
        const spd = Math.sqrt(b.vx*b.vx + b.vy*b.vy);
        b.vx += Math.cos(a) * 0.4;
        b.vy += Math.sin(a) * 0.4;
        const ns = Math.sqrt(b.vx*b.vx + b.vy*b.vy);
        b.vx = b.vx/ns * spd; b.vy = b.vy/ns * spd;
      }
      if (Math.random() < 0.3) spawnGlowParticles(b.x, b.y, '#ff44ff', 1, 1, 6);
    }
    if (b.btype === 'wave') {
      b.wavePhase = (b.wavePhase || 0) + 0.3;
      const perp = Math.atan2(b.vy, b.vx) + Math.PI/2;
      b.x += Math.cos(perp) * Math.sin(b.wavePhase) * 2;
      b.y += Math.sin(perp) * Math.sin(b.wavePhase) * 2;
    }
    // Lightning: chain to nearby enemies on hit (handled in hit code below)
    if (b.btype === 'lightning') {
      if (Math.random() < 0.4) spawnGlowParticles(b.x, b.y, '#88eeff', 1, 1, 5);
    }
    // Boomerang: decelerates, stops, returns to player
    if (b.btype === 'boomerang') {
      b.boomPhase = (b.boomPhase || 0) + 1;
      if (b.boomPhase < 20) {
        // Outward phase ‚Äî decelerate
        b.vx *= 0.95; b.vy *= 0.95;
      } else {
        // Return phase ‚Äî accelerate back toward player
        const tx = (b.ownerX || player.x) + 10;
        const ty = (b.ownerY || player.y) + 16;
        const dx = tx - b.x, dy = ty - b.y;
        const d = Math.sqrt(dx * dx + dy * dy);
        if (d > 0) { b.vx += (dx / d) * 0.6; b.vy += (dy / d) * 0.6; }
        // Despawn when returned close
        if (d < 20 && b.boomPhase > 30) b.life = 0;
      }
      // Rotate visual
      b.wavePhase = (b.wavePhase || 0) + 0.3;
      if (Math.random() < 0.2) spawnParticles(b.x, b.y, '#ffdd44', 1, 1, 6);
    }
    // Black Hole: slow-moving, pulls in enemies, deals DoT
    if (b.btype === 'blackhole') {
      b.vx *= 0.96; b.vy *= 0.96;
      b.bhTimer = (b.bhTimer || 0) + 1;
      // Gravitational pull on nearby enemies
      for (const e of enemies) {
        if (!e.active) continue;
        const dx = b.x - (e.x + e.w / 2), dy = b.y - (e.y + e.h / 2);
        const d = Math.sqrt(dx * dx + dy * dy);
        if (d < 120 && d > 5) {
          const pull = 0.8 / (d * 0.05);
          e.x += (dx / d) * pull;
          e.y += (dy / d) * pull;
          // DoT every 15 frames
          if (b.bhTimer % 15 === 0) { e.hp -= b.damage; e.hitFlash = 3; }
        }
      }
      // Visual particles
      if (Math.random() < 0.5) {
        const a = Math.random() * Math.PI * 2;
        const r = 10 + Math.random() * 30;
        spawnGlowParticles(b.x + Math.cos(a) * r, b.y + Math.sin(a) * r, '#9944ff', 1, 0.5, 10);
      }
    }
    // Mine: gravity, lands, then arms and explodes on proximity
    if (b.btype === 'mine') {
      b.vy += 0.2; // gravity
      b.mineTimer = (b.mineTimer || 0) + 1;
      if (b.mineTimer > 20) b.mineArmed = true;
      // Ground collision ‚Äî stop
      if (tileAt(level, b.x, b.y + b.size)) {
        b.y = Math.floor((b.y + b.size) / TILE) * TILE - b.size;
        b.vy = 0; b.vx = 0;
      }
      // Proximity detonation
      if (b.mineArmed) {
        for (const e of enemies) {
          if (!e.active) continue;
          const dx = (e.x + e.w / 2) - b.x, dy = (e.y + e.h / 2) - b.y;
          if (Math.sqrt(dx * dx + dy * dy) < 50) {
            // Explode!
            spawnParticles(b.x, b.y, '#ff4400', 25, 6, 30);
            spawnRing(b.x, b.y, '#ff6600', 40, 12);
            triggerShake(5, 6);
            playSound('explosion');
            // Damage all enemies in radius
            for (const e2 of enemies) {
              if (!e2.active) continue;
              const dx2 = (e2.x + e2.w / 2) - b.x, dy2 = (e2.y + e2.h / 2) - b.y;
              if (Math.sqrt(dx2 * dx2 + dy2 * dy2) < 70) { e2.hp -= b.damage; e2.hitFlash = 6; }
            }
            b.life = 0;
            break;
          }
        }
        // Blink when armed
        if (b.mineTimer % 20 < 10 && Math.random() < 0.3) spawnGlowParticles(b.x, b.y, '#ff4444', 1, 1, 8);
      }
    }

    b.x += b.vx;
    b.y += b.vy;
    b.life--;

    // Tile collision (piercing bullets go through)
    if (b.btype !== 'pierce' && tileAt(level, b.x, b.y)) {
      const hitC = Math.floor(b.x / TILE);
      const hitR = Math.floor(b.y / TILE);
      const tileVal = (hitR >= 0 && hitR < level.rows && hitC >= 0 && hitC < level.cols) ? level.map[hitR][hitC] : 0;
      const theme = getTheme(stage);
      const dirtColor = theme.desert ? '#ccaa66' : theme.snow ? '#ccddee' : theme.space ? '#555577' : '#886644';
      const tx = hitC * TILE + TILE / 2;
      const ty = hitR * TILE + TILE / 2;

      if (b.btype === 'rocket') {
        // Rocket explosion ‚Äî destroy hit tile + adjacent tiles
        spawnParticles(b.x, b.y, '#ff4400', 20, 5, 25);
        spawnRing(b.x, b.y, '#ff6600', 30, 10);
        triggerShake(4, 5);
        playSound('explosion');
        // Break tiles in blast radius
        for (let dr = -1; dr <= 1; dr++) {
          for (let dc = -1; dc <= 1; dc++) {
            const br = hitR + dr, bc = hitC + dc;
            if (br >= 0 && br < level.rows && bc >= 0 && bc < level.cols) {
              const bv = level.map[br][bc];
              if (bv === 1 || bv === 4) {
                const btx = bc * TILE + TILE / 2, bty = br * TILE + TILE / 2;
                if (bv === 4) {
                  playSound('treasure');
                  const tKey = br + ',' + bc;
                  if (!level.treasureMap) level.treasureMap = {};
                  const tType = level.treasureMap[tKey] || 'gem_small';
                  treasureItems.push({ x: btx-10, y: bty-10, w: 20, h: 20, vy: -6, vx: (Math.random()-0.5)*4, type: tType, life: 300, onGround: false, bobPhase: Math.random()*Math.PI*2 });
                  spawnGlowParticles(btx, bty, '#ffff44', 8, 4, 20);
                }
                spawnParticles(btx, bty, dirtColor, 6, 3, 15);
                spawnDebris(btx, bty, dirtColor, 3);
                level.map[br][bc] = 0;
                addScore((bv === 4) ? 0 : 10);
              }
            }
          }
        }
        // Damage nearby enemies
        for (let j = enemies.length - 1; j >= 0; j--) {
          const e = enemies[j];
          if (!e.active) continue;
          const dx = (e.x+e.w/2)-b.x, dy = (e.y+e.h/2)-b.y;
          if (Math.sqrt(dx*dx+dy*dy) < 60) { e.hp -= 3; e.hitFlash = 6; }
        }
      } else if (tileVal === 1 || tileVal === 4) {
        // Normal bullet ‚Äî destroy the single tile it hit
        spawnParticles(tx, ty, dirtColor, 8, 3, 15);
        spawnDebris(tx, ty, dirtColor, 4);
        triggerShake(2, 3);

        if (tileVal === 4) {
          playSound('treasure');
          const tKey = hitR + ',' + hitC;
          if (!level.treasureMap) level.treasureMap = {};
          const tType = level.treasureMap[tKey] || 'gem_small';
          treasureItems.push({ x: tx-10, y: ty-10, w: 20, h: 20, vy: -5, vx: (Math.random()-0.5)*3, type: tType, life: 300, onGround: false, bobPhase: Math.random()*Math.PI*2 });
          spawnGlowParticles(tx, ty, '#ffff44', 12, 4, 25);
          spawnRing(tx, ty, '#ffcc00', 30, 10);
        } else {
          playSound('dig');
          addScore(10);
          spawnPopup(tx, ty - 10, '+10', '#ccaa66', 10);
        }
        level.map[hitR][hitC] = 0;
      } else {
        // Indestructible tile ‚Äî just sparks
        spawnParticles(b.x, b.y, '#ffff88', 5, 3, 12);
      }
      bullets.splice(i, 1);
      continue;
    }

    // Off screen
    if (b.life <= 0 || b.x < camX - 100 || b.x > camX + viewW() + 100 || b.y < -100 || b.y > level.rows * TILE + 100) {
      bullets.splice(i, 1);
      continue;
    }

    // Hit destructible objects
    for (let j = objects.length - 1; j >= 0; j--) {
      const o = objects[j];
      if (b.x > o.x && b.x < o.x + o.w && b.y > o.y && b.y < o.y + o.h) {
        o.hp -= b.damage;
        spawnParticles(b.x, b.y, '#ddbb88', 4, 2, 10);
        if (b.btype !== 'pierce') { bullets.splice(i, 1); }
        if (o.hp <= 0) {
          const cx = o.x + o.w/2, cy = o.y + o.h/2;
          if (o.type === 'explbarrel') {
            // Explosive barrel!
            spawnParticles(cx, cy, '#ff4400', 30, 7, 35);
            spawnRing(cx, cy, '#ff6600', 50, 14);
            spawnDebris(cx, cy, '#cc3333', 6);
            triggerShake(8, 10);
            triggerFlash('#ff6600', 0.3);
            // Damage nearby enemies
            for (let k = enemies.length - 1; k >= 0; k--) {
              const e = enemies[k];
              if (!e.active) continue;
              const dx = (e.x+e.w/2)-cx, dy = (e.y+e.h/2)-cy;
              if (Math.sqrt(dx*dx+dy*dy) < 80) { e.hp -= 5; e.hitFlash = 6; }
            }
            // Damage player if close
            const pdx = (player.x+player.w/2)-cx, pdy = (player.y+player.h/2)-cy;
            if (Math.sqrt(pdx*pdx+pdy*pdy) < 60 && player.invincible <= 0) killPlayer();
            if (coopMode && player2 && !player2.dead) {
              const pdx2 = (player2.x+player2.w/2)-cx, pdy2 = (player2.y+player2.h/2)-cy;
              if (Math.sqrt(pdx2*pdx2+pdy2*pdy2) < 60 && player2.invincible <= 0) killPlayer(player2);
            }
          } else {
            spawnDebris(cx, cy, o.color, 5);
            spawnParticles(cx, cy, '#ddbb88', 10, 4, 20);
            playSound('hit');
            // Crates may drop powerups
            if (o.type === 'crate' && Math.random() < 0.3) {
              const types = ['SPREAD','LASER','MACHINE','FLAME','ROCKET','HOMING','WAVE','LIGHTNING','BOOMERANG','BLACKHOLE','MINE','LIFE'];
              powerups.push({
                x: cx - 10, y: cy - 10,
                w: 20, h: 20,
                type: types[Math.floor(Math.random() * types.length)],
                bobPhase: Math.random() * 6.28,
              });
            }
          }
          addScore(50);
          spawnPopup(cx, cy - 10, '+50', '#ffcc44', 9);
          objects.splice(j, 1);
        }
        break;
      }
    }
    if (i >= bullets.length) continue; // was removed above
    // Bullet vs secret exit walls
    for (let j = secretExits.length - 1; j >= 0; j--) {
      const se = secretExits[j];
      if (se.revealed) continue;
      if (b.x > se.x && b.x < se.x + se.w && b.y > se.y && b.y < se.y + se.h) {
        se.hp -= b.damage;
        spawnParticles(b.x, b.y, '#ff88ff', 5, 3, 12);
        if (b.btype !== 'pierce') { bullets.splice(i, 1); }
        if (se.hp <= 0) {
          se.revealed = true;
          se.portalTimer = 0;
          const cx = se.x + se.w / 2;
          const cy = se.y + se.h / 2;
          spawnPopup(cx, cy - 20, '‚ö° SECRET FOUND!', '#ff44ff', 14);
          spawnParticles(cx, cy, '#ff44ff', 40, 7, 45);
          spawnGlowParticles(cx, cy, '#ffffff', 20, 5, 40);
          spawnRing(cx, cy, '#ff88ff', 60, 20);
          triggerShake(10, 16);
          triggerFlash('#ff44ff', 0.5);
          playSound('boss');
          secretsFound['stage_' + stage] = true;
          saveSecrets();
        }
        break;
      }
    }
    if (i >= bullets.length) continue;

    // Hit 
    // Hit enemies
    for (let j = enemies.length - 1; j >= 0; j--) {
      const e = enemies[j];
      if (!e.active) continue;
      if (b.x > e.x && b.x < e.x + e.w && b.y > e.y && b.y < e.y + e.h) {
        let dmg = b.damage;
        // Shield enemies take half damage from front
        if (e.etype === 'shield') {
          const hitFromFront = (b.vx > 0 && e.facing === -1) || (b.vx < 0 && e.facing === 1);
          if (hitFromFront) { dmg *= 0.25; spawnParticles(b.x, b.y, '#88ccff', 4, 2, 8); }
        }
        // Shielded Pair: front shield absorbs 80% damage
        if (e.etype === 'shieldpair') {
          const hitFromFront = (b.vx > 0 && e.shieldFacing === 1) || (b.vx < 0 && e.shieldFacing === -1);
          if (hitFromFront) { dmg *= 0.2; spawnParticles(b.x, b.y, '#ffcc44', 4, 2, 8); }
        }
        // Cloaker: harder to hit when cloaked (bullets pass through when near-invisible)
        if (e.etype === 'cloaker' && (e.cloakAlpha || 1) < 0.2) {
          spawnParticles(b.x, b.y, '#446666', 3, 2, 6);
          if (b.btype !== 'pierce') bullets.splice(i, 1);
          continue;
        }
        // Mini-boss: shielded damage multiplier
        if (e.isMiniBoss && e.damageMult !== undefined) dmg *= e.damageMult;
        e.hp -= dmg;
        spawnParticles(b.x, b.y, '#ffcc44', 6, 3, 12);
        spawnGlowParticles(b.x, b.y, '#ffffff', 2, 2, 10);
        triggerShake(2, 3);
        playSound('hit');
        e.hitFlash = 6;

        // Rocket explodes on contact
        if (b.btype === 'rocket') {
          spawnParticles(b.x, b.y, '#ff4400', 20, 5, 25);
          spawnRing(b.x, b.y, '#ff6600', 35, 10);
          triggerShake(5, 6);
          // Splash damage to nearby enemies
          for (let k = enemies.length - 1; k >= 0; k--) {
            if (k === j) continue;
            const e2 = enemies[k];
            if (!e2.active) continue;
            const dx = (e2.x+e2.w/2)-b.x, dy = (e2.y+e2.h/2)-b.y;
            if (Math.sqrt(dx*dx+dy*dy) < 50) { e2.hp -= 2; e2.hitFlash = 6; }
          }
        }

        // Tank shell explodes with larger blast
        if (b.btype === 'tank_shell') {
          spawnParticles(b.x, b.y, '#ffcc44', 25, 6, 30);
          spawnRing(b.x, b.y, '#ff8800', 45, 14);
          triggerShake(6, 8);
          playSound('explosion');
          for (let k = enemies.length - 1; k >= 0; k--) {
            if (k === j) continue;
            const e2 = enemies[k];
            if (!e2.active) continue;
            const dx = (e2.x+e2.w/2)-b.x, dy = (e2.y+e2.h/2)-b.y;
            if (Math.sqrt(dx*dx+dy*dy) < 70) { e2.hp -= 4; e2.hitFlash = 6; }
          }
        }

        // Lightning chain: on hit, arc to up to 3 nearby enemies
        if (b.btype === 'lightning') {
          let chainX = b.x, chainY = b.y;
          const chained = new Set([j]);
          for (let ch = 0; ch < 3; ch++) {
            let nearK = -1, nearD = 150;
            for (let k = 0; k < enemies.length; k++) {
              if (chained.has(k)) continue;
              const e2 = enemies[k];
              if (!e2.active) continue;
              const dx = (e2.x + e2.w / 2) - chainX, dy = (e2.y + e2.h / 2) - chainY;
              const d = Math.sqrt(dx * dx + dy * dy);
              if (d < nearD) { nearD = d; nearK = k; }
            }
            if (nearK >= 0) {
              chained.add(nearK);
              const e2 = enemies[nearK];
              spawnGlowParticles((chainX + e2.x + e2.w / 2) / 2, (chainY + e2.y + e2.h / 2) / 2, '#88eeff', 4, 3, 8);
              e2.hp -= b.damage * 0.7;
              e2.hitFlash = 6;
              chainX = e2.x + e2.w / 2;
              chainY = e2.y + e2.h / 2;
            }
          }
        }

        // Boomerang & blackhole pass through enemies
        if (b.btype === 'boomerang' || b.btype === 'blackhole') {
          // Don't remove ‚Äî continues traveling
        } else if (b.btype !== 'pierce') { bullets.splice(i, 1); }

        if (e.hp <= 0) {
          const cx = e.x + e.w / 2;
          const cy = e.y + e.h / 2;
          addScore(e.score);
          registerKill();
          spawnPopup(cx, cy - 10, '+' + Math.round(e.score * diffSettings.scoreMult), '#ffff00', 12);

          // Mini-boss: splitter spawns 2 small enemies on death
          if (e.isMiniBoss && e.mbPattern === 'splitter') {
            for (let si = 0; si < 2; si++) {
              enemies.push({
                x: e.x + (si === 0 ? -20 : 20), y: e.y,
                w: 16, h: 22, hp: 3, maxHp: 3,
                speed: 2, score: 150, color: '#dd66dd',
                fireRate: 60, fireTimer: 0, shootRange: 200,
                active: true, facing: si === 0 ? -1 : 1,
                etype: 'soldier', dir: si === 0 ? -1 : 1,
                patrolStart: (e.x - 100), patrolEnd: (e.x + 100),
                vy: -3, onGround: false, hitFlash: 0,
              });
            }
            spawnPopup(cx, cy - 30, 'SPLIT!', '#dd66dd', 10);
          }

          // Mini-boss: enhanced death effects
          if (e.isMiniBoss) {
            playSound('boss');
            triggerShake(12, 20);
            triggerFreeze(8);
            triggerFlash('#ff8844', 0.5);
            spawnParticles(cx, cy, '#ff4400', 40, 7, 40);
            spawnGlowParticles(cx, cy, '#ffaa00', 15, 5, 45);
            spawnRing(cx, cy, '#ffaa00', 50, 14);
            spawnDebris(cx, cy, e.color, 8);
            addLight(cx, cy, 130, 'rgba(255,100,0,0.6)', 0.7, 20);
            spawnPopup(cx, cy - 25, 'MINI-BOSS DOWN!', '#ffaa00', 14);
          }

          if (e.isBoss) {
            runStats.bossKills++;
            playSound('boss');
            triggerShake(20, 40);
            triggerFreeze(12);
            triggerFlash('#ffffff', 0.8);
            spawnParticles(cx, cy, '#ff4400', 60, 8, 50);
            spawnParticles(cx, cy, '#ffff00', 40, 7, 45);
            spawnGlowParticles(cx, cy, '#ff8800', 30, 6, 60);
            spawnGlowParticles(cx, cy, '#ffffff', 20, 5, 40);
            spawnRing(cx, cy, '#ffaa00', 80, 24);
            spawnRing(cx, cy, '#ff4400', 50, 16);
            spawnDebris(cx, cy, '#666666', 15);
            spawnDebris(cx, cy, '#884444', 10);
            spawnPopup(cx, cy - 40, 'BOSS DESTROYED!', '#ff4444', 16);
            addLight(cx, cy, 200, 'rgba(255,100,0,0.7)', 0.8, 30);
            slowMo = 60;
            setTimeout(() => {
              // --- Mode-specific boss kill routing ---
              if (gameMode === 'bossrush') {
                onBossRushBossKill();
                return;
              }
              if (gameMode === 'endless') {
                // Endless boss killed ‚Äî continue waves
                onEndlessEnemyKill();
                playSound('stage_clear');
                spawnPopup(cx, cy - 60, 'WAVE ' + endlessWave + ' CLEAR!', '#44ff44', 16);
                return;
              }
              if (gameMode === 'timeattack') {
                onTimeAttackStageClear(stage);
                // Still advance stage normally
              }
              // Speedrun split
              onSpeedrunStageClear(stage);
              // Challenge: track no-hit boss
              if (gameMode === 'challenge' && activeChallenge === 'no_hit_boss') {
                if (!challengeState.bossHitsTaken || challengeState.bossHitsTaken === 0) {
                  challengeState.bossNoHit = true;
                }
              }

              if (stage > MAX_STAGE) {
                // Secret stage cleared ‚Äî return to normal progression
                playSound('stage_clear');
                secretsFound['stage_' + stage] = true;
                saveSecrets();
                spawnPopup(cx, cy - 60, 'SECRET STAGE CLEARED!', '#ff88ff', 16);
                runStats.stagesCleared++;
                runStats.stageDeaths = 0;
                stageStartTime = Date.now();
                checkAchievements();
                stage = returnFromSecretStage || (stage === 11 ? 4 : 8);
                returnFromSecretStage = 0;
                if (stage > MAX_STAGE) stage = MAX_STAGE;
                if (storyMode && STORY[getCutsceneKey(stage)]) {
                  playCutscene(getCutsceneKey(stage), () => { initGame(); });
                } else {
                  transitionToStage(() => initGame());
                }
              } else if (stage < MAX_STAGE) {
                playSound('stage_clear');
                // Check speed + untouchable achievements before advancing
                checkCharacterUnlocks();
                const stageElapsed = (Date.now() - stageStartTime) / 1000;
                runStats.stagesCleared++;
                if (stageElapsed < 60) unlockAchievement('speedrun3');
                if (runStats.stageDeaths === 0) unlockAchievement('untouchable');
                runStats.stageDeaths = 0;
                // Challenge: track consecutive no-death stages
                if (gameMode === 'challenge') {
                  if (challengeState.currentStageDeaths === 0) challengeState.consecutiveNoDeath++;
                  else challengeState.consecutiveNoDeath = 0;
                  challengeState.currentStageDeaths = 0;
                  challengeState.bossHitsTaken = 0;
                }
                stageStartTime = Date.now();
                checkAchievements();
                stage++;
                // Story mode: play next stage cutscene before starting
                if (storyMode && STORY[getCutsceneKey(stage)]) {
                  playCutscene(getCutsceneKey(stage), () => { initGame(); });
                } else {
                  transitionToStage(() => initGame());
                }
              } else {
                // Stage MAX_STAGE cleared (final boss)
                playSound('victory');
                runStats.stagesCleared++;
                unlockCharacter('GHOST'); // Unlock GHOST for beating the game
                checkCharacterUnlocks();
                if (runStats.stageDeaths === 0) unlockAchievement('untouchable');
                if (runStats.noDeathRun) unlockAchievement('flawless');
                checkAchievements();
                submitScore('victory');

                // NG+ completion ‚Äî offer next NG+ level
                if (gameMode === 'newgameplus') {
                  ngPlusLevel++;
                  gameState = 'victory';
                  showOverlay('NG+' + (ngPlusLevel-1) + ' COMPLETE!', `FINAL SCORE: ${score}`, 'PRESS ENTER FOR NG+' + ngPlusLevel);
                  return;
                }

                // Story mode: play epilogue before victory screen
                if (storyMode && STORY.epilogue) {
                  playCutscene('epilogue', () => {
                    startCredits(() => {
                      gameState = 'victory';
                      showOverlay('VICTORY!', `FINAL SCORE: ${score}`, 'PRESS ENTER TO PLAY AGAIN');
                    });
                  });
                } else {
                  startCredits(() => {
                    gameState = 'victory';
                    showOverlay('VICTORY!', `FINAL SCORE: ${score}`, 'PRESS ENTER TO PLAY AGAIN');
                  });
                }
              }
            }, 2000);
          } else {
            playSound('explosion');
            triggerShake(6, 8);
            triggerFreeze(4);
            triggerFlash('#ff8844', 0.25);
            spawnParticles(cx, cy, '#ff4400', 30, 6, 35);
            spawnParticles(cx, cy, '#ffff00', 15, 5, 30);
            spawnGlowParticles(cx, cy, '#ff8800', 10, 4, 40);
            spawnRing(cx, cy, '#ff6600', 40, 12);
            spawnDebris(cx, cy, darkenColor(e.color, 0.8), 6);
            addLight(cx, cy, 100, 'rgba(255,100,0,0.5)', 0.6, 15);
          }
          enemies.splice(j, 1);
        }
        break;
      }
    }
  }

  } // end world-scope updates (p === player)

  // Powerup collection
  for (let i = powerups.length - 1; i >= 0; i--) {
    const pw = powerups[i];
    const pwY = pw.y + Math.sin(Date.now() * 0.005 + pw.bobPhase) * 5;
    if (rectCollide(p, { x: pw.x, y: pwY, w: pw.w, h: pw.h })) {
      playSound('powerup');
      const cx = pw.x + pw.w / 2;
      const cy = pwY + pw.h / 2;

      if (pw.type === 'LIFE') {
        p.lives = Math.min(p.lives + 1, 9);
        spawnPopup(cx, cy - 20, '+1 LIFE', '#ff4488', 12);
        triggerFlash('#ff4488', 0.3);
      } else {
        // Try weapon fusion first
        const currentWepName = p.weapon ? p.weapon.name : 'RIFLE';
        const fused = (currentWepName !== 'RIFLE' && currentWepName !== pw.type) ? tryWeaponFusion(p, pw.type) : false;
        if (!fused) {
          p.weapon = WEAPONS[pw.type];
          // Start fusion window for this pickup
          if (pw.type !== 'RIFLE') { fusionHeldWeapon = pw.type; fusionTimer = FUSION_WINDOW; }
        }
        runStats.weaponsCollected.add(pw.type);
        if (gameMode === 'challenge') challengeState.weaponsUsed.add(pw.type);
        checkAchievements();
        const weaponNames = { SPREAD: 'SPREAD GUN!', LASER: 'LASER!', MACHINE: 'MACHINE GUN!', FLAME: 'FLAMETHROWER!', ROCKET: 'ROCKET!', HOMING: 'HOMING MISSILES!', WAVE: 'WAVE GUN!', LIGHTNING: 'LIGHTNING CHAIN!', BOOMERANG: 'BOOMERANG!', BLACKHOLE: 'BLACK HOLE!', MINE: 'MINE LAYER!' };
        if (!fused) {
          spawnPopup(cx, cy - 20, weaponNames[pw.type] || pw.type, '#44ffff', 12);
          triggerFlash('#44ffff', 0.25);
        }
      }
      // Big sparkle burst
      triggerShake(4, 6);
      triggerFreeze(3);
      spawnParticles(cx, cy, '#ffffff', 20, 5, 25);
      spawnGlowParticles(cx, cy, '#ffff88', 12, 4, 35);
      spawnRing(cx, cy, '#ffffff', 30, 10);
      powerups.splice(i, 1);
    }
  }

  // Vehicle pickup collection
  for (let i = vehiclePickups.length - 1; i >= 0; i--) {
    const vp = vehiclePickups[i];
    if (vp.collected) continue;
    if (rectCollide(p, vp)) {
      const vDef = VEHICLES[vp.type];
      p.inVehicle = true;
      p.vehicleType = vp.type;
      p.vehicleHP = vDef.hp;
      p.vehicleMaxHP = vDef.hp;
      p.vehicleFireTimer = 0;
      p.vehicleHitFlash = 0;
      p.w = vDef.w;
      p.h = vDef.h;
      // Snap feet to ground
      p.y = vp.y + vp.h - p.h;
      p.prone = false;
      p.onLadder = false;
      p.wallClimbing = false;
      p.grapple = null;
      playSound('powerup');
      const cx = vp.x + vp.w / 2;
      const cy = vp.y + vp.h / 2;
      spawnPopup(cx, cy - 30, vDef.name + '!', vDef.color, 14);
      spawnPopup(cx, cy - 10, vDef.desc, '#ffffff', 8);
      triggerShake(6, 10);
      triggerFreeze(5);
      triggerFlash(vDef.color, 0.4);
      spawnParticles(cx, cy, vDef.color, 30, 6, 35);
      spawnGlowParticles(cx, cy, '#ffffff', 15, 5, 40);
      spawnRing(cx, cy, vDef.color, 50, 16);
      vehiclePickups.splice(i, 1);
      break;
    }
  }

  // Secret exit portal entry
  for (const se of secretExits) {
    if (!se.revealed) continue;
    se.portalTimer++;
    if (se.portalTimer > 30 && rectCollide(p, se)) {
      playSound('stage_clear');
      const cx = se.x + se.w / 2;
      const cy = se.y + se.h / 2;
      spawnPopup(cx, cy - 30, 'ENTERING SECRET STAGE ' + se.targetStage + '!', '#ff88ff', 14);
      triggerFlash('#ff44ff', 0.8);
      triggerShake(15, 25);
      slowMo = 40;
      const target = se.targetStage;
      returnFromSecretStage = stage + 1; // remember where to return
      setTimeout(() => {
        stage = target;
        initGame();
      }, 1500);
      break;
    }
  }

  // Treasure item physics & collection
  for (let i = treasureItems.length - 1; i >= 0; i--) {
    const t = treasureItems[i];
    t.life--;
    if (t.life <= 0) { treasureItems.splice(i, 1); continue; }

    // Physics
    t.vy += gravity * 0.8;
    t.x += t.vx;
    t.y += t.vy;

    // Ground collision
    for (let checkX = t.x + 2; checkX < t.x + t.w - 2; checkX += 8) {
      if (tileAt(level, checkX, t.y + t.h)) {
        t.y = Math.floor((t.y + t.h) / TILE) * TILE - t.h;
        t.vy = -Math.abs(t.vy) * 0.3;
        t.vx *= 0.7;
        t.onGround = true;
        if (Math.abs(t.vy) < 0.5) t.vy = 0;
      }
    }

    // Player collection
    const bobY = t.onGround ? Math.sin(Date.now() * 0.006 + t.bobPhase) * 3 : 0;
    if (rectCollide(p, { x: t.x, y: t.y + bobY, w: t.w, h: t.h })) {
      const td = TREASURES[t.type];
      const cx = t.x + t.w / 2;
      const cy = t.y + t.h / 2;

      // Score
      if (td.score > 0) addScore(td.score);
      runStats.treasuresFound++;
      checkAchievements();

      // Effects
      if (td.effect === 'shield') {
        p.invincible = Math.max(p.invincible, 180); // 3 seconds
        spawnPopup(cx, cy - 20, td.label, td.color, 14);
      } else if (td.effect === 'speed') {
        playerSpeedBoost = 300; // 5 seconds
        spawnPopup(cx, cy - 20, td.label, td.color, 14);
      } else if (td.effect === 'life') {
        p.lives = Math.min(p.lives + 1, 9);
        spawnPopup(cx, cy - 20, td.label, td.color, 14);
        triggerFlash('#ff4488', 0.3);
      } else if (td.effect === 'weapon') {
        const wNames = ['SPREAD','LASER','MACHINE','FLAME','ROCKET','HOMING','WAVE','LIGHTNING','BOOMERANG','BLACKHOLE','MINE'];
        const rw = wNames[Math.floor(Math.random() * wNames.length)];
        p.weapon = WEAPONS[rw];
        runStats.weaponsCollected.add(rw);
        checkAchievements();
        spawnPopup(cx, cy - 20, rw + '!', td.color, 14);
        triggerFlash('#ff88ff', 0.25);
      } else {
        spawnPopup(cx, cy - 20, td.label, td.color, 14);
      }

      playSound('powerup');
      triggerShake(4, 6);
      triggerFreeze(3);
      spawnParticles(cx, cy, td.color, 15, 5, 25);
      spawnGlowParticles(cx, cy, '#ffff88', 10, 4, 30);
      spawnRing(cx, cy, td.color, 35, 10);

      treasureItems.splice(i, 1);
    }
  }

  // Enemy bullet collision with player
  if (p.invincible <= 0) {
    for (let i = enemyBullets.length - 1; i >= 0; i--) {
      const b = enemyBullets[i];
      if (b.x > p.x && b.x < p.x + p.w && b.y > p.y && b.y < p.y + p.h) {
        spawnParticles(b.x, b.y, '#ff4444', 8, 3, 12);
        enemyBullets.splice(i, 1);
        killPlayer(p);
        break;
      }
    }

    // Contact damage from enemies
    for (const e of enemies) {
      if (!e.active) continue;
      if (rectCollide(p, e)) {
        killPlayer(p);
        break;
      }
    }
  }
}

function updateEnemiesAndBullets() {
  // Update enemies
  for (let ei = enemies.length - 1; ei >= 0; ei--) {
    const e = enemies[ei];
    // Activate if near camera
    if (e.x < camX + viewW() + 100 && e.x > camX - 100) {
      e.active = true;
    }
    if (!e.active) continue;

    const p = player;

    // Flying enemies (drones) ‚Äî hover, no gravity
    if (e.flying) {
      e.vy = 0;
      e.flyPhase = (e.flyPhase || 0) + 0.03;
      e.y = (e.flyY || e.y) + Math.sin(e.flyPhase) * 20;
      e.onGround = false;
      // Drift toward player X
      const driftDir = p.x > e.x ? 1 : -1;
      e.x += driftDir * e.speed * 0.5;
      if (e.x <= e.patrolStart || e.x >= e.patrolEnd) e.dir *= -1;
      e.facing = p.x < e.x ? -1 : 1;
    } else {

    // Apply gravity to enemies
    e.vy += gravity;
    if (e.vy > maxFall) e.vy = maxFall;
    e.y += e.vy;

    // Enemy ground collision
    e.onGround = false;
    for (let checkX = e.x + 2; checkX < e.x + e.w - 2; checkX += 8) {
      if (tileAt(level, checkX, e.y + e.h)) {
        e.y = Math.floor((e.y + e.h) / TILE) * TILE - e.h;
        e.vy = 0;
        e.onGround = true;
      }
    }
    } // end non-flying gravity

    // Mini-boss AI
    if (e.isMiniBoss) {
      updateMiniBossAI(e);
    }

    // Movement (skip mini-bosses ‚Äî they have their own movement)
    if (e.speed > 0 && !e.isBoss && !e.isMiniBoss) {
      const eSpd = e.speed * (accessEnemySpeedMult || 1);
      const nextX = e.x + eSpd * e.dir;

      // Check wall collision ahead
      const checkWallX = e.dir > 0 ? nextX + e.w : nextX;
      let blocked = false;
      for (let checkY = e.y + 2; checkY < e.y + e.h - 2; checkY += 8) {
        if (tileAt(level, checkWallX, checkY)) {
          blocked = true;
          break;
        }
      }

      // Check for ledge (no ground ahead)
      const ledgeCheckX = e.dir > 0 ? nextX + e.w + 2 : nextX - 2;
      const hasGroundAhead = tileAt(level, ledgeCheckX, e.y + e.h + 4);

      if (blocked || (!hasGroundAhead && e.onGround)) {
        e.dir *= -1;
      } else {
        e.x = nextX;
      }

      if (e.x <= e.patrolStart || e.x >= e.patrolEnd) e.dir *= -1;
      e.facing = p.x < e.x ? -1 : 1;

      // Jumper: periodically jump towards player
      if (e.etype === 'jumper' && e.onGround) {
        e.jumpTimer = (e.jumpTimer || 0) + 1;
        if (e.jumpTimer > 40) {
          e.vy = -9;
          e.onGround = false;
          e.jumpTimer = 0;
          e.dir = p.x > e.x ? 1 : -1;
        }
      }

      // Shield: face player and move slowly
      if (e.etype === 'shield') {
        e.shieldFacing = p.x < e.x ? -1 : 1;
      }

      // Teleporter: periodically teleport near the player
      if (e.etype === 'teleporter') {
        e.teleportTimer = (e.teleportTimer || 0) + 1;
        if (e.teleportTimer > 80) {
          e.teleportTimer = 0;
          const dx = p.x - e.x, dy = p.y - e.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < 400) {
            // Teleport to a random offset near the player
            const ox = (Math.random() - 0.5) * 200;
            const newX = p.x + ox;
            const nc = Math.floor(newX / TILE);
            if (nc > 0 && nc < level.cols - 1) {
              // Find ground at new position
              for (let r = 0; r < level.rows; r++) {
                if (level.map[r][nc] === 1) {
                  spawnParticles(e.x + e.w / 2, e.y + e.h / 2, '#bb44ff', 12, 4, 15);
                  e.x = nc * TILE;
                  e.y = r * TILE - e.h;
                  spawnParticles(e.x + e.w / 2, e.y + e.h / 2, '#bb44ff', 12, 4, 15);
                  playSound('hit');
                  break;
                }
              }
            }
          }
        }
      }

      // Cloaker: fade in/out ‚Äî becomes nearly invisible when not shooting
      if (e.etype === 'cloaker') {
        const dx = p.x - e.x, dy = p.y - e.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        // Visible when close or actively shooting
        if (dist < 80 || e.fireTimer > e.fireRate - 10) {
          e.cloakAlpha = Math.min(1, (e.cloakAlpha || 0) + 0.08);
        } else {
          e.cloakAlpha = Math.max(0.08, (e.cloakAlpha || 1) - 0.03);
        }
      }

      // Shielded Pair: has a buddy shield unit that absorbs frontal hits
      if (e.etype === 'shieldpair') {
        e.pairOffset = (e.pairOffset || 0) + 0.05;
        e.shieldFacing = p.x < e.x ? -1 : 1;
      }
    }

    // Bomber: drop bombs when over player
    if (e.etype === 'bomber' && !p.dead) {
      e.fireTimer++;
      const dx = Math.abs(p.x - e.x);
      if (dx < 40 && e.fireTimer >= e.fireRate && e.onGround) {
        e.fireTimer = 0;
        // Lob a bomb
        enemyBullets.push({
          x: e.x + e.w / 2,
          y: e.y + e.h,
          vx: (p.x > e.x ? 1 : -1) * 1.5,
          vy: -4,
          life: 60,
          isBomb: true,
        });
      }
    }

    // Boss movement
    if (e.isBoss) {
      e.phaseTimer++;
      const numPhases = stage >= 8 ? 5 : (stage >= 5 ? 4 : 3);
      const phaseDuration = Math.max(60, 120 - stage * 5);
      if (e.phaseTimer > phaseDuration) { e.phase = (e.phase + 1) % numPhases; e.phaseTimer = 0; }

      // Movement ‚Äî phases 0 & 3 patrol, higher stages also charge
      if (e.phase === 0 || e.phase === 3) {
        const spd = e.phase === 3 ? e.speed * 2 : e.speed;
        const nextBossX = e.x + spd * e.dir;
        const bossWallX = e.dir > 0 ? nextBossX + e.w : nextBossX;
        let bossBlocked = false;
        for (let checkY = e.y + 2; checkY < e.y + e.h - 2; checkY += 8) {
          if (tileAt(level, bossWallX, checkY)) { bossBlocked = true; break; }
        }
        if (bossBlocked || nextBossX <= e.patrolStart || nextBossX >= e.patrolEnd) {
          e.dir *= -1;
        } else {
          e.x = nextBossX;
        }
      }
      // Phase 4: boss jump (stages 8+)
      if (e.phase === 4 && e.onGround && e.phaseTimer === 1) {
        e.vy = jumpForce * 0.8;
        e.onGround = false;
      }
      e.facing = p.x < e.x ? -1 : 1;
    }

    // Remove enemy if it fell off the map
    if (e.y > level.rows * TILE + 100) {
      enemies.splice(ei, 1);
      continue;
    }

    // Shooting
    if (e.fireRate > 0 && !p.dead) {
      e.fireTimer++;
      const dx = p.x - e.x;
      const dy = p.y - e.y;
      const dist = Math.sqrt(dx * dx + dy * dy);

      if (dist < e.shootRange && e.fireTimer >= e.fireRate) {
        e.fireTimer = 0;
        const angle = Math.atan2(dy, dx);

        if (e.isBoss) {
          // Boss fires stage-dependent attack patterns
          const bx = e.x + (e.facing === -1 ? -4 : e.w + 4);
          const cx = e.x + e.w / 2;
          const cy = e.y + e.h / 2;
          playSound('enemy_shoot');

          if (e.phase === 0) {
            // Spread fan ‚Äî more bullets at higher stages
            const fanCount = 2 + Math.min(3, Math.floor(stage / 3));
            for (let i = -fanCount; i <= fanCount; i++) {
              enemyBullets.push({
                x: bx, y: e.y + 25,
                vx: Math.cos(angle + i * 0.18) * enemyBulletSpeed,
                vy: Math.sin(angle + i * 0.18) * enemyBulletSpeed,
                life: 120,
              });
            }
          } else if (e.phase === 1) {
            // Radial burst ‚Äî bullet count scales with stage
            const burstCount = 8 + Math.min(8, stage);
            for (let i = 0; i < burstCount; i++) {
              const a = (Math.PI * 2 / burstCount) * i + Date.now() * 0.002;
              enemyBullets.push({ x: cx, y: cy, vx: Math.cos(a) * 3, vy: Math.sin(a) * 3, life: 90 });
            }
          } else if (e.phase === 2) {
            // Aimed fast double ‚Üí triple at stage 6+
            const shotCount = stage >= 6 ? 3 : 2;
            for (let s = 0; s < shotCount; s++) {
              enemyBullets.push({
                x: bx, y: e.y + 20 + s * 15,
                vx: Math.cos(angle) * enemyBulletSpeed * 1.5,
                vy: Math.sin(angle) * enemyBulletSpeed * 1.5,
                life: 150,
              });
            }
          } else if (e.phase === 3) {
            // Charge + ground wave (stages 5+): low bullets along ground
            for (let i = 0; i < 6; i++) {
              enemyBullets.push({
                x: cx + (i - 3) * 20, y: e.y + e.h - 8,
                vx: e.facing * (2 + i * 0.5), vy: 0, life: 100,
              });
            }
          } else if (e.phase === 4) {
            // Aerial bombardment (stages 8+): raining bullets from above
            for (let i = 0; i < 5; i++) {
              enemyBullets.push({
                x: cx + (Math.random() - 0.5) * 200, y: e.y - 20,
                vx: (Math.random() - 0.5) * 2, vy: 3 + Math.random() * 2,
                life: 120, isBomb: true,
              });
            }
          }
        } else {
          playSound('enemy_shoot');
          enemyBullets.push({
            x: e.x + e.w / 2,
            y: e.y + e.h / 2,
            vx: Math.cos(angle) * enemyBulletSpeed,
            vy: Math.sin(angle) * enemyBulletSpeed,
            life: 90,
          });
        }
      }
    }
  }

  // Update enemy bullets
  for (let i = enemyBullets.length - 1; i >= 0; i--) {
    const b = enemyBullets[i];
    // Arc projectile gravity (artillery mini-boss)
    if (b.isArc) b.vy += (b.gravity || 0.12);
    // Bomb gravity
    if (b.isBomb) {
      b.vy += 0.15;
      if (Math.random() < 0.2) spawnParticles(b.x, b.y, '#ff8844', 1, 1, 6);
    }
    const btMult = accessBulletTimeMult || 1;
    b.x += b.vx * btMult;
    b.y += b.vy * btMult;
    b.life--;
    const hitWall = tileAt(level, b.x, b.y);
    if (b.life <= 0 || hitWall || b.x < camX - 50 || b.x > camX + viewW() + 50) {
      // Bomb explodes on impact
      if (b.isBomb && (hitWall || b.life <= 0)) {
        spawnParticles(b.x, b.y, '#ff4400', 15, 5, 20);
        spawnRing(b.x, b.y, '#ff6600', 25, 8);
        playSound('explosion');
        triggerShake(3, 4);
        // Damage player if near
        const pdx = (player.x+player.w/2)-b.x, pdy = (player.y+player.h/2)-b.y;
        if (Math.sqrt(pdx*pdx+pdy*pdy) < 50 && player.invincible <= 0) killPlayer();
        if (coopMode && player2 && !player2.dead) {
          const pdx2 = (player2.x+player2.w/2)-b.x, pdy2 = (player2.y+player2.h/2)-b.y;
          if (Math.sqrt(pdx2*pdx2+pdy2*pdy2) < 50 && player2.invincible <= 0) killPlayer(player2);
        }
      }
      enemyBullets.splice(i, 1);
    }
  }
}

function fireWeapon(p) {
  const w = p.weapon;
  const sndMap = { SPREAD: 'spread', LASER: 'laser', HOMING: 'homing', ROCKET: 'rocket', FLAME: 'flame', MACHINE: 'machine', WAVE: 'wave', LIGHTNING: 'laser', BOOMERANG: 'shoot', BLACKHOLE: 'homing', MINE: 'rocket' };
  const sndType = sndMap[w.name] || 'shoot';
  playSound(sndType);

  const startX = p.x + p.w / 2;
  const startY = p.y + (p.prone ? p.h - 6 : p.h / 2 - 4);

  // Muzzle flash
  const muzzleX = startX + p.aimX * 14;
  const muzzleY = startY + p.aimY * 14;
  if (p.prone) {
    spawnParticles(p.x + p.w + 10 * p.facing, startY, '#ffff88', 3, 3, 6);
    addLight(p.x + p.w + 10 * p.facing, startY, 60, 'rgba(255,255,120,0.4)', 0.5, 6);
  } else {
    spawnParticles(muzzleX, muzzleY, '#ffff88', 3, 3, 6);
    spawnGlowParticles(muzzleX, muzzleY, w.color, 1, 1.5, 8);
    addLight(muzzleX, muzzleY, 55, 'rgba(255,255,120,0.4)', 0.45, 6);
  }

  for (let i = 0; i < w.bullets; i++) {
    let aimX = p.aimX;
    let aimY = p.aimY;
    if (p.prone) { aimX = p.facing; aimY = 0; }

    if (w.bullets > 1) {
      const spreadAngle = (i - (w.bullets - 1) / 2) * w.spread;
      const cos = Math.cos(spreadAngle);
      const sin = Math.sin(spreadAngle);
      const newAimX = aimX * cos - aimY * sin;
      const newAimY = aimX * sin + aimY * cos;
      aimX = newAimX;
      aimY = newAimY;
    }

    // Random spread for machine gun
    if (w.spread > 0 && w.bullets === 1) {
      aimX += (Math.random() - 0.5) * w.spread;
      aimY += (Math.random() - 0.5) * w.spread;
    }

    // Mine: drops at player's feet, doesn't fly
    if (w.type === 'mine') {
      bullets.push({
        x: startX,
        y: p.y + p.h - 6,
        vx: p.facing * 2,
        vy: -2,
        damage: w.damage * (p.damageMult || 1),
        color: w.color,
        size: w.size,
        life: 300,
        btype: 'mine',
        wavePhase: 0,
        mineArmed: false,
        mineTimer: 0,
        ownerX: p.x,
      });
    } else {

    const spdMult = w.type === 'rocket' ? 0.7 : (w.type === 'flame' ? 0.8 : (w.type === 'boomerang' ? 0.9 : 1));
    bullets.push({
      x: startX,
      y: startY,
      vx: aimX * bulletSpeed * spdMult,
      vy: aimY * bulletSpeed * spdMult,
      damage: w.damage * (p.damageMult || 1),
      color: w.color,
      size: w.size,
      life: w.type === 'flame' ? 30 : (w.type === 'boomerang' ? 60 : (w.type === 'blackhole' ? 120 : 80)),
      btype: w.type,
      wavePhase: i * Math.PI, // for wave bullets
      boomPhase: 0, // for boomerang return
      bhTimer: 0, // for blackhole
      ownerX: p.x, ownerY: p.y,
    });

    } // end non-mine
  }
}

function exitVehicle(p) {
  if (!p.inVehicle) return;
  const vDef = VEHICLES[p.vehicleType];
  const cx = p.x + p.w / 2;
  const cy = p.y + p.h / 2;
  p.inVehicle = false;
  p.vehicleType = null;
  p.vehicleHP = 0;
  p.vehicleMaxHP = 0;
  p.w = 20;
  p.h = 32;
  p.y = cy - p.h;
  p.invincible = 30; // brief invincibility after exiting
  spawnParticles(cx, cy, vDef.color, 15, 4, 25);
  spawnDebris(cx, cy, vDef.color, 5);
  playSound('explosion');
}

function damageVehicle(p, dmg) {
  if (!p.inVehicle) return false;
  p.vehicleHP -= dmg;
  p.vehicleHitFlash = 8;
  const cx = p.x + p.w / 2;
  const cy = p.y + p.h / 2;
  spawnParticles(cx, cy, '#ffaa00', 6, 3, 15);
  triggerShake(3, 4);
  if (p.vehicleHP <= 0) {
    // Vehicle destroyed ‚Äî eject player
    exitVehicle(p);
    spawnPopup(cx, cy - 20, 'VEHICLE DESTROYED!', '#ff4400', 12);
    triggerShake(12, 20);
    triggerFlash('#ff6600', 0.5);
    spawnParticles(cx, cy, '#ff4400', 40, 7, 40);
    spawnRing(cx, cy, '#ff6600', 60, 16);
    spawnDebris(cx, cy, '#666666', 10);
    playSound('boss');
  }
  return true;
}

function killPlayer(target) {
  const p = target || player;
  if (p.dead || p.invincible > 0 || godMode) return;
  // If in vehicle, damage vehicle instead of killing player
  if (p.inVehicle) {
    damageVehicle(p, 1);
    p.invincible = 20;
    return;
  }
  // HEAVY ability: 30% chance to resist death
  if (p.ability === 'damageResist' && Math.random() < 0.3) {
    p.invincible = 60;
    spawnPopup(p.x + p.w / 2, p.y - 10, 'TOUGH!', '#cc6633', 10);
    spawnParticles(p.x + p.w / 2, p.y + p.h / 2, '#cc6633', 12, 4, 20);
    triggerShake(4, 6);
    return;
  }
  p.dead = true;
  p.lives--;
  p.respawnTimer = 90;
  runStats.deaths++;
  runStats.stageDeaths++;
  runStats.noDeathRun = false;
  // Challenge tracking: count hits/deaths
  if (gameMode === 'challenge' && p === player) {
    challengeState.damageTaken++;
    challengeState.currentStageDeaths++;
    // Check if boss is alive ‚Äî means this was a boss hit
    if (enemies.some(e => e.isBoss && e.active)) {
      challengeState.bossHitsTaken++;
    }
    // Track consecutive no-death stages
    challengeState.consecutiveNoDeath = 0;
  }
  p.grapple = null;
  p.grappleCooldown = 0;
  p.digging = false;
  p.digTimer = 0;
  playSound('die');
  // Gamepad vibration on death
  if (p === player) gpRumble(0, 300, 0.8, 1.0);
  else if (p === player2) gpRumble(1, 300, 0.8, 1.0);
  const cx = p.x + p.w / 2;
  const cy = p.y + p.h / 2;
  triggerShake(12, 20);
  triggerFreeze(8);
  triggerFlash('#ff0000', 0.5);
  spawnParticles(cx, cy, '#ff4400', 40, 7, 40);
  spawnParticles(cx, cy, '#ffff00', 20, 5, 30);
  spawnGlowParticles(cx, cy, '#ff2200', 15, 5, 50);
  spawnRing(cx, cy, '#ff4400', 60, 16);
  spawnDebris(cx, cy, '#338833', 8);
  spawnDebris(cx, cy, '#ddbb88', 4);
  if (p.lives <= 0) {
    spawnPopup(cx, cy - 30, 'GAME OVER', '#ff0000', 16);
  }
}

// --- DRAW ---
function draw() {
  ctx.clearRect(0, 0, GAME_W, GAME_H);

  // Apply zoom + shake
  ctx.save();
  ctx.scale(zoom, zoom);
  ctx.translate(shakeX, shakeY);

  // Background (not affected by camY)
  const undergroundStart = level.groundRow * TILE;
  if (camY < undergroundStart) {
    drawBackground(stage);
  } else {
    // Underground background ‚Äî dark gradient
    const depth = (camY - undergroundStart) / (UNDERGROUND_ROWS * TILE);
    const r = Math.max(5, Math.floor(20 - depth * 15));
    const g = Math.max(3, Math.floor(15 - depth * 12));
    const b = Math.max(8, Math.floor(25 - depth * 15));
    ctx.fillStyle = `rgb(${r},${g},${b})`;
    ctx.fillRect(0, 0, viewW(), viewH());
  }

  // Apply vertical camera offset for world objects
  ctx.translate(0, -camY);

  // Underground earth background fill (behind tiles, covers gaps underground)
  if (camY + viewH() > undergroundStart) {
    const ugTop = Math.max(undergroundStart, camY);
    const ugBot = Math.min(level.rows * TILE, camY + viewH());
    const depth01 = Math.min(1, (ugTop - undergroundStart) / (UNDERGROUND_ROWS * TILE));
    const rr = Math.max(8, Math.floor(30 - depth01 * 22));
    const gg = Math.max(5, Math.floor(22 - depth01 * 18));
    const bb = Math.max(10, Math.floor(18 - depth01 * 12));
    ctx.fillStyle = `rgb(${rr},${gg},${bb})`;
    // Fill visible width in viewport + extra margin
    ctx.fillRect(-50, ugTop, viewW() + 100, ugBot - ugTop);
  }

  drawTiles(level);

  // Draw decorations (behind everything)
  for (const d of decorations) {
    if (d.x < camX - 50 || d.x > camX + viewW() + 50) continue;
    const sx = d.x - camX;
    const sy = d.y;
    ctx.globalAlpha = 0.7;

    switch (d.type) {
      case 'tree':
        ctx.fillStyle = '#443322';
        ctx.fillRect(sx + 7, sy + 20, 6, 28);
        ctx.fillStyle = d.color;
        ctx.beginPath();
        ctx.arc(sx + 10, sy + 14, 12, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = '#2a7a2a';
        ctx.beginPath();
        ctx.arc(sx + 8, sy + 8, 8, 0, Math.PI * 2); ctx.fill();
        break;
      case 'deadtree':
        ctx.fillStyle = d.color;
        ctx.fillRect(sx + 5, sy + 10, 5, 34);
        ctx.fillRect(sx, sy + 14, 16, 3);
        ctx.fillRect(sx + 8, sy + 6, 10, 3);
        break;
      case 'bush':
        ctx.fillStyle = d.color;
        ctx.beginPath();
        ctx.arc(sx + 12, sy + 10, 10, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = '#2a882a';
        ctx.beginPath();
        ctx.arc(sx + 8, sy + 8, 7, 0, Math.PI * 2); ctx.fill();
        break;
      case 'rocks':
        ctx.fillStyle = d.color;
        ctx.beginPath();
        ctx.arc(sx + 8, sy + 8, 7, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = '#888';
        ctx.beginPath();
        ctx.arc(sx + 20, sy + 6, 9, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = '#666';
        ctx.beginPath();
        ctx.arc(sx + 14, sy + 10, 5, 0, Math.PI * 2); ctx.fill();
        break;
      case 'sign':
        ctx.fillStyle = d.color;
        ctx.fillRect(sx + 5, sy + 10, 4, 18);
        ctx.fillStyle = '#aa9966';
        ctx.fillRect(sx, sy, 14, 12);
        ctx.fillStyle = '#332211';
        ctx.fillRect(sx + 2, sy + 3, 3, 2);
        ctx.fillRect(sx + 7, sy + 3, 3, 2);
        break;
      case 'skull':
        ctx.fillStyle = d.color;
        ctx.beginPath();
        ctx.arc(sx + 6, sy + 5, 6, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = '#222';
        ctx.fillRect(sx + 3, sy + 3, 2, 2);
        ctx.fillRect(sx + 7, sy + 3, 2, 2);
        ctx.fillRect(sx + 4, sy + 7, 4, 2);
        break;
      case 'fence':
        ctx.fillStyle = d.color;
        ctx.fillRect(sx, sy + 4, 32, 3);
        ctx.fillRect(sx, sy + 14, 32, 3);
        for (let i = 0; i < 4; i++) {
          ctx.fillRect(sx + 2 + i * 9, sy, 3, 24);
        }
        break;
      case 'flag':
        ctx.fillStyle = '#886644';
        ctx.fillRect(sx + 3, sy, 2, 36);
        ctx.fillStyle = d.color;
        const wave = Math.sin(Date.now() * 0.005 + d.phase) * 2;
        ctx.fillRect(sx + 5, sy + 2 + wave, 10, 8);
        break;
      case 'cactus':
        ctx.fillStyle = d.color;
        ctx.fillRect(sx + 5, sy + 4, 4, 32); // trunk
        ctx.fillRect(sx, sy + 10, 5, 4); // left arm
        ctx.fillRect(sx, sy + 6, 4, 8);
        ctx.fillRect(sx + 9, sy + 16, 5, 4); // right arm
        ctx.fillRect(sx + 10, sy + 12, 4, 8);
        // spines
        ctx.fillStyle = '#55aa55';
        ctx.fillRect(sx + 4, sy + 2, 1, 2);
        ctx.fillRect(sx + 9, sy + 8, 1, 2);
        break;
      case 'antenna':
        ctx.fillStyle = d.color;
        ctx.fillRect(sx + 2, sy + 6, 2, 34); // pole
        ctx.fillRect(sx, sy + 6, 6, 3); // cross bar
        // blinking light
        ctx.fillStyle = Math.sin(Date.now() * 0.008 + d.phase) > 0 ? '#ff2222' : '#440000';
        ctx.beginPath();
        ctx.arc(sx + 3, sy + 3, 2, 0, Math.PI * 2); ctx.fill();
        break;
    }
    ctx.globalAlpha = 1;
  }

  // Draw destructible objects
  for (const o of objects) {
    if (o.x < camX - 50 || o.x > camX + viewW() + 50) continue;
    const sx = o.x - camX;
    const sy = o.y;
    const dmgRatio = o.hp / o.maxHp;

    switch (o.type) {
      case 'crate':
        ctx.fillStyle = o.color;
        ctx.fillRect(sx, sy, o.w, o.h);
        ctx.fillStyle = '#997744';
        ctx.fillRect(sx + 2, sy + 2, o.w - 4, o.h - 4);
        ctx.strokeStyle = '#665533';
        ctx.lineWidth = 1;
        ctx.strokeRect(sx + 1, sy + 1, o.w - 2, o.h - 2);
        // X marks
        ctx.fillStyle = '#776633';
        ctx.fillRect(sx + 4, sy + o.h / 2 - 1, o.w - 8, 2);
        ctx.fillRect(sx + o.w / 2 - 1, sy + 4, 2, o.h - 8);
        // ? symbol
        ctx.fillStyle = '#ffcc00';
        ctx.font = '10px "Press Start 2P"';
        ctx.fillText('?', sx + 7, sy + 16);
        break;
      case 'barrel':
      case 'explbarrel':
        ctx.fillStyle = o.color;
        ctx.beginPath();
        ctx.ellipse(sx + o.w / 2, sy + o.h / 2, o.w / 2, o.h / 2, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = darkenColor(o.color, 0.8);
        ctx.fillRect(sx + 2, sy + 4, o.w - 4, 3);
        ctx.fillRect(sx + 2, sy + o.h - 7, o.w - 4, 3);
        if (o.type === 'explbarrel') {
          ctx.fillStyle = '#ffaa00';
          ctx.font = '10px "Press Start 2P"';
          ctx.fillText('!', sx + 6, sy + 17);
        }
        break;
      case 'sandbag':
        ctx.fillStyle = o.color;
        ctx.beginPath();
        ctx.ellipse(sx + o.w / 2, sy + o.h / 2, o.w / 2, o.h / 2, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = darkenColor(o.color, 0.85);
        ctx.fillRect(sx + 4, sy + o.h / 2 - 1, o.w - 8, 2);
        break;
    }

    // Damage cracks
    if (dmgRatio < 0.7) {
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(sx + o.w * 0.3, sy + 2);
      ctx.lineTo(sx + o.w * 0.5, sy + o.h * 0.5);
      ctx.lineTo(sx + o.w * 0.7, sy + o.h * 0.3);
      ctx.stroke();
    }
  }

  // Draw secret exits
  for (const se of secretExits) {
    if (se.x < camX - 100 || se.x > camX + viewW() + 100) continue;
    const sx = se.x - camX;
    const sy = se.y;
    if (!se.revealed) {
      const dmgRatio = se.hp / se.maxHp;
      const t = getTheme(stage);
      ctx.fillStyle = t.tileFill;
      ctx.fillRect(sx, sy, se.w, se.h);
      ctx.fillStyle = t.tileTop;
      ctx.fillRect(sx, sy, se.w, 4);
      // Subtle glow hint ‚Äî cross shape
      ctx.globalAlpha = 0.15 + Math.sin(Date.now() * 0.003) * 0.1;
      ctx.fillStyle = '#ff44ff';
      ctx.fillRect(sx + se.w / 2 - 2, sy + se.h / 2 - 8, 4, 16);
      ctx.fillRect(sx + se.w / 2 - 8, sy + se.h / 2 - 2, 16, 4);
      ctx.globalAlpha = 1;
      // Damage cracks when shot
      if (dmgRatio < 1) {
        ctx.strokeStyle = '#ff88ff';
        ctx.lineWidth = 1;
        ctx.globalAlpha = 0.3 + (1 - dmgRatio) * 0.5;
        ctx.beginPath();
        ctx.moveTo(sx + 5, sy + 10);
        ctx.lineTo(sx + se.w / 2, sy + se.h / 2);
        ctx.lineTo(sx + se.w - 5, sy + 20);
        ctx.stroke();
        ctx.globalAlpha = 1;
      }
    } else {
      // Revealed portal
      const pulse = 0.5 + Math.sin(Date.now() * 0.008) * 0.5;
      const pcx = sx + se.w / 2;
      const pcy = sy + se.h / 2;
      // Outer glow
      ctx.globalAlpha = 0.15 + pulse * 0.15;
      ctx.fillStyle = '#ff44ff';
      ctx.beginPath();
      ctx.arc(pcx, pcy, 40 + pulse * 10, 0, Math.PI * 2);
      ctx.fill();
      // Inner dark void
      ctx.globalAlpha = 0.5 + pulse * 0.3;
      ctx.fillStyle = '#220044';
      ctx.beginPath();
      ctx.arc(pcx, pcy, 24, 0, Math.PI * 2);
      ctx.fill();
      // Ring border
      ctx.globalAlpha = 0.8;
      ctx.strokeStyle = '#ff88ff';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(pcx, pcy, 24 + pulse * 3, 0, Math.PI * 2);
      ctx.stroke();
      // Swirling arcs
      ctx.strokeStyle = '#ff44ff';
      ctx.lineWidth = 1.5;
      for (let a = 0; a < 4; a++) {
        const ang = Date.now() * 0.004 + a * Math.PI / 2;
        ctx.beginPath();
        ctx.arc(pcx, pcy, 16, ang, ang + 1);
        ctx.stroke();
      }
      ctx.globalAlpha = 1;
      // Label
      ctx.fillStyle = '#ff88ff';
      ctx.font = '7px "Press Start 2P"';
      ctx.textAlign = 'center';
      ctx.fillText('SECRET', pcx, sy - 8);
      ctx.fillText('STAGE ' + se.targetStage, pcx, sy);
      ctx.textAlign = 'left';
      // Sparkles
      if (Math.random() < 0.15) {
        spawnGlowParticles(se.x + Math.random() * se.w, se.y + Math.random() * se.h, '#ff44ff', 1, 2, 20);
      }
    }
  }

  // Draw hazards
  drawHazards();

  // Draw enemies
  for (const e of enemies) {
    if (!e.active) continue;
    if (e.x + e.w < camX - 50 || e.x > camX + viewW() + 50) continue;
    // Cloaker: apply transparency
    if (e.etype === 'cloaker') ctx.globalAlpha = e.cloakAlpha || 1;
    if (useSprites) drawEnemySprite(e); else drawEnemy(e);
    if (e.etype === 'cloaker') ctx.globalAlpha = 1;
    // Mini-boss: draw health bar + name
    if (e.isMiniBoss) {
      const bx = e.x - camX;
      const barW = e.w + 10;
      const barH = 4;
      const by = e.y - 14;
      ctx.fillStyle = '#333';
      ctx.fillRect(bx - 5, by, barW, barH);
      ctx.fillStyle = '#ff4444';
      ctx.fillRect(bx - 5, by, barW * (e.hp / e.maxHp), barH);
      ctx.fillStyle = '#ffcc00';
      ctx.font = '6px "Press Start 2P"';
      ctx.textAlign = 'center';
      ctx.fillText('MINI-BOSS', bx + e.w / 2, by - 3);
      ctx.textAlign = 'left';
      // Shield indicator for shielded type
      if (e.mbPattern === 'shielded' && e.shieldActive) {
        ctx.globalAlpha = 0.3;
        ctx.fillStyle = '#4488ff';
        ctx.fillRect(bx + (e.facing > 0 ? e.w - 4 : -4), e.y, 8, e.h);
        ctx.globalAlpha = 1;
      }
    }
    // Hit flash
    if (e.hitFlash > 0) {
      ctx.globalAlpha = 0.4;
      ctx.fillStyle = '#fff';
      ctx.fillRect(e.x - camX, e.y, e.w, e.h);
      ctx.globalAlpha = 1;
      e.hitFlash--;
    }
  }

  // Draw powerups
  for (const pw of powerups) {
    if (pw.x < camX - 50 || pw.x > camX + viewW() + 50) continue;
    const pwY = pw.y + Math.sin(Date.now() * 0.005 + pw.bobPhase) * 5;
    const sx = pw.x - camX;
    const pulse = 0.5 + Math.sin(Date.now() * 0.008) * 0.5;

    let color;
    let label;
    switch (pw.type) {
      case 'SPREAD': color = '#ff8800'; label = 'S'; break;
      case 'LASER': color = '#00ffff'; label = 'L'; break;
      case 'MACHINE': color = '#ff4444'; label = 'M'; break;
      case 'FLAME': color = '#ff6600'; label = 'F'; break;
      case 'ROCKET': color = '#ff2222'; label = 'R'; break;
      case 'HOMING': color = '#ff44ff'; label = 'H'; break;
      case 'WAVE': color = '#44ff88'; label = 'W'; break;
      case 'LIFE': color = '#ff4488'; label = '‚ô•'; break;
    }

    // Outer glow
    ctx.globalAlpha = 0.15 + pulse * 0.15;
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(sx + pw.w / 2, pwY + pw.h / 2, 18 + pulse * 6, 0, Math.PI * 2);
    ctx.fill();

    // Inner glow
    ctx.globalAlpha = 0.3 + pulse * 0.2;
    ctx.beginPath();
    ctx.arc(sx + pw.w / 2, pwY + pw.h / 2, 14 + pulse * 3, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;

    // Box
    ctx.fillStyle = '#333';
    ctx.fillRect(sx - 2, pwY - 2, pw.w + 4, pw.h + 4);
    ctx.fillStyle = color;
    ctx.fillRect(sx, pwY, pw.w, pw.h);

    // Shine highlight
    ctx.fillStyle = 'rgba(255,255,255,0.3)';
    ctx.fillRect(sx + 2, pwY + 2, pw.w - 6, 4);

    ctx.fillStyle = '#fff';
    ctx.font = '10px "Press Start 2P"';
    ctx.fillText(label, sx + 5, pwY + 14);

    // Sparkle particles (occasional)
    if (Math.random() < 0.08) {
      spawnGlowParticles(pw.x + Math.random() * pw.w, pwY + Math.random() * pw.h, color, 1, 1, 20);
    }
  }

  // Draw vehicle pickups
  for (const vp of vehiclePickups) {
    if (vp.collected) continue;
    if (vp.x < camX - 60 || vp.x > camX + viewW() + 60) continue;
    const vDef = VEHICLES[vp.type];
    const bob = Math.sin(Date.now() * 0.004 + vp.bobPhase) * 4;
    const sx = vp.x - camX;
    const sy = vp.y + bob;
    const pulse = 0.5 + Math.sin(Date.now() * 0.006) * 0.5;

    // Glow aura
    ctx.globalAlpha = 0.12 + pulse * 0.12;
    ctx.fillStyle = vDef.color;
    ctx.beginPath();
    ctx.arc(sx + vp.w / 2, sy + vp.h / 2, 35 + pulse * 8, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;

    // Draw mini vehicle preview
    ctx.save();
    ctx.translate(sx, sy);
    if (vp.type === 'HOVERBIKE') {
      ctx.fillStyle = '#44ccff';
      ctx.fillRect(4, 6, 40, 10);
      ctx.fillStyle = '#88eeff';
      ctx.fillRect(36, 2, 8, 8);
      ctx.fillStyle = '#3399cc';
      ctx.beginPath(); ctx.moveTo(44, 6); ctx.lineTo(48, 11); ctx.lineTo(44, 16); ctx.fill();
      // Hover glow
      ctx.globalAlpha = 0.4 + pulse * 0.3;
      ctx.fillStyle = '#44eeff';
      ctx.fillRect(8, 18, 32, 3);
      ctx.globalAlpha = 1;
    } else {
      ctx.fillStyle = '#555555';
      ctx.fillRect(0, 22, 56, 10);
      ctx.fillStyle = '#88aa55';
      ctx.fillRect(6, 10, 44, 14);
      ctx.fillStyle = '#779944';
      ctx.fillRect(16, 2, 24, 10);
      ctx.fillStyle = '#555555';
      ctx.fillRect(40, 4, 14, 4);
    }
    ctx.restore();

    // Label
    ctx.fillStyle = '#ffffff';
    ctx.font = '7px "Press Start 2P"';
    ctx.textAlign = 'center';
    ctx.fillText(vDef.name, sx + vp.w / 2, sy - 6);
    ctx.textAlign = 'left';

    // Sparkles
    if (Math.random() < 0.1) {
      spawnGlowParticles(vp.x + Math.random() * vp.w, vp.y + bob + Math.random() * vp.h, vDef.color, 1, 1.5, 25);
    }
  }

  // Draw treasure items
  for (const t of treasureItems) {
    if (t.x < camX - 50 || t.x > camX + viewW() + 50) continue;
    const td = TREASURES[t.type];
    const bobY = t.onGround && t.vy === 0 ? Math.sin(Date.now() * 0.006 + t.bobPhase) * 3 : 0;
    const sx = t.x - camX;
    const sy = t.y + bobY;
    const pulse = 0.5 + Math.sin(Date.now() * 0.01) * 0.5;

    // Fade out when about to expire
    if (t.life < 60) ctx.globalAlpha = t.life / 60;

    // Glow
    const prevAlpha = ctx.globalAlpha;
    ctx.globalAlpha = prevAlpha * (0.2 + pulse * 0.15);
    ctx.fillStyle = td.color;
    ctx.beginPath();
    ctx.arc(sx + t.w / 2, sy + t.h / 2, 16 + pulse * 4, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = prevAlpha;

    // Item body
    if (t.type === 'gem_small' || t.type === 'gem_big') {
      ctx.fillStyle = td.color;
      ctx.beginPath();
      ctx.moveTo(sx + t.w / 2, sy);
      ctx.lineTo(sx + t.w, sy + t.h / 2);
      ctx.lineTo(sx + t.w / 2, sy + t.h);
      ctx.lineTo(sx, sy + t.h / 2);
      ctx.fill();
      ctx.fillStyle = 'rgba(255,255,255,0.4)';
      ctx.beginPath();
      ctx.moveTo(sx + t.w / 2, sy + 2);
      ctx.lineTo(sx + t.w - 4, sy + t.h / 2);
      ctx.lineTo(sx + t.w / 2, sy + t.h / 2);
      ctx.fill();
    } else if (t.type === 'gold') {
      ctx.fillStyle = '#ffcc00';
      ctx.beginPath();
      ctx.arc(sx + t.w / 2, sy + t.h / 2, 9, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#ffee66';
      ctx.beginPath();
      ctx.arc(sx + t.w / 2 - 1, sy + t.h / 2 - 1, 6, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#cc9900';
      ctx.font = '8px "Press Start 2P"';
      ctx.fillText('$', sx + 6, sy + 14);
    } else if (t.type === 'shield') {
      ctx.fillStyle = td.color;
      ctx.beginPath();
      ctx.moveTo(sx + t.w / 2, sy + 2);
      ctx.lineTo(sx + t.w - 2, sy + 6);
      ctx.lineTo(sx + t.w - 2, sy + t.h - 6);
      ctx.lineTo(sx + t.w / 2, sy + t.h);
      ctx.lineTo(sx + 2, sy + t.h - 6);
      ctx.lineTo(sx + 2, sy + 6);
      ctx.fill();
      ctx.fillStyle = '#fff';
      ctx.font = '8px "Press Start 2P"';
      ctx.fillText('+', sx + 5, sy + 14);
    } else if (t.type === 'speed') {
      ctx.fillStyle = td.color;
      ctx.fillRect(sx + 3, sy + 2, 14, 16);
      ctx.fillStyle = '#000';
      ctx.font = '12px sans-serif';
      ctx.fillText('‚ö°', sx + 3, sy + 16);
    } else if (t.type === 'life') {
      ctx.fillStyle = td.color;
      ctx.font = '14px "Press Start 2P"';
      ctx.fillText('‚ô•', sx + 2, sy + 16);
    } else if (t.type === 'weapon') {
      ctx.fillStyle = '#333';
      ctx.fillRect(sx, sy + 2, t.w, t.h - 4);
      ctx.fillStyle = td.color;
      ctx.fillRect(sx + 2, sy + 4, t.w - 4, t.h - 8);
      ctx.fillStyle = '#fff';
      ctx.font = '8px "Press Start 2P"';
      ctx.fillText('?', sx + 6, sy + 14);
    }

    // Sparkle
    if (Math.random() < 0.1) {
      spawnGlowParticles(t.x + Math.random() * t.w, t.y + bobY + Math.random() * t.h, td.color, 1, 1, 15);
    }
    ctx.globalAlpha = 1;
  }

  // Draw dig progress bar
  if (player.digging && player.digTimer > 0 && !player.dead) {
    const progress = player.digTimer / DIG_TIME;
    const tx = player.digCol * TILE + TILE / 2 - camX;
    const ty = player.digRow * TILE + TILE / 2;
    // Position bar near the target tile
    const bx = tx - 12;
    const by = ty - 4;
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.fillRect(bx - 1, by - 1, 26, 7);
    ctx.fillStyle = progress < 0.5 ? '#ffcc00' : '#44ff44';
    ctx.fillRect(bx, by, 24 * progress, 5);
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 0.5;
    ctx.strokeRect(bx, by, 24, 5);

    // Direction arrow
    ctx.fillStyle = '#ffcc00';
    const ax = tx, ay = ty;
    ctx.globalAlpha = 0.6;
    if (player.digDirY > 0) ctx.fillText('‚ñº', tx - 4, ty + 14);
    else if (player.digDirY < 0) ctx.fillText('‚ñ≤', tx - 4, ty - 10);
    else if (player.digDirX > 0) ctx.fillText('‚ñ∫', tx + 10, ty + 4);
    else if (player.digDirX < 0) ctx.fillText('‚óÑ', tx - 16, ty + 4);
    ctx.globalAlpha = 1;
  }

  // Draw player
  if (!player.dead) {
    if (player.invincible > 0 && Math.floor(player.invincible / 3) % 2) {
      // Blink when invincible
    } else if (player.inVehicle) {
      drawVehicle(player);
    } else if (useSprites) {
      const sprKey = player.charId ? 'char_' + player.charId : 'p1';
      drawPlayerSprite(player, SPR[sprKey] ? sprKey : 'p1');
    } else if (player.onLadder) {
      drawClimbingChar(player.x, player.y, player.w, player.h, player.climbFrame);
    } else if (player.wallClimbing) {
      drawWallClimbingChar(player.x, player.y, player.w, player.h, player.wallClimbFrame, player.wallClimbDir);
    } else {
      drawPixelChar(player.x, player.y, player.w, player.h, player.charColor || '#338833',
        player.facing, player.prone, player.animFrame, player.shooting, player.aimY);
    }
  }

  // Draw grapple hook
  if (player.grapple && !player.dead) {
    const g = player.grapple;
    const px = player.x + player.w / 2 - camX;
    const py = player.y + 4;
    const hx = g.state === 'firing' ? g.x - camX : g.anchorX - camX;
    const hy = g.state === 'firing' ? g.y : Math.max(0, g.anchorY);

    // Rope
    if (g.state === 'hanging') {
      // Curved rope for hanging/swinging
      ctx.strokeStyle = '#8899aa';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(hx, hy);
      // Slight sag in rope
      const midX = (hx + px) / 2 + g.swingAngle * 5;
      const midY = (hy + py) / 2 + 4;
      ctx.quadraticCurveTo(midX, midY, px, py);
      ctx.stroke();
      // Rope glow
      ctx.globalAlpha = 0.25;
      ctx.strokeStyle = '#66eeff';
      ctx.lineWidth = 5;
      ctx.beginPath();
      ctx.moveTo(hx, hy);
      ctx.quadraticCurveTo(midX, midY, px, py);
      ctx.stroke();
      ctx.globalAlpha = 1;
    } else {
      // Straight rope for firing/latched/pulling
      ctx.strokeStyle = '#8899aa';
      ctx.lineWidth = 2;
      ctx.setLineDash([4, 3]);
      ctx.beginPath();
      ctx.moveTo(px, py);
      ctx.lineTo(hx, hy);
      ctx.stroke();
      ctx.setLineDash([]);
      // Rope glow
      ctx.globalAlpha = 0.3;
      ctx.strokeStyle = g.state === 'pulling' ? '#66eeff' : '#aaccff';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(px, py);
      ctx.lineTo(hx, hy);
      ctx.stroke();
      ctx.globalAlpha = 1;
    }

    // Anchor head
    if (g.state === 'firing') {
      // Spinning hook
      const angle = Date.now() * 0.02;
      ctx.fillStyle = '#ccddee';
      ctx.beginPath();
      ctx.arc(hx, hy, 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.save();
      ctx.translate(hx, hy);
      ctx.rotate(angle);
      ctx.fillStyle = '#889999';
      ctx.fillRect(-5, -1, 4, 2);
      ctx.fillRect(1, -1, 4, 2);
      ctx.fillRect(-1, -5, 2, 4);
      ctx.restore();
    } else if (g.isCeiling) {
      // Ceiling anchor ‚Äî horizontal bar
      ctx.fillStyle = '#aabbcc';
      ctx.fillRect(hx - 8, hy, 16, 3);
      ctx.fillStyle = '#ddeeff';
      ctx.fillRect(hx - 6, hy, 12, 1);
      // Bolts
      ctx.fillStyle = '#667788';
      ctx.fillRect(hx - 6, hy, 2, 3);
      ctx.fillRect(hx + 4, hy, 2, 3);
    } else {
      // Tile anchor ‚Äî prongs embedded in tile
      ctx.fillStyle = g.state === 'hanging' ? '#88ccff' : '#ffcc44';
      ctx.beginPath();
      ctx.arc(hx, hy, 4, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#ffdd66';
      ctx.fillRect(hx - 5, hy - 1, 3, 2);
      ctx.fillRect(hx + 2, hy - 1, 3, 2);
      ctx.fillRect(hx - 1, hy - 5, 2, 3);
    }

    // Hanging glow pulse
    if (g.state === 'hanging') {
      const pulse = Math.sin(Date.now() * 0.005) * 0.15 + 0.15;
      ctx.globalAlpha = pulse;
      ctx.fillStyle = '#88ccff';
      ctx.beginPath();
      ctx.arc(hx, hy, 8, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }
    // Latched flash
    if (g.state === 'latched') {
      const flash = Math.sin(Date.now() * 0.03) * 0.5 + 0.5;
      ctx.globalAlpha = flash * 0.5;
      ctx.fillStyle = '#ffff88';
      ctx.beginPath();
      ctx.arc(hx, hy, 8, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }
  }

  // Draw player 2 (co-op mode)
  if (coopMode && player2 && !player2.dead) {
    if (player2.invincible > 0 && Math.floor(player2.invincible / 3) % 2) {
      // Blink when invincible
    } else if (player2.inVehicle) {
      drawVehicle(player2);
    } else if (useSprites) {
      const sprKey2 = player2.charId ? 'char_' + player2.charId : 'p2';
      drawPlayerSprite(player2, SPR[sprKey2] ? sprKey2 : 'p2');
    } else if (player2.onLadder) {
      drawClimbingChar(player2.x, player2.y, player2.w, player2.h, player2.climbFrame);
    } else if (player2.wallClimbing) {
      drawWallClimbingChar(player2.x, player2.y, player2.w, player2.h, player2.wallClimbFrame, player2.wallClimbDir);
    } else {
      drawPixelChar(player2.x, player2.y, player2.w, player2.h, player2.charColor || '#3366ff',
        player2.facing, player2.prone, player2.animFrame, player2.shooting, player2.aimY);
    }
  }

  // Draw grapple hook (player 2)
  if (coopMode && player2 && player2.grapple && !player2.dead) {
    const g = player2.grapple;
    const px = player2.x + player2.w / 2 - camX;
    const py = player2.y + 4;
    const hx = g.state === 'firing' ? g.x - camX : g.anchorX - camX;
    const hy = g.state === 'firing' ? g.y : Math.max(0, g.anchorY);

    // Rope
    if (g.state === 'hanging') {
      // Curved rope for hanging/swinging
      ctx.strokeStyle = '#6688ff';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(hx, hy);
      // Slight sag in rope
      const midX = (hx + px) / 2 + g.swingAngle * 5;
      const midY = (hy + py) / 2 + 4;
      ctx.quadraticCurveTo(midX, midY, px, py);
      ctx.stroke();
      // Rope glow
      ctx.globalAlpha = 0.25;
      ctx.strokeStyle = '#66eeff';
      ctx.lineWidth = 5;
      ctx.beginPath();
      ctx.moveTo(hx, hy);
      ctx.quadraticCurveTo(midX, midY, px, py);
      ctx.stroke();
      ctx.globalAlpha = 1;
    } else {
      // Straight rope for firing/latched/pulling
      ctx.strokeStyle = '#6688ff';
      ctx.lineWidth = 2;
      ctx.setLineDash([4, 3]);
      ctx.beginPath();
      ctx.moveTo(px, py);
      ctx.lineTo(hx, hy);
      ctx.stroke();
      ctx.setLineDash([]);
      // Rope glow
      ctx.globalAlpha = 0.3;
      ctx.strokeStyle = g.state === 'pulling' ? '#66eeff' : '#aaccff';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(px, py);
      ctx.lineTo(hx, hy);
      ctx.stroke();
      ctx.globalAlpha = 1;
    }

    // Anchor head
    if (g.state === 'firing') {
      // Spinning hook
      const angle = Date.now() * 0.02;
      ctx.fillStyle = '#6688ff';
      ctx.beginPath();
      ctx.arc(hx, hy, 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.save();
      ctx.translate(hx, hy);
      ctx.rotate(angle);
      ctx.fillStyle = '#6688ff';
      ctx.beginPath();
      ctx.arc(5, 0, 2, 0, Math.PI * 2); ctx.fill();
      ctx.restore();
    } else if (g.state === 'latched') {
      ctx.fillStyle = '#ffaa44';
      ctx.beginPath();
      ctx.arc(hx, hy, 4, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#ffdd66';
      ctx.fillRect(hx - 5, hy - 1, 3, 2);
      ctx.fillRect(hx + 2, hy - 1, 3, 2);
      ctx.fillRect(hx - 1, hy - 5, 2, 3);
    }

    // Hanging glow pulse
    if (g.state === 'hanging') {
      const pulse = Math.sin(Date.now() * 0.005) * 0.15 + 0.15;
      ctx.globalAlpha = pulse;
      ctx.fillStyle = '#88ccff';
      ctx.beginPath();
      ctx.arc(hx, hy, 8, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }
    // Latched flash
    if (g.state === 'latched') {
      const flash = Math.sin(Date.now() * 0.03) * 0.5 + 0.5;
      ctx.globalAlpha = flash * 0.5;
      ctx.fillStyle = '#ffff88';
      ctx.beginPath();
      ctx.arc(hx, hy, 8, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }
  }

  // Draw player bullets
  for (const b of bullets) {
    const bx = b.x - camX;

    if (b.btype === 'flame') {
      // Flame: flickering orange/red
      const flicker = 0.5 + Math.random() * 0.5;
      ctx.globalAlpha = (b.life / 30) * flicker;
      ctx.fillStyle = '#ff6600';
      ctx.beginPath();
      ctx.arc(bx, b.y, b.size * 1.3, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#ffcc00';
      ctx.beginPath();
      ctx.arc(bx, b.y, b.size * 0.7, 0, Math.PI * 2); ctx.fill();
    } else if (b.btype === 'rocket') {
      // Rocket: elongated with trail
      ctx.globalAlpha = 0.4;
      ctx.fillStyle = '#888';
      ctx.beginPath();
      ctx.arc(bx - b.vx * 0.8, b.y - b.vy * 0.8, 4, 0, Math.PI * 2); ctx.fill();
      ctx.globalAlpha = 1;
      ctx.fillStyle = '#cc2222';
      ctx.save();
      ctx.translate(bx, b.y);
      ctx.rotate(Math.atan2(b.vy, b.vx));
      ctx.fillRect(-6, -2.5, 12, 5);
      ctx.fillStyle = '#ff4444';
      ctx.fillRect(4, -1.5, 4, 3);
      ctx.restore();
    } else if (b.btype === 'homing') {
      // Homing: magenta with spiraling trail
      ctx.globalAlpha = 0.3;
      ctx.fillStyle = '#ff44ff';
      ctx.beginPath();
      ctx.arc(bx, b.y, b.size * 2, 0, Math.PI * 2); ctx.fill();
      ctx.globalAlpha = 1;
      ctx.fillStyle = '#ff88ff';
      ctx.beginPath();
      ctx.arc(bx, b.y, b.size, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(bx, b.y, b.size * 0.4, 0, Math.PI * 2); ctx.fill();
    } else if (b.btype === 'wave') {
      // Wave: pulsing green
      ctx.globalAlpha = 0.3;
      ctx.fillStyle = b.color;
      ctx.beginPath();
      ctx.arc(bx, b.y, b.size * 2, 0, Math.PI * 2); ctx.fill();
      ctx.globalAlpha = 0.8;
      ctx.beginPath();
      ctx.arc(bx, b.y, b.size * 1.2, 0, Math.PI * 2); ctx.fill();
      ctx.globalAlpha = 1;
      ctx.fillStyle = '#aaffcc';
      ctx.beginPath();
      ctx.arc(bx, b.y, b.size * 0.6, 0, Math.PI * 2); ctx.fill();
    } else if (b.btype === 'lightning') {
      // Lightning: jagged blue-white bolt
      ctx.strokeStyle = '#88eeff';
      ctx.lineWidth = 2;
      ctx.shadowColor = '#88eeff';
      ctx.shadowBlur = 8;
      ctx.beginPath();
      ctx.moveTo(bx - b.vx * 2, b.y - b.vy * 2);
      for (let seg = 0; seg < 4; seg++) {
        const t = (seg + 1) / 4;
        ctx.lineTo(bx - b.vx * 2 * (1 - t) + (Math.random() - 0.5) * 6, b.y - b.vy * 2 * (1 - t) + (Math.random() - 0.5) * 6);
      }
      ctx.stroke();
      ctx.fillStyle = '#ffffff';
      ctx.beginPath(); ctx.arc(bx, b.y, b.size * 0.6, 0, Math.PI * 2); ctx.fill();
      ctx.shadowBlur = 0;
    } else if (b.btype === 'boomerang') {
      // Boomerang: spinning blade
      const rot = (b.wavePhase || 0);
      ctx.save();
      ctx.translate(bx, b.y);
      ctx.rotate(rot);
      ctx.fillStyle = '#ffdd44';
      ctx.fillRect(-b.size, -2, b.size * 2, 4);
      ctx.fillRect(-2, -b.size, 4, b.size * 2);
      ctx.fillStyle = '#fff';
      ctx.fillRect(-1, -1, 2, 2);
      ctx.restore();
    } else if (b.btype === 'blackhole') {
      // Black hole: pulsing dark vortex
      const pulse = Math.sin(Date.now() * 0.01) * 2;
      ctx.globalAlpha = 0.3;
      ctx.fillStyle = '#6622cc';
      ctx.beginPath(); ctx.arc(bx, b.y, b.size + pulse + 6, 0, Math.PI * 2); ctx.fill();
      ctx.globalAlpha = 0.6;
      ctx.fillStyle = '#220044';
      ctx.beginPath(); ctx.arc(bx, b.y, b.size + pulse, 0, Math.PI * 2); ctx.fill();
      ctx.globalAlpha = 1;
      ctx.fillStyle = '#9944ff';
      ctx.beginPath(); ctx.arc(bx, b.y, b.size * 0.4, 0, Math.PI * 2); ctx.fill();
      ctx.strokeStyle = '#bb66ff';
      ctx.lineWidth = 1;
      for (let a = 0; a < 3; a++) {
        const ang = Date.now() * 0.005 + a * 2.09;
        ctx.beginPath();
        ctx.arc(bx, b.y, b.size * 0.7, ang, ang + 1);
        ctx.stroke();
      }
    } else if (b.btype === 'mine') {
      // Mine: small blinking box
      ctx.fillStyle = b.mineArmed ? (b.mineTimer % 20 < 10 ? '#ff4444' : '#882222') : '#888888';
      ctx.fillRect(bx - 4, b.y - 4, 8, 8);
      ctx.fillStyle = '#444';
      ctx.fillRect(bx - 3, b.y - 5, 6, 2);
      if (b.mineArmed) {
        ctx.fillStyle = '#ff0000';
        ctx.fillRect(bx - 1, b.y - 6, 2, 2);
      }
    } else if (b.btype === 'tank_shell') {
      // Tank shell: glowing orange projectile
      ctx.globalAlpha = 0.4;
      ctx.fillStyle = '#ffaa00';
      ctx.beginPath();
      ctx.arc(bx, b.y, 7, 0, Math.PI * 2); ctx.fill();
      ctx.globalAlpha = 1;
      ctx.fillStyle = '#ffcc44';
      ctx.beginPath();
      ctx.arc(bx, b.y, 4, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#ffffff';
      ctx.beginPath();
      ctx.arc(bx, b.y, 2, 0, Math.PI * 2); ctx.fill();
    } else if (b.btype === 'vehicle') {
      // Vehicle bullet: small bright bolt
      ctx.fillStyle = b.color || '#88eeff';
      ctx.fillRect(bx - 3, b.y - 1, 6, 2);
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(bx - 1, b.y, 2, 1);
    } else if (b.btype === 'pierce') {
      // Laser: long beam line
      ctx.globalAlpha = 0.3;
      ctx.fillStyle = b.color;
      ctx.beginPath();
      ctx.arc(bx, b.y, b.size * 1.8, 0, Math.PI * 2); ctx.fill();
      ctx.globalAlpha = 1;
      ctx.shadowColor = b.color;
      ctx.shadowBlur = 10;
      const angle = Math.atan2(b.vy, b.vx);
      ctx.save();
      ctx.translate(bx, b.y);
      ctx.rotate(angle);
      ctx.fillStyle = '#fff';
      ctx.fillRect(-10, -1, 20, 2);
      ctx.fillStyle = b.color;
      ctx.fillRect(-8, -2, 16, 4);
      ctx.restore();
      ctx.shadowBlur = 0;
    } else {
      // Normal bullet
      ctx.globalAlpha = 0.3;
      ctx.fillStyle = b.color;
      ctx.beginPath();
      ctx.arc(bx - b.vx * 0.5, b.y - b.vy * 0.5, b.size * 1.5, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
      ctx.shadowColor = b.color;
      ctx.shadowBlur = 8;
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(bx, b.y, b.size * 0.7, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = b.color;
      ctx.beginPath();
      ctx.arc(bx, b.y, b.size, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
    }
  }
  ctx.globalAlpha = 1;
  ctx.shadowBlur = 0;

  // Draw enemy bullets
  for (const b of enemyBullets) {
    const bx = b.x - camX;
    if (b.isBomb) {
      // Bomb
      ctx.fillStyle = '#444';
      ctx.beginPath();
      ctx.arc(bx, b.y, 5, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#ff8844';
      ctx.beginPath();
      ctx.arc(bx, b.y - 5, 2, 0, Math.PI * 2);
      ctx.fill();
    } else {
      // Regular bullet
      ctx.globalAlpha = 0.25;
      ctx.fillStyle = '#ff0000';
      ctx.beginPath();
      ctx.arc(bx, b.y, 8, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
      ctx.fillStyle = '#ff6666';
      ctx.shadowColor = '#ff0000';
      ctx.shadowBlur = 6;
      ctx.beginPath();
      ctx.arc(bx, b.y, 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#ffffff';
      ctx.beginPath();
      ctx.arc(bx, b.y, 1.5, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
    }
  }
  const weaponText = player.inVehicle
    ? VEHICLES[player.vehicleType].name + ' [' + player.vehicleHP + '/' + player.vehicleMaxHP + ']'
    : (player.charId && player.charId !== 'COMMANDO' ? player.charId + ': ' : '') + player.weapon.name + (player.weapon.isFusion ? ' ‚ö°' : '');
  document.getElementById('weaponDisplay').textContent = weaponText;
  // Large HUD accessibility option
  const hudEl = document.getElementById('hud');
  if (hudEl) hudEl.style.fontSize = accessLargeHUD ? '14px' : '';

  drawParticles(camX);
  drawPopups(camX);

  // Dynamic lighting (drawn in world space before restore)
  drawLights(camX);

  // Restore screen shake transform
  ctx.restore();

  // Weather effects (screen-space)
  drawWeather();

  // Screen flash overlay (drawn after shake restore so it covers full screen)
  if (flashAlpha > 0) {
    ctx.globalAlpha = flashAlpha;
    ctx.fillStyle = flashColor;
    ctx.fillRect(0, 0, GAME_W, GAME_H);
    ctx.globalAlpha = 1;
  }

  // Update HUD
  const livesStr = '‚ô•'.repeat(Math.max(0, player.lives));
  document.getElementById('livesDisplay').textContent = livesStr;
  document.getElementById('scoreDisplay').textContent = 'SCORE: ' + score + (runStats.combo >= 3 ? ` (${runStats.combo}x)` : '');
  document.getElementById('weaponDisplay').textContent = player.weapon.name;
  document.getElementById('stageDisplay').textContent = stage + '-' + getTheme(stage).name;
  // Mode-specific HUD info on stageDisplay
  if (gameMode === 'endless') {
    document.getElementById('stageDisplay').textContent = 'WAVE ' + endlessWave + ' | KILLS: ' + endlessKills + '/' + endlessKillsNeeded;
  } else if (gameMode === 'bossrush') {
    const brSec = Math.floor(bossRushTimer / 60);
    document.getElementById('stageDisplay').textContent = 'BOSS ' + Math.min(bossRushIdx + 1, 10) + '/10 | ' + brSec + 's';
  } else if (gameMode === 'timeattack') {
    const taSec = (timeAttackTimer / 60).toFixed(1);
    document.getElementById('stageDisplay').textContent = stage + '-' + getTheme(stage).name + ' | ' + taSec + 's';
  } else if (gameMode === 'newgameplus') {
    document.getElementById('stageDisplay').textContent = 'NG+' + ngPlusLevel + ' ' + stage + '-' + getTheme(stage).name;
  } else if (gameMode === 'challenge' && activeChallenge) {
    const ch = CHALLENGES.find(c => c.id === activeChallenge);
    document.getElementById('stageDisplay').textContent = stage + '-' + getTheme(stage).name + ' [' + (ch ? ch.name : activeChallenge) + ']';
  }
  const diffEl = document.getElementById('diffDisplay');
  if (diffEl) { diffEl.textContent = getDifficultyLabel(); diffEl.style.color = getDifficultyColor(); }
  document.getElementById('zoomDisplay').textContent = 'üîç' + Math.round(zoom * 100) + '%';
  const playerDepth = Math.max(0, Math.floor((player.y + player.h) / TILE) - level.groundRow);
  document.getElementById('depthDisplay').textContent = playerDepth > 0 ? ('‚õè' + playerDepth + 'm') : '';
  const grapDisp = document.getElementById('grappleDisplay');
  if (player.grapple && player.grapple.state === 'hanging') grapDisp.textContent = 'ü™ù HANGING';
  else if (player.grapple) grapDisp.textContent = 'ü™ù ACTIVE';
  else if (player.grappleCooldown > 0) grapDisp.textContent = 'ü™ù ...';
  else grapDisp.textContent = playerDepth > 0 ? 'ü™ù READY' : '';
  
  // Update co-op display
  const coopDisp = document.getElementById('coopDisplay');
  if (coopMode && player2) {
    coopDisp.style.display = 'block';
    const player2LivesStr = '‚ô•'.repeat(Math.max(0, player2.lives));
    document.getElementById('player2LivesDisplay').textContent = player2LivesStr;
  } else {
    coopDisp.style.display = 'none';
  }

  // --- Admin overlays ---
  if (adminOpen) {
    ctx.save();
    ctx.scale(zoom, zoom);
    ctx.translate(shakeX, shakeY);
    ctx.translate(0, -camY);

    // Hitboxes
    if (showHitboxes) {
      ctx.lineWidth = 1 / zoom;
      ctx.strokeStyle = '#00ff00';
      ctx.strokeRect(player.x - camX, player.y, player.w, player.h);
      for (const e of enemies) {
        if (!e.active) continue;
        ctx.strokeStyle = e.isBoss ? '#ff00ff' : '#ff0000';
        ctx.strokeRect(e.x - camX, e.y, e.w, e.h);
      }
      for (const o of objects) {
        ctx.strokeStyle = '#ffaa00';
        ctx.strokeRect(o.x - camX, o.y, o.w, o.h);
      }
      for (const b of bullets) {
        ctx.strokeStyle = '#ffff00';
        ctx.strokeRect(b.x - camX - b.size, b.y - b.size, b.size*2, b.size*2);
      }
    }

    // Editor grid overlay
    if (editorMode && level) {
      const vw = viewW();
      const startCol = Math.max(0, Math.floor(camX / TILE) - 1);
      const endCol = Math.min(level.cols, Math.ceil((camX + vw) / TILE) + 1);

      ctx.globalAlpha = 0.12;
      ctx.strokeStyle = '#88aaff';
      ctx.lineWidth = 0.5 / zoom;
      for (let c = startCol; c <= endCol; c++) {
        ctx.beginPath();
        ctx.moveTo(c * TILE - camX, 0);
        ctx.lineTo(c * TILE - camX, level.rows * TILE);
        ctx.stroke();
      }
      for (let r = 0; r <= level.rows; r++) {
        ctx.beginPath();
        ctx.moveTo(startCol * TILE - camX, r * TILE);
        ctx.lineTo(endCol * TILE - camX, r * TILE);
        ctx.stroke();
      }

      // Highlight empty tiles faintly to help see grid
      ctx.globalAlpha = 0.04;
      ctx.fillStyle = '#ffffff';
      for (let r = 0; r < level.rows; r++) {
        for (let c = startCol; c < endCol; c++) {
          if (level.map[r][c] === 0 && (r + c) % 2 === 0) {
            ctx.fillRect(c * TILE - camX, r * TILE, TILE, TILE);
          }
        }
      }
      ctx.globalAlpha = 1;
    }

    ctx.restore();

    // God mode indicator
    if (godMode) {
      ctx.fillStyle = '#44ff44';
      ctx.font = '8px "Press Start 2P"';
      ctx.globalAlpha = 0.6 + Math.sin(Date.now() * 0.005) * 0.3;
      ctx.fillText('GOD MODE', 10, GAME_H - 10);
      ctx.globalAlpha = 1;
    }
    // Editor mode indicator
    if (editorMode) {
      ctx.fillStyle = '#88aaff';
      ctx.font = '8px "Press Start 2P"';
      ctx.globalAlpha = 0.6;
      ctx.fillText('EDITOR', 10, GAME_H - (godMode ? 24 : 10));
      ctx.globalAlpha = 1;
    }
    // Speed boost indicator
    if (playerSpeedBoost > 0) {
      let yOff = 10 + (godMode ? 14 : 0) + (editorMode ? 14 : 0);
      ctx.fillStyle = '#ffff44';
      ctx.font = '8px "Press Start 2P"';
      ctx.globalAlpha = 0.7 + Math.sin(Date.now() * 0.01) * 0.3;
      ctx.fillText('‚ö° SPEED', 10, GAME_H - yOff);
      ctx.globalAlpha = 1;
    }
    // Digging indicator
    if (player.digging && !player.dead) {
      const digSx = player.x + player.w / 2 - camX;
      const digSy = player.y - 12;
      ctx.fillStyle = '#ffcc00';
      ctx.font = '7px "Press Start 2P"';
      ctx.textAlign = 'center';
      ctx.globalAlpha = 0.7;
      const dirs = { '0,1': 'DIG ‚ñº', '0,-1': 'DIG ‚ñ≤', '1,0': 'DIG ‚ñ∫', '-1,0': 'DIG ‚óÑ' };
      ctx.fillText(dirs[player.digDirX + ',' + player.digDirY] || 'DIG', digSx, digSy);
      ctx.textAlign = 'left';
      ctx.globalAlpha = 1;
    }
    // Grapple indicator
    if (player.grapple) {
      const grapSx = player.x + player.w / 2 - camX;
      const grapSy = player.y - 6;
      ctx.fillStyle = '#88ccff';
      ctx.font = '6px "Press Start 2P"';
      ctx.textAlign = 'center';
      ctx.globalAlpha = 0.7;
      const gLabel = player.grapple.state === 'hanging' ? 'ü™ù HANGING' :
                     player.grapple.state === 'pulling' ? 'ü™ù PULL' : 'ü™ù';
      ctx.fillText(gLabel, grapSx, grapSy);
      ctx.textAlign = 'left';
      ctx.globalAlpha = 1;
    }
  }

  // Aim assist indicator (in world space, before restore)
  if (accessAimAssist && player && !player.dead) drawAimAssistIndicator(player);
  if (accessAimAssist && coopMode && player2 && !player2.dead) drawAimAssistIndicator(player2);

  // Screen transition overlay (wipe/fade/circle)
  drawTransition();

  // Speedrun timer HUD (drawn over everything, in screen space)
  drawSpeedrunHUD();

  // Fusion indicator HUD
  if (fusionTimer > 0 && fusionHeldWeapon) {
    ctx.save();
    ctx.font = '7px "Press Start 2P"';
    ctx.textAlign = 'left';
    const alpha = Math.min(1, fusionTimer / 30);
    ctx.globalAlpha = alpha;
    ctx.fillStyle = '#ffaa00';
    ctx.fillText('FUSION: ' + fusionHeldWeapon + ' + ?', 8, GAME_H - 30);
    // Timer bar
    ctx.fillStyle = '#553300';
    ctx.fillRect(8, GAME_H - 22, 80, 4);
    ctx.fillStyle = '#ffaa00';
    ctx.fillRect(8, GAME_H - 22, 80 * (fusionTimer / FUSION_WINDOW), 4);
    ctx.globalAlpha = 1;
    ctx.restore();
  }

  // High contrast HUD overlay
  if (accessHighContrastHUD) {
    ctx.fillStyle = 'rgba(0,0,0,0.4)';
    ctx.fillRect(0, 0, GAME_W, 20);
    ctx.fillRect(0, GAME_H - 14, GAME_W, 14);
  }

  // Color-blind filter (post-process, before CRT)
  applyColorBlindFilter();

  // CRT post-processing (must be last)
  applyCRTEffect();
}

// --- OVERLAY ---
function controlsText() {
  const kb = (action) => keybinds[action].map(k => keyName(k)).join(' / ');
  let txt = `${kb('left')} ${kb('right')} ‚Äî MOVE   ${kb('up')} ${kb('down')} ‚Äî AIM<br>` +
         `${kb('shoot')} ‚Äî SHOOT   ${kb('grapple')} ‚Äî GRAPPLE HOOK<br>` +
         `${kb('jump')} / ${kb('up')} ‚Äî JUMP (also releases grapple)<br>` +
         `HOLD DIRECTION INTO WALL ‚Äî DIG   DOWN ‚Äî PRONE/DIG DOWN<br>` +
         `GRAPPLE: HANG ‚Üí ‚Üê‚Üí SWING ‚Üí JUMP TO LAUNCH<br>` +
         `SCROLL / +‚àí ‚Äî ZOOM (0 RESET)<br>` +
         `\` (BACKTICK) ‚Äî ADMIN PANEL`;
  if (gpState[0] || gpState[1]) {
    txt += `<br><span style="color:#44ff88">üéÆ GAMEPAD: D-PAD/STICK=MOVE  A=JUMP  B/X=SHOOT  Y/RB=GRAPPLE  START=START</span>`;
  }
  if (window.electronAPI) {
    txt += `<br><span style="color:#88aaff">F11 ‚Äî FULLSCREEN</span>`;
  }
  return txt;
}

// ============================================================
//  ONLINE MULTIPLAYER (WebRTC P2P)
// ============================================================
// Architecture: Host-authoritative. Host runs game loop & sends state.
// Guest sends inputs and receives state snapshots.
// Signaling: Manual copy/paste of base64-encoded SDP offers/answers.

const MP_SYNC_INTERVAL = 3;        // Send state every N frames (lower = smoother but more data)
const MP_INPUT_INTERVAL = 1;       // Send inputs every N frames
const MP_ICE_SERVERS = [
  { urls: 'stun:stun.l.google.com:19302' },
  { urls: 'stun:stun1.l.google.com:19302' },
];

let mpRole = null;                  // 'host' | 'guest' | null
let mpPeer = null;                  // RTCPeerConnection
let mpChannel = null;               // RTCDataChannel
let mpConnected = false;
let mpFrameCount = 0;
let mpRemoteInput = {               // Guest's input state (as seen by host)
  left: false, right: false, up: false, down: false,
  jump: false, jumpKey: false, shoot: false, grapple: false
};
let mpPingStart = 0;
let mpLatency = 0;

// --- Compact state for sync (omit particles/decorations, they're visual-only) ---
function getMpSyncState() {
  const sp = (p) => {
    if (!p) return null;
    return {
      x: Math.round(p.x), y: Math.round(p.y),
      vx: +(p.vx.toFixed(2)), vy: +(p.vy.toFixed(2)),
      facing: p.facing, aimX: p.aimX, aimY: p.aimY,
      onGround: p.onGround, dead: p.dead, lives: p.lives,
      invincible: p.invincible, prone: p.prone, shooting: p.shooting,
      onLadder: p.onLadder, wallClimbing: p.wallClimbing,
      wallClimbDir: p.wallClimbDir, fireTimer: p.fireTimer,
      respawnTimer: p.respawnTimer, animFrame: p.animFrame,
      _weaponType: (p.weapon && p.weapon.name) || 'RIFLE',
      grapple: p.grapple ? { x: p.grapple.x, y: p.grapple.y,
        anchorX: p.grapple.anchorX, anchorY: p.grapple.anchorY,
        state: p.grapple.state, vx: p.grapple.vx || 0, vy: p.grapple.vy || 0 } : null,
      grappleCooldown: p.grappleCooldown,
      digging: p.digging, digTimer: p.digTimer
    };
  };
  return {
    t: 's',                          // type = state
    sc: score, st: stage, gs: gameState,
    p1: sp(player), p2: sp(player2),
    en: enemies.map(e => ({ x: Math.round(e.x), y: Math.round(e.y), vx: +(e.vx||0).toFixed(1), vy: +(e.vy||0).toFixed(1),
      hp: e.hp, etype: e.etype, facing: e.facing, dead: e.dead, onGround: e.onGround,
      fireTimer: e.fireTimer || 0, isBoss: e.isBoss || false,
      bossPhase: e.bossPhase, bossTimer: e.bossTimer, bossHp: e.bossHp })),
    bu: bullets.map(b => ({ x: Math.round(b.x), y: Math.round(b.y), vx: +b.vx.toFixed(1), vy: +b.vy.toFixed(1),
      type: b.type || 'normal', owner: b.owner || 0 })),
    eb: enemyBullets.map(b => ({ x: Math.round(b.x), y: Math.round(b.y), vx: +b.vx.toFixed(1), vy: +b.vy.toFixed(1) })),
    pw: powerups.map(p => ({ x: Math.round(p.x), y: Math.round(p.y), vy: +(p.vy||0).toFixed(1), type: p.type, onGround: p.onGround })),
    cx: Math.round(camX), cy: Math.round(camY),
    fx: freezeFrames, sm: slowMo
  };
}

// --- Apply received state on the guest side ---
function applyMpState(s) {
  if (mpRole !== 'guest') return;

  score = s.sc;
  stage = s.st;

  // Handle game state transitions
  if (s.gs !== gameState) {
    if (s.gs === 'gameover') {
      gameState = 'gameover';
      playSound('game_over');
      showOverlay('GAME OVER', `SCORE: ${score}`, 'PRESS ENTER TO RETRY');
      return;
    } else if (s.gs === 'victory') {
      gameState = 'victory';
      playSound('victory');
      showOverlay('VICTORY!', `FINAL SCORE: ${score}`, 'PRESS ENTER TO PLAY AGAIN');
      return;
    }
    gameState = s.gs;
  }
  if (gameState !== 'playing') return;

  const restoreP = (target, src) => {
    if (!target || !src) return;
    target.x = src.x; target.y = src.y;
    target.vx = src.vx; target.vy = src.vy;
    target.facing = src.facing; target.aimX = src.aimX; target.aimY = src.aimY;
    target.onGround = src.onGround; target.dead = src.dead; target.lives = src.lives;
    target.invincible = src.invincible; target.prone = src.prone;
    target.shooting = src.shooting; target.onLadder = src.onLadder;
    target.wallClimbing = src.wallClimbing; target.wallClimbDir = src.wallClimbDir;
    target.fireTimer = src.fireTimer; target.respawnTimer = src.respawnTimer;
    target.animFrame = src.animFrame; target.digging = src.digging;
    target.digTimer = src.digTimer; target.grappleCooldown = src.grappleCooldown;
    if (src._weaponType && WEAPONS[src._weaponType]) target.weapon = WEAPONS[src._weaponType];
    if (src.grapple) {
      if (!target.grapple) target.grapple = {};
      Object.assign(target.grapple, src.grapple);
    } else { target.grapple = null; }
  };

  restoreP(player, s.p1);
  if (player2) restoreP(player2, s.p2);

  // Sync enemies
  enemies.length = 0;
  for (const e of s.en) {
    enemies.push({ x: e.x, y: e.y, vx: e.vx, vy: e.vy, hp: e.hp,
      etype: e.etype, facing: e.facing, dead: e.dead, onGround: e.onGround,
      w: ENEMY_TYPES[e.etype] ? ENEMY_TYPES[e.etype].w : 20,
      h: ENEMY_TYPES[e.etype] ? ENEMY_TYPES[e.etype].h : 32,
      fireTimer: e.fireTimer, isBoss: e.isBoss,
      bossPhase: e.bossPhase, bossTimer: e.bossTimer, bossHp: e.bossHp,
      speed: ENEMY_TYPES[e.etype] ? ENEMY_TYPES[e.etype].speed : 1,
      color: ENEMY_TYPES[e.etype] ? ENEMY_TYPES[e.etype].color : '#f00' });
  }

  // Sync bullets
  bullets.length = 0;
  for (const b of s.bu) bullets.push({ x: b.x, y: b.y, vx: b.vx, vy: b.vy, type: b.type, owner: b.owner, w: 6, h: 4 });
  enemyBullets.length = 0;
  for (const b of s.eb) enemyBullets.push({ x: b.x, y: b.y, vx: b.vx, vy: b.vy, w: 5, h: 5 });

  // Sync powerups
  powerups.length = 0;
  for (const p of s.pw) powerups.push({ x: p.x, y: p.y, vy: p.vy, type: p.type, onGround: p.onGround, w: 24, h: 24 });

  camX = s.cx; camY = s.cy;
  freezeFrames = s.fx || 0;
  slowMo = s.sm || 0;
}

// --- Send data over the data channel (safe wrapper) ---
function mpSend(obj) {
  if (mpChannel && mpChannel.readyState === 'open') {
    try { mpChannel.send(JSON.stringify(obj)); } catch(e) {}
  }
}

// --- Handle incoming messages ---
function mpOnMessage(evt) {
  let msg;
  try { msg = JSON.parse(evt.data); } catch(e) { return; }

  if (msg.t === 's') {
    // State update (guest receives from host)
    applyMpState(msg);
  } else if (msg.t === 'i') {
    // Input update (host receives from guest)
    mpRemoteInput = msg.i;
  } else if (msg.t === 'init') {
    // Initial full state (guest receives when joining)
    if (mpRole === 'guest') {
      // Restore the full level + state
      if (msg.level) {
        level = msg.level;
      }
      stage = msg.stage;
      score = msg.score;
      currentDifficulty = msg.difficulty || 'normal';
      if (DIFFICULTY_PRESETS[currentDifficulty]) {
        diffSettings = { ...DIFFICULTY_PRESETS[currentDifficulty] };
      }
      // Create players
      player = createPlayer(40, selectedCharacter);
      player2 = createPlayer(80, selectedCharacter2);
      coopMode = true;
      gameState = 'playing';
      overlay.classList.add('hidden');
      hud.classList.remove('hidden');
      // Apply positions from state
      if (msg.p1) {
        const restoreP = (target, src) => {
          target.x = src.x; target.y = src.y;
          target.vx = src.vx; target.vy = src.vy;
          target.facing = src.facing; target.lives = src.lives;
          if (src._weaponType && WEAPONS[src._weaponType]) target.weapon = WEAPONS[src._weaponType];
        };
        restoreP(player, msg.p1);
        if (msg.p2) restoreP(player2, msg.p2);
      }
      camX = msg.camX || 0; camY = msg.camY || 0;
      showSaveToast('Connected! You are Player 2', 'success');
    }
  } else if (msg.t === 'ping') {
    mpSend({ t: 'pong', ts: msg.ts });
  } else if (msg.t === 'pong') {
    mpLatency = Date.now() - msg.ts;
  } else if (msg.t === 'start') {
    // Host tells guest the game is (re)starting
    if (mpRole === 'guest') {
      stage = msg.stage || 1;
      score = 0;
      player = createPlayer(40, selectedCharacter);
      player2 = createPlayer(80, selectedCharacter2);
      coopMode = true;
      if (msg.level) level = msg.level;
      gameState = 'playing';
      overlay.classList.add('hidden');
      hud.classList.remove('hidden');
    }
  } else if (msg.t === 'chat') {
    showSaveToast(`${msg.from}: ${msg.msg}`, 'success');
  }
}

// --- Create RTCPeerConnection and set up channel ---
function mpCreatePeer() {
  mpPeer = new RTCPeerConnection({ iceServers: MP_ICE_SERVERS });
  mpPeer.oniceconnectionstatechange = () => {
    const st = mpPeer.iceConnectionState;
    if (st === 'disconnected' || st === 'failed' || st === 'closed') {
      mpDisconnect('Connection lost');
    }
  };
  return mpPeer;
}

function mpSetupChannel(ch) {
  mpChannel = ch;
  ch.onopen = () => {
    mpConnected = true;
    updateMpHud();
    showSaveToast(mpRole === 'host' ? 'Player 2 connected!' : 'Connected to host!', 'success');
    // If host, send initial game state
    if (mpRole === 'host') {
      coopMode = true;
      if (!player2) player2 = createPlayer(80);
      mpSend({
        t: 'init',
        level: { map: level.map, cols: level.cols, rows: level.rows,
                 groundRow: level.groundRow, treasureMap: level.treasureMap || {} },
        stage, score,
        difficulty: currentDifficulty,
        p1: getMpSyncState().p1,
        p2: getMpSyncState().p2,
        camX, camY
      });
    }
    // Start ping interval
    if (mpRole === 'host') {
      mpPeer._pingInterval = setInterval(() => {
        mpSend({ t: 'ping', ts: Date.now() });
      }, 2000);
    }
  };
  ch.onmessage = mpOnMessage;
  ch.onclose = () => mpDisconnect('Channel closed');
}

// --- Encode/decode SDP as compact base64 ---
function mpEncodeSDP(sdp) {
  try {
    // Compress: strip unnecessary lines for brevity
    const compact = JSON.stringify(sdp);
    return btoa(unescape(encodeURIComponent(compact)));
  } catch(e) { return ''; }
}

function mpDecodeSDP(code) {
  try {
    const json = decodeURIComponent(escape(atob(code.trim())));
    return JSON.parse(json);
  } catch(e) { return null; }
}

// --- HOST: Create offer ---
async function mpHostCreate() {
  mpRole = 'host';
  mpCreatePeer();
  const ch = mpPeer.createDataChannel('game', { ordered: true, maxRetransmits: 0 });
  mpSetupChannel(ch);

  // Collect ICE candidates
  const candidates = [];
  mpPeer.onicecandidate = (e) => {
    if (e.candidate) candidates.push(e.candidate);
  };

  const offer = await mpPeer.createOffer();
  await mpPeer.setLocalDescription(offer);

  // Wait for ICE gathering to complete
  await new Promise(resolve => {
    if (mpPeer.iceGatheringState === 'complete') return resolve();
    mpPeer.onicegatheringstatechange = () => {
      if (mpPeer.iceGatheringState === 'complete') resolve();
    };
    // Fallback timeout
    setTimeout(resolve, 5000);
  });

  return mpEncodeSDP(mpPeer.localDescription);
}

// --- HOST: Accept answer ---
async function mpHostAcceptAnswer(answerCode) {
  const answer = mpDecodeSDP(answerCode);
  if (!answer) throw new Error('Invalid answer code');
  await mpPeer.setRemoteDescription(new RTCSessionDescription(answer));
}

// --- GUEST: Join with offer ---
async function mpGuestJoin(offerCode) {
  const offer = mpDecodeSDP(offerCode);
  if (!offer) throw new Error('Invalid offer code');

  mpRole = 'guest';
  mpCreatePeer();

  // Listen for data channel from host
  mpPeer.ondatachannel = (e) => {
    mpSetupChannel(e.channel);
  };

  await mpPeer.setRemoteDescription(new RTCSessionDescription(offer));
  const answer = await mpPeer.createAnswer();
  await mpPeer.setLocalDescription(answer);

  // Wait for ICE gathering
  await new Promise(resolve => {
    if (mpPeer.iceGatheringState === 'complete') return resolve();
    mpPeer.onicegatheringstatechange = () => {
      if (mpPeer.iceGatheringState === 'complete') resolve();
    };
    setTimeout(resolve, 5000);
  });

  return mpEncodeSDP(mpPeer.localDescription);
}

// --- Disconnect ---
function mpDisconnect(reason) {
  if (mpPeer) {
    if (mpPeer._pingInterval) clearInterval(mpPeer._pingInterval);
    try { mpPeer.close(); } catch(e) {}
  }
  mpPeer = null;
  mpChannel = null;
  mpConnected = false;
  mpRole = null;
  mpFrameCount = 0;
  updateMpHud();
  if (reason) showSaveToast(`MP: ${reason}`, 'error');
}

// --- HUD badge ---
function updateMpHud() {
  const el = document.getElementById('mpHud');
  const adminStatus = document.getElementById('mpAdminStatus');
  if (!mpRole || !mpConnected) {
    if (el) { el.style.display = 'none'; }
    if (adminStatus) { adminStatus.textContent = 'Status: Not connected'; adminStatus.style.color = '#888'; }
    return;
  }
  if (el) {
    el.style.display = '';
    el.className = 'mp-hud ' + (mpRole === 'host' ? 'mp-hud-host' : 'mp-hud-guest');
    el.innerHTML = `üåê ONLINE ${mpRole === 'host' ? 'HOST' : 'GUEST'}` +
      (mpLatency ? `<span class="mp-hud-ping">${mpLatency}ms</span>` : '');
  }
  if (adminStatus) {
    adminStatus.textContent = `Status: Connected as ${mpRole === 'host' ? 'HOST' : 'GUEST'}` + (mpLatency ? ` ‚Äî ${mpLatency}ms` : '');
    adminStatus.style.color = mpRole === 'host' ? '#44ff88' : '#44ddff';
  }
}

// --- Per-frame sync (called from gameLoop) ---
function mpTick() {
  if (!mpConnected) return;
  mpFrameCount++;

  if (mpRole === 'host' && gameState === 'playing') {
    // Send state to guest
    if (mpFrameCount % MP_SYNC_INTERVAL === 0) {
      mpSend(getMpSyncState());
    }
    // Update ping display
    if (mpFrameCount % 120 === 0) updateMpHud();
  }

  if (mpRole === 'guest' && gameState === 'playing') {
    // Send local inputs to host
    if (mpFrameCount % MP_INPUT_INTERVAL === 0) {
      mpSend({
        t: 'i',
        i: {
          left: isLeft(), right: isRight(), up: isUp(), down: isDown(),
          jump: isJump(), jumpKey: isJumpKey(), shoot: isShoot(), grapple: isGrapple()
        }
      });
    }
  }
}

// --- Remote input functions (host uses these for player2) ---
function mpRemoteLeft()    { return mpRemoteInput.left; }
function mpRemoteRight()   { return mpRemoteInput.right; }
function mpRemoteUp()      { return mpRemoteInput.up; }
function mpRemoteDown()    { return mpRemoteInput.down; }
function mpRemoteJump()    { return mpRemoteInput.jump; }
function mpRemoteJumpKey() { return mpRemoteInput.jumpKey; }
function mpRemoteShoot()   { return mpRemoteInput.shoot; }
function mpRemoteGrapple() { return mpRemoteInput.grapple; }

// ============================================================
//  MULTIPLAYER UI ‚Äî Modal
// ============================================================
function showMpModal() {
  const container = document.getElementById('mpModalContainer');
  if (mpConnected) {
    // Show disconnect dialog
    container.innerHTML = `
      <div class="mp-modal-bg" onclick="if(event.target===this)closeMpModal()">
        <div class="mp-modal">
          <h2>üåê ONLINE MULTIPLAYER</h2>
          <div class="mp-status mp-status-connected">‚úì Connected as ${mpRole === 'host' ? 'HOST' : 'GUEST'} ‚Äî Latency: ${mpLatency}ms</div>
          <div style="text-align:center; margin-top:12px;">
            <button class="mp-btn mp-btn-danger" onclick="mpDisconnect('Disconnected');closeMpModal();">DISCONNECT</button>
            <button class="mp-btn mp-btn-close" onclick="closeMpModal()">CLOSE</button>
          </div>
        </div>
      </div>`;
    return;
  }

  container.innerHTML = `
    <div class="mp-modal-bg" onclick="if(event.target===this)closeMpModal()">
      <div class="mp-modal">
        <h2>üåê ONLINE MULTIPLAYER</h2>
        <p>Play co-op with a friend online! One player hosts, the other joins. No server needed ‚Äî direct peer-to-peer via WebRTC.</p>
        <div style="display:flex; gap:8px; justify-content:center; margin-bottom:10px;">
          <button class="mp-btn mp-btn-host" onclick="mpStartHost()">üñ•Ô∏è HOST GAME</button>
          <button class="mp-btn mp-btn-join" onclick="mpStartJoin()">üéÆ JOIN GAME</button>
          <button class="mp-btn mp-btn-close" onclick="closeMpModal()">CLOSE</button>
        </div>
        <div id="mpSteps"></div>
      </div>
    </div>`;
}

function closeMpModal() {
  document.getElementById('mpModalContainer').innerHTML = '';
}

// --- HOST FLOW ---
async function mpStartHost() {
  const steps = document.getElementById('mpSteps');
  steps.innerHTML = `<div class="mp-status mp-status-waiting">‚è≥ Generating invite code...</div>`;
  try {
    const offerCode = await mpHostCreate();
    steps.innerHTML = `
      <div class="mp-step">
        <span class="mp-step-num">1</span><span class="mp-step-label">Send this code to your friend:</span>
        <textarea id="mpOfferCode" readonly onclick="this.select()">${offerCode}</textarea>
        <button class="mp-btn mp-btn-copy" onclick="navigator.clipboard.writeText(document.getElementById('mpOfferCode').value);this.textContent='‚úì COPIED';">üìã COPY CODE</button>
      </div>
      <div class="mp-step">
        <span class="mp-step-num">2</span><span class="mp-step-label">Paste your friend's answer code:</span>
        <textarea id="mpAnswerInput" placeholder="Paste answer code here..."></textarea>
        <button class="mp-btn mp-btn-host" onclick="mpHostFinish()">‚úì CONNECT</button>
      </div>
      <div id="mpHostStatus"></div>`;
  } catch(e) {
    steps.innerHTML = `<div class="mp-status mp-status-error">‚úó Error: ${e.message}</div>`;
  }
}

async function mpHostFinish() {
  const code = document.getElementById('mpAnswerInput').value.trim();
  const status = document.getElementById('mpHostStatus');
  if (!code) { status.innerHTML = `<div class="mp-status mp-status-error">Please paste the answer code</div>`; return; }
  status.innerHTML = `<div class="mp-status mp-status-waiting">‚è≥ Connecting...</div>`;
  try {
    await mpHostAcceptAnswer(code);
    status.innerHTML = `<div class="mp-status mp-status-waiting">‚è≥ Establishing connection...</div>`;
    // Wait for channel to open (up to 10s)
    let waited = 0;
    const check = setInterval(() => {
      waited += 200;
      if (mpConnected) {
        clearInterval(check);
        closeMpModal();
      } else if (waited > 10000) {
        clearInterval(check);
        status.innerHTML = `<div class="mp-status mp-status-error">‚úó Connection timed out. Check the code and try again.</div>`;
      }
    }, 200);
  } catch(e) {
    status.innerHTML = `<div class="mp-status mp-status-error">‚úó ${e.message}</div>`;
  }
}

// --- JOIN FLOW ---
function mpStartJoin() {
  const steps = document.getElementById('mpSteps');
  steps.innerHTML = `
    <div class="mp-step">
      <span class="mp-step-num">1</span><span class="mp-step-label">Paste the host's invite code:</span>
      <textarea id="mpOfferInput" placeholder="Paste invite code here..."></textarea>
      <button class="mp-btn mp-btn-join" onclick="mpJoinFinish()">GENERATE ANSWER</button>
    </div>
    <div id="mpJoinSteps2"></div>`;
}

async function mpJoinFinish() {
  const code = document.getElementById('mpOfferInput').value.trim();
  const steps2 = document.getElementById('mpJoinSteps2');
  if (!code) { steps2.innerHTML = `<div class="mp-status mp-status-error">Please paste the invite code</div>`; return; }
  steps2.innerHTML = `<div class="mp-status mp-status-waiting">‚è≥ Generating answer...</div>`;
  try {
    const answerCode = await mpGuestJoin(code);
    steps2.innerHTML = `
      <div class="mp-step">
        <span class="mp-step-num">2</span><span class="mp-step-label">Send this answer code back to the host:</span>
        <textarea id="mpAnswerCode" readonly onclick="this.select()">${answerCode}</textarea>
        <button class="mp-btn mp-btn-copy" onclick="navigator.clipboard.writeText(document.getElementById('mpAnswerCode').value);this.textContent='‚úì COPIED';">üìã COPY CODE</button>
      </div>
      <div id="mpJoinStatus"><div class="mp-status mp-status-waiting">‚è≥ Waiting for host to connect...</div></div>`;
    // Wait for connection
    let waited = 0;
    const check = setInterval(() => {
      waited += 200;
      if (mpConnected) {
        clearInterval(check);
        closeMpModal();
      } else if (waited > 30000) {
        clearInterval(check);
        const el = document.getElementById('mpJoinStatus');
        if (el) el.innerHTML = `<div class="mp-status mp-status-error">‚úó Connection timed out.</div>`;
      }
    }, 200);
  } catch(e) {
    steps2.innerHTML = `<div class="mp-status mp-status-error">‚úó ${e.message}</div>`;
  }
}

function showOverlay(title, subtitle, action) {
  overlay.classList.remove('hidden');
  hud.classList.add('hidden');
  
  // Build run stats summary for gameover/victory
  let statsHtml = '';
  if (title === 'GAME OVER' || title === 'VICTORY!') {
    const duration = (Date.now() - runStats.startTime) / 1000;
    const mins = Math.floor(duration / 60);
    const secs = Math.floor(duration % 60);
    const achUnlocked = ACHIEVEMENTS.filter(a => achievements[a.id]).length;
    statsHtml = `
      <div style="display:flex; gap:20px; justify-content:center; margin:8px 0; font-size:9px; color:#aaa; font-family:'Segoe UI',sans-serif;">
        <span>üíÄ ${runStats.kills} kills</span>
        <span>üèÜ ${runStats.maxCombo}x combo</span>
        <span>‚è±Ô∏è ${mins}:${String(secs).padStart(2,'0')}</span>
        <span>üéñÔ∏è ${achUnlocked}/${ACHIEVEMENTS.length}</span>
      </div>
    `;
  }
  
  // Difficulty selector HTML
  const diffHtml = `
    <div class="diff-label">DIFFICULTY</div>
    <div class="diff-selector" id="diffSelectorOverlay">
      ${Object.keys(DIFFICULTY_PRESETS).map(k => {
        const p = DIFFICULTY_PRESETS[k];
        return `<button class="diff-btn${currentDifficulty === k ? ' active' : ''}" data-diff="${k}" onclick="setDifficulty('${k}')">${p.label}</button>`;
      }).join('')}
    </div>
  `;

  // Extra buttons for gameover/victory
  let extraBtns = '';
  if (title === 'GAME OVER' || title === 'VICTORY!') {
    extraBtns = `
    <div style="display:flex; gap:8px; margin-top:6px;">
      <button onclick="showShareModal()" style="padding:5px 12px; font-family:'Press Start 2P',monospace; font-size:7px; background:rgba(0,50,80,0.7); color:#44ddff; border:1px solid #44ddff; border-radius:4px; cursor:pointer;">üì§ SHARE SCORE</button>
      <button onclick="showImportScoreModal()" style="padding:5px 12px; font-family:'Press Start 2P',monospace; font-size:7px; background:rgba(0,50,30,0.7); color:#44ff88; border:1px solid #44ff88; border-radius:4px; cursor:pointer;">üì• IMPORT SCORE</button>
    </div>`;
  }
  // Save/load button (show when returning from playing)
  let saveLoadBtns = '';
  if (title !== 'GAME OVER' && title !== 'VICTORY!') {
    const hasSave = !!localStorage.getItem('contraForce_saveState');
    saveLoadBtns = hasSave ? `<div style="margin-top:8px;"><button onclick="loadGameState()" style="padding:5px 14px; font-family:'Press Start 2P',monospace; font-size:8px; background:rgba(40,60,10,0.7); color:#aaff44; border:1px solid #aaff44; border-radius:4px; cursor:pointer;">üìÇ CONTINUE SAVED GAME</button></div>` : '';
  }

  overlay.innerHTML = `
    <div style="margin-bottom:4px;">
      <button onclick="showMpModal()" style="padding:6px 14px; font-family:'Press Start 2P',monospace; font-size:8px; background:rgba(10,20,50,0.7); color:#88aaff; border:1px solid #88aaff; border-radius:4px; cursor:pointer;">üåê ONLINE MULTIPLAYER</button>
    </div>
    <h1>${title}</h1>
    <h2>${subtitle}</h2>
    ${statsHtml}
    <div class="blink">‚Äî ${action} ‚Äî</div>
    ${diffHtml}
    <div class="diff-label" style="margin-top:8px;">GAME MODE</div>
    <div class="mode-selector" id="modeSelectorOverlay">
      <button class="mode-btn${gameMode==='campaign'?' active':''}" data-mode="campaign" onclick="selectGameMode('campaign')"><span class="mode-icon">üéÆ</span><span class="mode-label">CAMPAIGN</span></button>
      <button class="mode-btn${gameMode==='endless'?' active':''}" data-mode="endless" onclick="selectGameMode('endless')"><span class="mode-icon">‚ôæÔ∏è</span><span class="mode-label">ENDLESS</span></button>
      <button class="mode-btn${gameMode==='bossrush'?' active':''}" data-mode="bossrush" onclick="selectGameMode('bossrush')"><span class="mode-icon">üëπ</span><span class="mode-label">BOSS RUSH</span></button>
      <button class="mode-btn${gameMode==='timeattack'?' active':''}" data-mode="timeattack" onclick="selectGameMode('timeattack')"><span class="mode-icon">‚è±Ô∏è</span><span class="mode-label">TIME ATTACK</span></button>
      <button class="mode-btn${gameMode==='newgameplus'?' active':''}" data-mode="newgameplus" onclick="selectGameMode('newgameplus')"><span class="mode-icon">‚ûï</span><span class="mode-label">NEW GAME+</span></button>
      <button class="mode-btn${gameMode==='challenge'?' active':''}" data-mode="challenge" onclick="selectGameMode('challenge')"><span class="mode-icon">üèÖ</span><span class="mode-label">CHALLENGES</span></button>
    </div>
    <div class="mode-desc" id="modeDescOverlay" style="font-size:6px;color:#aaa;margin:4px 0;font-family:'Press Start 2P',monospace;">${getModeDesc(gameMode)}</div>
    <button id="startBtn">START GAME</button>
    <div style="display:flex; gap:12px; margin-top:8px; align-items:center;">
      <button onclick="toggleAchievementsPanel()" style="padding:6px 14px; font-family:'Press Start 2P',monospace; font-size:8px; background:rgba(60,40,10,0.7); color:#ffaa00; border:1px solid #ffaa00; border-radius:4px; cursor:pointer;">üèÜ ACHIEVEMENTS</button>
      <button onclick="toggleLeaderboardPanel()" style="padding:6px 14px; font-family:'Press Start 2P',monospace; font-size:8px; background:rgba(10,40,60,0.7); color:#44ddff; border:1px solid #44ddff; border-radius:4px; cursor:pointer;">üìä LEADERBOARD</button>
      <button onclick="startTutorial()" style="padding:6px 14px; font-family:'Press Start 2P',monospace; font-size:8px; background:rgba(10,60,30,0.7); color:#44ff88; border:1px solid #44ff88; border-radius:4px; cursor:pointer;">üìñ TUTORIAL</button>
    </div>
    <div style="margin-top:6px; display:flex; align-items:center; gap:8px; justify-content:center;">
      <label style="font-family:'Press Start 2P',monospace; font-size:7px; color:#cc88ff; cursor:pointer; display:flex; align-items:center; gap:6px;">
        <input type="checkbox" id="storyModeOverlay" ${storyMode ? 'checked' : ''} onchange="storyMode=this.checked;localStorage.setItem('contraForce_storyMode',storyMode?'1':'0');const a=document.getElementById('s_storyMode');if(a)a.checked=storyMode;" style="cursor:pointer;">
        üìñ STORY MODE
      </label>
    </div>
    ${extraBtns}
    ${saveLoadBtns}
    <div class="controls-info">${controlsText()}</div>
  `;
  // Re-attach START button event listeners after replacing HTML
  const startBtn = document.getElementById('startBtn');
  if (startBtn) {
    startBtn.addEventListener('click', startGameSession);
    startBtn.addEventListener('touchend', e => {
      e.preventDefault();
      startGameSession();
    });
  }
}

// --- GAME LOOP ---
function gameLoop() {
  // Poll gamepads every frame
  pollGamepads();
  updateGpHud();

  // Handle gamepad Start button for starting game or advancing cutscene
  for (let gi = 0; gi < 2; gi++) {
    if (gpStart(gi)) {
      if (csActive && typeof csAdvance === 'function') {
        csAdvance();
      } else if (gameState === 'title' || gameState === 'gameover' || gameState === 'victory') {
        const sb = document.getElementById('startBtn');
        if (sb) sb.click();
      }
    }
    // Gamepad A button to advance cutscene
    if (csActive && gpJustPressed(gi, GP_A) && typeof csAdvance === 'function') {
      csAdvance();
    }
  }

  // Cutscene active ‚Äî skip normal game loop, cutscene has its own render loop
  if (csActive) {
    requestAnimationFrame(gameLoop);
    return;
  }

  // Hit freeze - skip update but still draw
  if (freezeFrames > 0) {
    freezeFrames--;
    if (gameState === 'playing') draw();
    requestAnimationFrame(gameLoop);
    return;
  }

  // Pause
  if (paused && gameState === 'playing') {
    updateShake();
    updateFlash();
    draw();
    // Draw pause overlay
    ctx.globalAlpha = 0.4;
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, GAME_W, GAME_H);
    ctx.globalAlpha = 1;
    ctx.fillStyle = '#fff';
    ctx.font = '16px "Press Start 2P"';
    ctx.textAlign = 'center';
    ctx.fillText('PAUSED', GAME_W/2, GAME_H/2);
    ctx.font = '8px "Press Start 2P"';
    ctx.fillStyle = '#888';
    ctx.fillText('Uncheck Pause in admin panel to resume', GAME_W/2, GAME_H/2 + 24);
    ctx.textAlign = 'left';
    updateMinimap();
    requestAnimationFrame(gameLoop);
    return;
  }

  // Slow motion
  if (slowMo > 0) {
    slowMo--;
    // Only update every N frames during slow-mo
    if (slowMo % 3 !== 0) {
      if (gameState === 'playing') {
        updateParticles();
        updatePopups();
        updateShake();
        updateFlash();
        draw();
      }
      requestAnimationFrame(gameLoop);
      return;
    }
  }

  update();
  updateShake();
  updateFlash();
  updatePopups();
  updateMusic();
  updateWeather();
  updateTransition();
  updateLights();
  updateAnimatedTiles();
  updateTutorial();
  mpTick();

  if (gameState === 'playing') {
    draw();
    if (tutorialActive) drawTutorialHUD();
    if (adminOpen) updateMinimap();
  } else if (gameState === 'charSelect') {
    drawCharSelect();
  } else if (gameState === 'title') {
    drawTitleScreen();
  } else if (gameState === 'demo') {
    updateDemoAI();
    draw();
    // Semi-transparent overlay so game is visible behind title elements
    ctx.fillStyle = 'rgba(0,0,10,0.55)';
    ctx.fillRect(0, 0, GAME_W, GAME_H);
    // Draw just the logo + demo indicator
    drawDemoOverlay();
  } else if (creditsActive) {
    updateCredits();
    drawCredits();
  }

  requestAnimationFrame(gameLoop);
}

// --- START GAME FUNCTION ---
function startGameSession() {
  if (gameState === 'playing') return;
  const wasTitle = (gameState === 'title');

  // Validate mode-specific requirements
  if (gameMode === 'newgameplus' && !canStartNGPlus()) {
    spawnPopup(400, 200, 'BEAT CAMPAIGN FIRST!', '#ff4444', 14);
    return;
  }
  if (gameMode === 'challenge' && !activeChallenge) {
    showChallengeSelect();
    return;
  }

  if (storyMode && gameMode === 'campaign') {
    const storyStart = () => {
      overlay.classList.add('hidden');
      const launchGame = () => {
        const stageKey = getCutsceneKey(stage);
        if (STORY[stageKey]) {
          playCutscene(stageKey, () => { actuallyStartGame(); });
        } else {
          actuallyStartGame();
        }
      };
      if (STORY.prologue && (wasTitle || stage === 1)) {
        playCutscene('prologue', launchGame);
      } else {
        launchGame();
      }
    };
    showCharSelect(storyStart);
    return;
  }

  // Non-story-mode: char select then start
  showCharSelect();
}

// --- CHARACTER SELECT SCREEN ---
let charSelectCB = null;
let charSelectIdx = 0;
const CHAR_KEYS = Object.keys(CHARACTERS);

function showCharSelect(callback) {
  checkCharacterUnlocks();
  charSelectCB = callback || null;
  charSelectIdx = CHAR_KEYS.indexOf(selectedCharacter);
  if (charSelectIdx < 0) charSelectIdx = 0;
  overlay.classList.add('hidden');
  hud.classList.add('hidden');
  gameState = 'charSelect';
}

function drawCharSelect() {
  ctx.fillStyle = '#000000';
  ctx.fillRect(0, 0, GAME_W, GAME_H);

  ctx.fillStyle = '#ff4444';
  ctx.font = '12px "Press Start 2P"';
  ctx.textAlign = 'center';
  ctx.fillText('SELECT CHARACTER', GAME_W / 2, 40);

  const cols = 3;
  const cellW = 200, cellH = 100;
  const ox = (GAME_W - cols * cellW) / 2;
  const oy = 65;

  for (let i = 0; i < CHAR_KEYS.length; i++) {
    const key = CHAR_KEYS[i];
    const ch = CHARACTERS[key];
    const col = i % cols, row = Math.floor(i / cols);
    const cx = ox + col * cellW + cellW / 2;
    const cy = oy + row * cellH + cellH / 2;
    const unlocked = isCharUnlocked(key);

    if (i === charSelectIdx) {
      ctx.strokeStyle = '#ffff00';
      ctx.lineWidth = 2;
      ctx.strokeRect(ox + col * cellW + 5, oy + row * cellH + 5, cellW - 10, cellH - 10);
      ctx.fillStyle = 'rgba(255,255,0,0.05)';
      ctx.fillRect(ox + col * cellW + 5, oy + row * cellH + 5, cellW - 10, cellH - 10);
    }

    if (unlocked) {
      ctx.fillStyle = ch.color;
      ctx.fillRect(cx - 8, cy - 20, 16, 26);
      ctx.fillRect(cx - 5, cy - 26, 10, 8);
      ctx.font = '8px "Press Start 2P"';
      ctx.fillText(ch.name, cx, cy + 20);
      ctx.fillStyle = '#aaaaaa';
      ctx.font = '6px "Press Start 2P"';
      ctx.fillText(ch.desc, cx, cy + 32);
      // Stat bars
      ctx.font = '5px "Press Start 2P"';
      ctx.textAlign = 'left';
      const bx = cx - 45;
      ctx.fillStyle = '#666';
      ctx.fillText('SPD', bx, cy + 42);
      ctx.fillStyle = '#33cc33';
      for (let s = 0; s < Math.round(ch.speedMult * 5); s++) ctx.fillRect(bx + 25 + s * 8, cy + 38, 6, 4);
      ctx.fillStyle = '#666';
      ctx.fillText('DMG', bx + 50, cy + 42);
      ctx.fillStyle = '#ff4444';
      for (let s = 0; s < Math.round(ch.damageMult * 5); s++) ctx.fillRect(bx + 75 + s * 8, cy + 38, 6, 4);
      ctx.textAlign = 'center';
    } else {
      ctx.fillStyle = '#333';
      ctx.fillRect(cx - 8, cy - 20, 16, 26);
      ctx.fillStyle = '#666';
      ctx.font = '12px "Press Start 2P"';
      ctx.fillText('?', cx, cy);
      ctx.font = '8px "Press Start 2P"';
      ctx.fillText(ch.name, cx, cy + 20);
      ctx.fillStyle = '#555';
      ctx.font = '5px "Press Start 2P"';
      ctx.fillText(ch.unlockDesc, cx, cy + 32);
    }
  }

  ctx.fillStyle = '#888';
  ctx.font = '7px "Press Start 2P"';
  ctx.textAlign = 'center';
  ctx.fillText('< > SELECT    ENTER CONFIRM    ESC BACK', GAME_W / 2, GAME_H - 20);

  const sel = CHARACTERS[CHAR_KEYS[charSelectIdx]];
  if (isCharUnlocked(CHAR_KEYS[charSelectIdx])) {
    ctx.fillStyle = '#ffcc44';
    ctx.font = '7px "Press Start 2P"';
    ctx.fillText('WEAPON: ' + sel.startWeapon + (sel.ability ? '  |  ' + sel.ability.toUpperCase() : ''), GAME_W / 2, GAME_H - 40);
  }
}

function handleCharSelectKey(e) {
  if (e.key === 'ArrowLeft' || e.key === 'a') {
    charSelectIdx = (charSelectIdx - 1 + CHAR_KEYS.length) % CHAR_KEYS.length;
    playSound('menu_select');
  } else if (e.key === 'ArrowRight' || e.key === 'd') {
    charSelectIdx = (charSelectIdx + 1) % CHAR_KEYS.length;
    playSound('menu_select');
  } else if (e.key === 'ArrowUp' || e.key === 'w') {
    charSelectIdx = (charSelectIdx - 3 + CHAR_KEYS.length) % CHAR_KEYS.length;
    playSound('menu_select');
  } else if (e.key === 'ArrowDown' || e.key === 's') {
    charSelectIdx = (charSelectIdx + 3) % CHAR_KEYS.length;
    playSound('menu_select');
  } else if (e.key === 'Enter') {
    const key = CHAR_KEYS[charSelectIdx];
    if (isCharUnlocked(key)) {
      selectedCharacter = key;
      playSound('powerup');
      if (charSelectCB) {
        charSelectCB();
      } else {
        actuallyStartGame();
      }
    } else {
      playSound('explosion');
    }
  } else if (e.key === 'Escape') {
    gameState = 'title';
    overlay.classList.remove('hidden');
  }
}


function actuallyStartGame() {
    applyDifficulty();
    resetRunStats();
    stageStartTime = Date.now();
    gameState = 'playing';
    overlay.classList.add('hidden');
    hud.classList.remove('hidden');
    // Close panels if open
    document.getElementById('achievementsPanel').classList.remove('open');
    document.getElementById('leaderboardPanel').classList.remove('open');
    hideChallengeSelect();
    updateAchHud();

    // --- Mode-specific initialization ---
    if (gameMode === 'endless') {
      initEndlessMode();
      initGame();
      // Clear pre-spawned enemies ‚Äî endless spawns its own
      enemies = [];
      startEndlessWave();
    } else if (gameMode === 'bossrush') {
      initBossRush();
      initGame();
      enemies = [];
      spawnPopup(player.x + player.w/2, player.y - 30, 'BOSS 1/10', '#ff8844', 14);
      setTimeout(() => { if (gameMode === 'bossrush' && gameState === 'playing') spawnBossRushBoss(); }, 1000);
    } else if (gameMode === 'timeattack') {
      initTimeAttack();
      initGame();
    } else if (gameMode === 'newgameplus') {
      if (!canStartNGPlus()) {
        gameState = 'title';
        overlay.classList.remove('hidden');
        hud.classList.add('hidden');
        spawnPopup(400, 200, 'BEAT CAMPAIGN FIRST!', '#ff4444', 14);
        return;
      }
      initNGPlus();
      initGame();
    } else if (gameMode === 'challenge') {
      initChallengeRun();
      initGame();
    } else {
      // Campaign mode (default)
      initGame();
    }

    // Notify online guest of new game start
    if (mpRole === 'host' && mpConnected) {
      coopMode = true;
      if (!player2) player2 = createPlayer(80);
      mpSend({
        t: 'start', stage,
        level: { map: level.map, cols: level.cols, rows: level.rows,
                 groundRow: level.groundRow, treasureMap: level.treasureMap || {} }
      });
    }
}

// Keyboard start (Enter key)
window.addEventListener('keydown', e => {
  if (rebindingAction) return; // Don't handle game keys during rebind
  if (csActive) return; // Don't handle game keys during cutscenes

  // Demo mode ‚Äî any key press stops demo and returns to title
  if (gameState === 'demo' || titleDemoActive) {
    stopDemoMode();
    return;
  }

  // Credits ‚Äî Enter or Escape skips credits
  if (creditsActive && (e.code === 'Enter' || e.code === 'Escape')) {
    creditsActive = false;
    if (creditsCallback) {
      creditsCallback();
      creditsCallback = null;
    }
    return;
  }

  // Title screen ‚Äî reset demo timer on any keypress
  if (gameState === 'title') {
    titleDemoTimer = 0;
  }

  if (gameState === 'charSelect') { handleCharSelectKey(e); return; }
  if (e.code === 'Enter') {
    startGameSession();
  }
  // Tab ‚Äî Achievements panel
  if (e.code === 'Tab') {
    e.preventDefault();
    // Close leaderboard if open
    document.getElementById('leaderboardPanel').classList.remove('open');
    toggleAchievementsPanel();
  }
  // L ‚Äî Leaderboard panel (only on title/gameover/victory or when paused)
  if (e.code === 'KeyL' && (gameState !== 'playing' || paused)) {
    document.getElementById('achievementsPanel').classList.remove('open');
    toggleLeaderboardPanel();
  }
  // Escape ‚Äî close any open panel
  if (e.code === 'Escape') {
    const achPanel = document.getElementById('achievementsPanel');
    const lbPanel = document.getElementById('leaderboardPanel');
    if (achPanel.classList.contains('open')) { achPanel.classList.remove('open'); e.preventDefault(); }
    if (lbPanel.classList.contains('open')) { lbPanel.classList.remove('open'); e.preventDefault(); }
  }
  // Zoom controls
  if (e.code === 'Equal' || e.code === 'NumpadAdd') {
    e.preventDefault();
    zoom = Math.min(ZOOM_MAX, zoom + ZOOM_STEP);
  }
  if (e.code === 'Minus' || e.code === 'NumpadSubtract') {
    e.preventDefault();
    zoom = Math.max(ZOOM_MIN, zoom - ZOOM_STEP);
  }
  if (e.code === 'Digit0' || e.code === 'Numpad0') {
    e.preventDefault();
    zoom = 1.0;
  }
});

// Mouse wheel zoom
canvas.addEventListener('wheel', e => {
  e.preventDefault();
  if (e.deltaY < 0) {
    zoom = Math.min(ZOOM_MAX, zoom + ZOOM_STEP);
  } else {
    zoom = Math.max(ZOOM_MIN, zoom - ZOOM_STEP);
  }
// --- ADMIN: Characters & Vehicles & Secrets ---
function unlockAllCharacters() {
  for (const key of Object.keys(CHARACTERS)) {
    unlockedCharacters[key] = true;
  }
  saveCharacterUnlocks();
  updateCharAdminList();
  showSaveToast('All characters unlocked!', 'success');
}

function resetCharacterUnlocks() {
  unlockedCharacters = {};
  saveCharacterUnlocks();
  updateCharAdminList();
  showSaveToast('Character unlocks reset', 'error');
}

function updateCharAdminList() {
  const el = document.getElementById('charAdminList');
  if (!el) return;
  el.innerHTML = Object.keys(CHARACTERS).map(k => {
    const c = CHARACTERS[k];
    const u = isCharUnlocked(k);
    return `<span style="color:${u ? c.color : '#555'}">${u ? '‚úì' : 'üîí'} ${c.name}</span>`;
  }).join(' &nbsp;|&nbsp; ');
}

function adminSpawnVehicle(type) {
  if (!player || !level) return;
  vehiclePickups.push({
    x: player.x + 60,
    y: player.y,
    w: VEHICLES[type].w,
    h: VEHICLES[type].h,
    type: type,
    collected: false
  });
  showSaveToast('Spawned ' + type + '!', 'success');
}

function updateSecretsAdmin() {
  const el = document.getElementById('secretsAdminInfo');
  if (!el) return;
  const found = Object.keys(secretsFound).length;
  const totalKills = localStorage.getItem('contraForce_totalKills') || '0';
  el.textContent = `Secrets found: ${found}/2 | Total kills: ${totalKills}`;
}

}, { passive: false });

// ============================================================
//  ADMIN PANEL
// ============================================================
const adminPanel = document.getElementById('adminPanel');
let adminOpen = false;
let spawnType = null;
let brushSize = 1;
let mouseDown = false;
let mouseBtn = 0;

function toggleAdmin() {
  adminOpen = !adminOpen;
  adminPanel.classList.toggle('open', adminOpen);
  // Clear all keys so player stops moving when admin opens
  if (adminOpen) {
    for (const k in keys) keys[k] = false;
    syncAdminPanel();
  } else {
    // Cancel any active rebind
    if (rebindingAction) {
      if (keybinds[rebindingAction][rebindingSlot] === '') {
        keybinds[rebindingAction].splice(rebindingSlot, 1);
      }
      rebindingAction = null;
      rebindingSlot = 0;
      if (rebindingEl) rebindingEl.classList.remove('listening');
      rebindingEl = null;
    }
  }
  updateCursor();
}

function updateCursor() {
  if (adminOpen && editorMode) canvas.style.cursor = 'crosshair';
  else if (adminOpen && spawnType) canvas.style.cursor = 'cell';
  else canvas.style.cursor = 'default';
}

// --- Slider bindings ---
const sliderBindings = [
  { id: 's_gravity',         get: () => gravity,          set: v => gravity = v },
  { id: 's_jumpForce',       get: () => jumpForce,        set: v => jumpForce = v },
  { id: 's_playerSpeed',     get: () => playerSpeed,      set: v => playerSpeed = v },
  { id: 's_maxFall',         get: () => maxFall,          set: v => maxFall = v },
  { id: 's_climbSpeed',      get: () => climbSpeed,       set: v => climbSpeed = v },
  { id: 's_bulletSpeed',     get: () => bulletSpeed,      set: v => bulletSpeed = v },
  { id: 's_enemyBulletSpeed',get: () => enemyBulletSpeed, set: v => enemyBulletSpeed = v },
  { id: 's_lives',           get: () => player ? player.lives : 3, set: v => { if (player) player.lives = Math.round(v); } },
  { id: 's_score',           get: () => score,            set: v => score = Math.round(v) },
  { id: 's_brushSize',       get: () => brushSize,        set: v => brushSize = Math.round(v) },
];

function showFusionList() {
  const el = document.getElementById('fusionListAdmin');
  if (!el) return;
  let html = '';
  for (const [key, f] of Object.entries(WEAPON_FUSIONS)) {
    html += `<div style="margin:2px 0"><span style="color:${f.color}">‚ñ†</span> <b>${key}</b> ‚Üí <span style="color:#ffaa00">${f.name}</span> ‚Äî ${f.desc}</div>`;
  }
  el.innerHTML = html;
}

function syncAdminPanel() {
  for (const b of sliderBindings) {
    const el = document.getElementById(b.id);
    if (!el) continue;
    el.value = b.get();
    const valEl = document.getElementById('v_' + b.id.slice(2));
    if (valEl) valEl.textContent = parseFloat(el.value).toFixed(el.step >= 1 ? 0 : el.step >= 0.5 ? 1 : 2);
  }
  document.getElementById('s_godMode').checked = godMode;

  // Audio controls sync
  const musicVolEl = document.getElementById('s_musicVol');
  if (musicVolEl) { musicVolEl.value = Math.round(musicVolume * 100); const v = document.getElementById('v_musicVol'); if(v) v.textContent = Math.round(musicVolume*100); }
  const sfxVolEl = document.getElementById('s_sfxVol');
  if (sfxVolEl) { sfxVolEl.value = Math.round(sfxVolume * 100); const v = document.getElementById('v_sfxVol'); if(v) v.textContent = Math.round(sfxVolume*100); }
  const musicEnEl = document.getElementById('s_musicEnabled');
  if (musicEnEl) musicEnEl.checked = musicEnabled;
  const sfxEnEl = document.getElementById('s_sfxEnabled');
  if (sfxEnEl) sfxEnEl.checked = sfxEnabled;

  // Touch controls sync
  const touchOpEl = document.getElementById('s_touchOpacity');
  if (touchOpEl) { touchOpEl.value = Math.round(touchOpacity * 100); const v = document.getElementById('v_touchOpacity'); if(v) v.textContent = Math.round(touchOpacity*100); }
  const touchSwEl = document.getElementById('s_touchSwap');

  // Accessibility sync
  const cbEl = document.getElementById('s_colorBlind');
  if (cbEl) cbEl.value = accessColorBlindMode;
  const aaEl = document.getElementById('s_aimAssist');
  if (aaEl) aaEl.checked = accessAimAssist;
  const ilEl = document.getElementById('s_infLives');
  if (ilEl) ilEl.checked = accessInfiniteLives;
  const hcEl = document.getElementById('s_highContrast');
  if (hcEl) hcEl.checked = accessHighContrastHUD;
  const lhEl = document.getElementById('s_largeHUD');
  if (lhEl) lhEl.checked = accessLargeHUD;
  const rsEl = document.getElementById('s_reduceShake');
  if (rsEl) rsEl.checked = accessScreenShakeReduced;
  // Speedrun sync
  const srEl = document.getElementById('s_speedrun');
  if (srEl) srEl.checked = speedrunEnabled;
  // Update PB list display
  const pbList = document.getElementById('speedrunPBList');
  if (pbList && speedrunPB.length > 0) {
    pbList.innerHTML = speedrunPB.map(s => `S${s.stage}: ${formatSpeedrunTime(s.time)}`).join('<br>');
  }
  if (touchSwEl) touchSwEl.checked = touchSwapped;
  const touchVibEl = document.getElementById('s_touchVibrate');
  if (touchVibEl) touchVibEl.checked = touchVibrate;
  document.getElementById('s_showHitboxes').checked = showHitboxes;
  document.getElementById('s_editorMode').checked = editorMode;
  document.getElementById('s_paused').checked = paused;
  document.getElementById('s_coopMode').checked = coopMode;
  // Story mode sync
  const storyEl = document.getElementById('s_storyMode');
  if (storyEl) storyEl.checked = storyMode;
}

// Bind slider events
for (const b of sliderBindings) {
  const el = document.getElementById(b.id);
  if (!el) continue;
  el.addEventListener('input', () => {
    b.set(parseFloat(el.value));
    const valEl = document.getElementById('v_' + b.id.slice(2));
    if (valEl) valEl.textContent = parseFloat(el.value).toFixed(el.step >= 1 ? 0 : el.step >= 0.5 ? 1 : 2);
  });
}

document.getElementById('s_godMode').addEventListener('change', e => { godMode = e.target.checked; });
document.getElementById('s_showHitboxes').addEventListener('change', e => { showHitboxes = e.target.checked; });
document.getElementById('s_editorMode').addEventListener('change', e => { editorMode = e.target.checked; updateCursor(); });
document.getElementById('s_paused').addEventListener('change', e => { paused = e.target.checked; });
document.getElementById('s_coopMode').addEventListener('change', e => { coopMode = e.target.checked; });

// --- Weapon buttons ---
(function buildWeaponBar() {
  const bar = document.getElementById('weaponBar');
  for (const wName of Object.keys(WEAPONS)) {
    const btn = document.createElement('button');
    btn.className = 'admin-btn';
    btn.textContent = wName;
    btn.style.fontSize = '9px';
    btn.onclick = () => { if (player) player.weapon = WEAPONS[wName]; };
    bar.appendChild(btn);
  }
})();

// --- Stage buttons ---
(function buildStageBar() {
  const bar = document.getElementById('stageBar');
  for (let s = 1; s <= MAX_STAGE; s++) {
    const t = getTheme(s);
    const btn = document.createElement('button');
    btn.className = 'admin-btn';
    btn.textContent = s + '';
    btn.title = t.name;
    btn.style.fontSize = '9px';
    btn.onclick = () => adminSetStage(s);
    bar.appendChild(btn);
  }
})();

// --- Spawn buttons ---
(function buildSpawnBar() {
  const bar = document.getElementById('spawnBar');
  const items = [
    ...Object.keys(ENEMY_TYPES).map(k => ({ label: k, cat: 'enemy' })),
    { label: 'Boss', cat: 'boss' },
    { label: '---', cat: 'sep' },
    ...['SPREAD','LASER','MACHINE','FLAME','ROCKET','HOMING','WAVE','LIFE'].map(k => ({ label: k, cat: 'powerup' })),
  ];
  for (const item of items) {
    if (item.cat === 'sep') { bar.appendChild(document.createElement('br')); continue; }
    const btn = document.createElement('button');
    btn.className = 'admin-btn';
    btn.textContent = item.label;
    btn.style.fontSize = '9px';
    btn.onclick = () => {
      spawnType = item;
      bar.querySelectorAll('.admin-btn').forEach(b => b.classList.remove('selected'));
      btn.classList.add('selected');
      updateCursor();
    };
    bar.appendChild(btn);
  }
})();

// --- Keybinds UI ---
const defaultKeybinds = JSON.parse(JSON.stringify(keybinds));

function buildKeybindsList() {
  const container = document.getElementById('keybindsList');
  container.innerHTML = '';
  const actions = ['left','right','up','down','jump','shoot','grapple'];
  for (const action of actions) {
    const row = document.createElement('div');
    row.className = 'keybind-row';

    const label = document.createElement('span');
    label.className = 'kb-label';
    label.textContent = action;
    row.appendChild(label);

    const keysDiv = document.createElement('div');
    keysDiv.className = 'kb-keys';

    // Existing key buttons
    keybinds[action].forEach((code, idx) => {
      const btn = document.createElement('span');
      btn.className = 'kb-btn';
      btn.innerHTML = keyName(code);
      // Add remove X if more than 1 key
      if (keybinds[action].length > 1) {
        const rm = document.createElement('span');
        rm.className = 'kb-remove';
        rm.textContent = '‚úï';
        rm.onclick = (e) => {
          e.stopPropagation();
          keybinds[action].splice(idx, 1);
          buildKeybindsList();
        };
        btn.appendChild(rm);
      }
      btn.onclick = () => startRebind(action, idx, btn);
      keysDiv.appendChild(btn);
    });

    // Add button (max 3 keys per action)
    if (keybinds[action].length < 3) {
      const addBtn = document.createElement('span');
      addBtn.className = 'kb-btn kb-add';
      addBtn.textContent = '+';
      addBtn.title = 'Add key';
      addBtn.onclick = () => {
        keybinds[action].push('');
        const newIdx = keybinds[action].length - 1;
        buildKeybindsList();
        // Auto-start listening on the new slot
        const allBtns = container.querySelectorAll('.keybind-row');
        const actionRow = allBtns[actions.indexOf(action)];
        const lastKb = actionRow.querySelectorAll('.kb-btn:not(.kb-add)');
        if (lastKb.length) startRebind(action, newIdx, lastKb[lastKb.length - 1]);
      };
      keysDiv.appendChild(addBtn);
    }

    row.appendChild(keysDiv);
    container.appendChild(row);
  }
}

function startRebind(action, slot, el) {
  // Cancel any existing rebind
  if (rebindingEl) rebindingEl.classList.remove('listening');
  rebindingAction = action;
  rebindingSlot = slot;
  rebindingEl = el;
  el.classList.add('listening');
  el.innerHTML = '...';
}

function finishRebind(code) {
  if (!rebindingAction) return;
  if (code === 'Escape') {
    // Cancel ‚Äî if the slot is empty, remove it
    if (keybinds[rebindingAction][rebindingSlot] === '') {
      keybinds[rebindingAction].splice(rebindingSlot, 1);
    }
  } else if (code === 'Backquote' || code === 'Enter') {
    // Reserved keys ‚Äî ignore, keep listening
    return;
  } else {
    keybinds[rebindingAction][rebindingSlot] = code;
  }
  if (rebindingEl) rebindingEl.classList.remove('listening');
  rebindingAction = null;
  rebindingSlot = 0;
  rebindingEl = null;
  buildKeybindsList();
}

function resetKeybinds() {
  for (const action of Object.keys(defaultKeybinds)) {
    keybinds[action] = [...defaultKeybinds[action]];
  }
  buildKeybindsList();
}

buildKeybindsList();

// --- Brush selector ---
function setBrush(b, el) {
  editorBrush = b;
  document.querySelectorAll('#brushBar .admin-btn').forEach(btn => btn.classList.remove('selected'));
  if (el) el.classList.add('selected');
}

// --- Admin actions ---
function adminSetStage(s) {
  stage = s;
  initGame();
  if (gameState !== 'playing') {
    gameState = 'playing';
    overlay.classList.add('hidden');
    hud.classList.remove('hidden');
  }
}

function adminKillAllEnemies() {
  for (const e of enemies) {
    if (!e.isBoss) {
      const cx = e.x + e.w/2, cy = e.y + e.h/2;
      spawnParticles(cx, cy, '#ff4400', 10, 4, 20);
      addScore(e.score);
    }
  }
  enemies = enemies.filter(e => e.isBoss);
}

function adminRespawnEnemies() {
  spawnEnemies(level, stage);
}

function adminClearBullets() {
  bullets = [];
  enemyBullets = [];
  particles = [];
}

function adminRegenLevel() {
  level = generateLevel(stage);
  spawnEnemies(level, stage);
  spawnPowerups(level, stage);
  spawnObjects(level, stage);
  spawnDecorations(level, stage);
  camX = 0; camY = 0;
  player.x = 60;
  for (let r = 0; r < level.rows; r++) {
    if (level.map[r][2] === 1) { player.y = r * TILE - player.h; break; }
  }
}

function adminFlattenGround() {
  if (!level) return;
  const gr = level.groundRow;
  for (let c = 0; c < level.cols; c++) {
    level.map[gr][c] = 1;
    level.map[level.rows - 1][c] = 1;
  }
}

function adminClearMap() {
  if (!level) return;
  for (let r = 0; r < level.rows; r++) {
    for (let c = 0; c < level.cols; c++) {
      level.map[r][c] = 0;
    }
  }
  // Keep bottom 2 rows as ground
  const gr = level.rows - 2;
  for (let c = 0; c < level.cols; c++) {
    level.map[gr][c] = 1;
    level.map[level.rows - 1][c] = 1;
  }
}

function adminExportLevel() {
  if (!level) return;
  const data = { cols: level.cols, rows: level.rows, groundRow: level.groundRow, map: level.map };
  const json = JSON.stringify(data);
  navigator.clipboard.writeText(json).then(() => {
    alert('Level JSON copied to clipboard! (' + json.length + ' chars)');
  }).catch(() => {
    const ta = document.createElement('textarea');
    ta.value = json; document.body.appendChild(ta);
    ta.select(); document.execCommand('copy');
    document.body.removeChild(ta);
    alert('Level JSON copied to clipboard!');
  });
}

function adminImportLevel() {
  const json = prompt('Paste level JSON:');
  if (!json) return;
  try {
    const data = JSON.parse(json);
    if (data.map && data.cols && data.rows) {
      level.map = data.map;
      level.cols = data.cols;
      level.rows = data.rows;
      level.groundRow = data.groundRow || data.rows - 2;
      alert('Level imported! (' + data.cols + ' x ' + data.rows + ')');
    }
  } catch(e) { alert('Invalid JSON: ' + e.message); }
}

// --- Canvas mouse events for editor & spawner ---
function canvasToWorld(e) {
  const rect = canvas.getBoundingClientRect();
  const scaleX = GAME_W / rect.width;
  const scaleY = GAME_H / rect.height;
  const cx = (e.clientX - rect.left) * scaleX;
  const cy = (e.clientY - rect.top) * scaleY;
  // Convert screen to world
  const wx = cx / zoom + camX;
  const wy = cy / zoom + camY;
  return { wx, wy };
}

function paintTile(wx, wy) {
  if (!level) return;
  if (!level.treasureMap) level.treasureMap = {};
  const half = Math.floor(brushSize / 2);
  const centerC = Math.floor(wx / TILE);
  const centerR = Math.floor(wy / TILE);
  const brush = mouseBtn === 2 ? 0 : editorBrush;
  for (let dr = -half; dr <= half; dr++) {
    for (let dc = -half; dc <= half; dc++) {
      const r = centerR + dr;
      const c = centerC + dc;
      if (r >= 0 && r < level.rows && c >= 0 && c < level.cols) {
        level.map[r][c] = brush;
        if (brush === 4) {
          const tTypes = ['gem_small','gem_big','gold','shield','speed','life','weapon'];
          level.treasureMap[r + ',' + c] = tTypes[Math.floor(Math.random() * tTypes.length)];
        } else {
          delete level.treasureMap[r + ',' + c];
        }
      }
    }
  }
}

function handleSpawn(wx, wy) {
  if (!spawnType || !level) return;
  if (spawnType.cat === 'enemy') {
    const type = ENEMY_TYPES[spawnType.label];
    enemies.push({
      x: wx - type.w/2, y: wy - type.h,
      ...type, maxHp: type.hp,
      fireTimer: 0, active: true, facing: -1,
      patrolStart: (wx - 150), patrolEnd: (wx + 150),
      dir: -1, vy: 0, onGround: false, jumpTimer: 0, shieldFacing: -1,
    });
  } else if (spawnType.cat === 'boss') {
    enemies.push({
      x: wx - 24, y: wy - 64,
      w: 48, h: 64, hp: 30 + stage * 15, maxHp: 30 + stage * 15,
      speed: 1, score: 2000, color: '#ff2222',
      fireRate: 25, fireTimer: 0, shootRange: 500,
      active: true, facing: -1, isBoss: true, etype: 'boss',
      patrolStart: wx - 200, patrolEnd: wx + 200,
      dir: -1, phase: 0, phaseTimer: 0, vy: 0, onGround: false,
    });
  } else if (spawnType.cat === 'powerup') {
    powerups.push({
      x: wx - 10, y: wy - 10,
      w: 20, h: 20, type: spawnType.label,
      bobPhase: Math.random() * 6.28,
    });
  }
  spawnType = null;
  document.querySelectorAll('#spawnBar .admin-btn').forEach(b => b.classList.remove('selected'));
  updateCursor();
}

canvas.addEventListener('mousedown', e => {
  if (!adminOpen) return;
  mouseDown = true;
  mouseBtn = e.button;
  const { wx, wy } = canvasToWorld(e);

  // Shift+click = teleport player
  if (e.shiftKey && gameState === 'playing' && player) {
    player.x = wx - player.w / 2;
    player.y = wy - player.h;
    player.vx = 0;
    player.vy = 0;
    player.onLadder = false;
    return;
  }

  if (spawnType && gameState === 'playing') {
    handleSpawn(wx, wy);
    return;
  }
  if (editorMode && level) {
    e.preventDefault();
    paintTile(wx, wy);
  }
});

canvas.addEventListener('mousemove', e => {
  if (!adminOpen || !mouseDown || !editorMode || !level) return;
  const { wx, wy } = canvasToWorld(e);
  paintTile(wx, wy);
});

canvas.addEventListener('mouseup', () => { mouseDown = false; });
canvas.addEventListener('mouseleave', () => { mouseDown = false; });
canvas.addEventListener('contextmenu', e => {
  if (adminOpen && editorMode) e.preventDefault();
});

// --- Minimap ---
const minimapCanvas = document.getElementById('minimapCanvas');
const mmCtx = minimapCanvas.getContext('2d');

function updateMinimap() {
  if (!level || !minimapCanvas) return;
  const mw = minimapCanvas.width;
  const mh = minimapCanvas.height;
  mmCtx.clearRect(0, 0, mw, mh);
  mmCtx.fillStyle = '#0a0a1e';
  mmCtx.fillRect(0, 0, mw, mh);

  const scaleX = mw / (level.cols * TILE);
  const scaleY = mh / (level.rows * TILE);

  // Draw underground fill (batch solid)
  const ugStartY = level.groundRow * TILE * scaleY;
  mmCtx.fillStyle = '#3a3525';
  mmCtx.fillRect(0, ugStartY, mw, mh - ugStartY);

  // Draw tiles (surface + non-solid underground features)
  for (let r = 0; r < level.rows; r++) {
    for (let c = 0; c < level.cols; c++) {
      const v = level.map[r][c];
      // Skip solid underground tiles (already filled)
      if (r > level.groundRow && v === 1) continue;
      if (v === 0) {
        // Draw air pockets underground as dark
        if (r > level.groundRow) {
          mmCtx.fillStyle = '#0a0a1e';
          mmCtx.fillRect(c * TILE * scaleX, r * TILE * scaleY, Math.ceil(TILE * scaleX), Math.ceil(TILE * scaleY));
        }
        continue;
      }
      mmCtx.fillStyle = v === 1 ? '#556655' : v === 4 ? '#ccaa22' : v === 2 ? '#8B6914' : '#2266aa';
      mmCtx.fillRect(c * TILE * scaleX, r * TILE * scaleY, Math.ceil(TILE * scaleX), Math.ceil(TILE * scaleY));
    }
  }

  // Draw enemies
  for (const e of enemies) {
    if (!e.active) continue;
    mmCtx.fillStyle = e.isBoss ? '#ff00ff' : '#ff3333';
    mmCtx.fillRect(e.x * scaleX, e.y * scaleY, Math.max(2, e.w * scaleX), Math.max(2, e.h * scaleY));
  }

  // Draw powerups
  mmCtx.fillStyle = '#44ffff';
  for (const pw of powerups) {
    mmCtx.fillRect(pw.x * scaleX - 1, pw.y * scaleY - 1, 3, 3);
  }

  // Draw treasure items
  mmCtx.fillStyle = '#ffcc00';
  for (const t of treasureItems) {
    mmCtx.fillRect(t.x * scaleX - 1, t.y * scaleY - 1, 3, 3);
  }

  // Draw objects
  mmCtx.fillStyle = '#aa8844';
  for (const o of objects) {
    mmCtx.fillRect(o.x * scaleX, o.y * scaleY, Math.max(2, o.w * scaleX), Math.max(1, o.h * scaleY));
  }

  // Draw player
  if (player && !player.dead) {
    mmCtx.fillStyle = '#44ff44';
    mmCtx.fillRect(player.x * scaleX - 1, player.y * scaleY - 1, 4, 4);
    // Player glow
    mmCtx.fillStyle = 'rgba(68, 255, 68, 0.3)';
    mmCtx.beginPath();
    mmCtx.arc(player.x * scaleX + 1, player.y * scaleY + 1, 6, 0, Math.PI * 2);
    mmCtx.fill();
  }

  // Camera viewport rectangle
  const vw = viewW();
  const vh = viewH();
  mmCtx.strokeStyle = '#ffffff';
  mmCtx.lineWidth = 1;
  mmCtx.globalAlpha = 0.6;
  mmCtx.strokeRect(camX * scaleX, camY * scaleY, vw * scaleX, vh * scaleY);
  mmCtx.globalAlpha = 1;
}

// Click minimap to jump camera
minimapCanvas.addEventListener('click', e => {
  if (!level) return;
  const rect = minimapCanvas.getBoundingClientRect();
  const mx = (e.clientX - rect.left) / rect.width;
  const my = (e.clientY - rect.top) / rect.height;
  const worldX = mx * level.cols * TILE;
  const worldY = my * level.rows * TILE;
  camX = worldX - viewW() / 2;
  camY = worldY - viewH() / 2;
  if (camX < 0) camX = 0;
  if (camY < 0) camY = 0;
  const maxCamX = level.cols * TILE - viewW();
  const maxCamY = level.rows * TILE - viewH();
  if (camX > maxCamX) camX = Math.max(0, maxCamX);
  if (camY > maxCamY) camY = Math.max(0, maxCamY);
});

// Backtick key to toggle admin
window.addEventListener('keydown', e => {
  if (e.code === 'Backquote' && !rebindingAction) {
    e.preventDefault();
    toggleAdmin();
  }
});

// Periodic sync
setInterval(() => { if (adminOpen) syncAdminPanel(); }, 500);

// Handle resize ‚Äî scale game to fill viewport
function resize() {
  const wrapper = document.getElementById('gameWrapper');
  if (!wrapper) return;
  const ww = window.innerWidth;
  const wh = window.innerHeight;
  const scale = Math.min(ww / GAME_W, wh / GAME_H);
  wrapper.style.transform = 'scale(' + scale + ')';
  wrapper.style.left = ((ww - GAME_W * scale) / 2) + 'px';
  wrapper.style.top = ((wh - GAME_H * scale) / 2) + 'px';
}
window.addEventListener('resize', resize);
resize();

// Initialize mobile touch controls
initTouchControls();

// Initialize animated sprite sheets
initSpriteSheets();

// Electron desktop app integration
if (window.electronAPI) {
  console.log('[Electron] Running as desktop app');
  window.electronAPI.getVersion().then(v => {
    console.log('[Electron] Version:', v);
    const el = document.getElementById('stageDisplay');
    if (el) el.title = 'CONTRA FORCE v' + v;
  });
  // Listen for fullscreen state changes
  window.electronAPI.onFullscreenChange(isFs => {
    document.body.classList.toggle('electron-fullscreen', isFs);
  });
}

// Initialize start button
const startBtn = document.getElementById('startBtn');
if (startBtn) {
  startBtn.addEventListener('click', startGameSession);
  startBtn.addEventListener('touchend', e => {
    e.preventDefault();
    startGameSession();
  });
}

// Sync story mode checkbox with saved state
const storyInit = document.getElementById('storyModeInit');
if (storyInit) storyInit.checked = storyMode;

// HUD achievement/leaderboard buttons
document.getElementById('achHudBtn').addEventListener('click', toggleAchievementsPanel);
document.getElementById('lbHudBtn').addEventListener('click', toggleLeaderboardPanel);

// Initialize HUD counter
updateAchHud();

// Initialize particle editor UI
updateParticleEditorUI();

// Initialize title screen
initTitleStars();

gameLoop();
</script>
</body>
</html>
